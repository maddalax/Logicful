import './ComboBox.css.proxy.js';
/* src/inputs/ComboBox.svelte generated by Svelte v3.25.1 */
import {
	SvelteComponent,
	add_flush_callback,
	append,
	attr,
	bind,
	binding_callbacks,
	bubble,
	check_outros,
	create_component,
	destroy_component,
	detach,
	element,
	empty,
	group_outros,
	init,
	insert,
	listen,
	mount_component,
	noop,
	safe_not_equal,
	set_style,
	space,
	stop_propagation,
	transition_in,
	transition_out
} from "../../web_modules/svelte/internal.js";

import { afterUpdate, onDestroy, onMount, tick } from "../../web_modules/svelte.js";
import { LoadState } from "../models/LoadState.js";
import { stringEquals, fastEquals } from "../util/Compare.js";
import { subscribeFieldChange } from "../event/FieldEvent.js";
import { isFunction, isString } from "../guards/Guard.js";
import { randomString } from "../util/Generate.js";
import { dispatch, subscribeComponent } from "../event/EventBus.js";
import Fuse from "../../web_modules/fusejs.js";
import formStore from "../store/FormStore.js";
import { nullOrEmpty } from "../util/Compare.js";
import Label from "./Label.js";
import Select from "../components/select/Select.js";

function create_if_block_4(ctx) {
	let label;
	let current;
	label = new Label({ props: { field: /*field*/ ctx[0] } });

	return {
		c() {
			create_component(label.$$.fragment);
		},
		m(target, anchor) {
			mount_component(label, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const label_changes = {};
			if (dirty & /*field*/ 1) label_changes.field = /*field*/ ctx[0];
			label.$set(label_changes);
		},
		i(local) {
			if (current) return;
			transition_in(label.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(label.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(label, detaching);
		}
	};
}

// (240:2) {:else}
function create_else_block(ctx) {
	let t;
	let if_block1_anchor;
	let current;
	let if_block0 = /*options*/ ctx[3] && create_if_block_3(ctx);
	let if_block1 = /*field*/ ctx[0].helperText && create_if_block_2(ctx);

	return {
		c() {
			if (if_block0) if_block0.c();
			t = space();
			if (if_block1) if_block1.c();
			if_block1_anchor = empty();
		},
		m(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert(target, t, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert(target, if_block1_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (/*options*/ ctx[3]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty & /*options*/ 8) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_3(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(t.parentNode, t);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (/*field*/ ctx[0].helperText) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_2(ctx);
					if_block1.c();
					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			current = true;
		},
		o(local) {
			transition_out(if_block0);
			current = false;
		},
		d(detaching) {
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach(t);
			if (if_block1) if_block1.d(detaching);
			if (detaching) detach(if_block1_anchor);
		}
	};
}

// (238:39) 
function create_if_block_1(ctx) {
	let p;

	return {
		c() {
			p = element("p");
			p.textContent = "Failed to load.";
		},
		m(target, anchor) {
			insert(target, p, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(p);
		}
	};
}

// (232:2) {#if state === LoadState.Loading}
function create_if_block(ctx) {
	let div1;

	return {
		c() {
			div1 = element("div");
			div1.innerHTML = `<div class="spinner-border" role="status"><span class="sr-only">Loading...</span></div>`;
		},
		m(target, anchor) {
			insert(target, div1, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div1);
		}
	};
}

// (241:4) {#if options}
function create_if_block_3(ctx) {
	let div;
	let select_1;
	let updating_selectedValue;
	let current;
	let mounted;
	let dispose;

	function select_1_selectedValue_binding(value) {
		/*select_1_selectedValue_binding*/ ctx[8].call(null, value);
	}

	let select_1_props = {
		inputAttributes: { autocomplete: "off" },
		items: /*options*/ ctx[3],
		isVirtualList: /*options*/ ctx[3].length > 25,
		itemFilter: /*itemFilter*/ ctx[4],
		showChevron: true
	};

	if (/*selectedValue*/ ctx[2] !== void 0) {
		select_1_props.selectedValue = /*selectedValue*/ ctx[2];
	}

	select_1 = new Select({ props: select_1_props });
	binding_callbacks.push(() => bind(select_1, "selectedValue", select_1_selectedValue_binding));
	select_1.$on("select", /*onSelect*/ ctx[5]);
	select_1.$on("clear", /*onClear*/ ctx[6]);

	return {
		c() {
			div = element("div");
			create_component(select_1.$$.fragment);
			attr(div, "class", "themed svelte-3dptv7");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(select_1, div, null);
			current = true;

			if (!mounted) {
				dispose = listen(div, "click", stop_propagation(/*click_handler*/ ctx[7]));
				mounted = true;
			}
		},
		p(ctx, dirty) {
			const select_1_changes = {};
			if (dirty & /*options*/ 8) select_1_changes.items = /*options*/ ctx[3];
			if (dirty & /*options*/ 8) select_1_changes.isVirtualList = /*options*/ ctx[3].length > 25;

			if (!updating_selectedValue && dirty & /*selectedValue*/ 4) {
				updating_selectedValue = true;
				select_1_changes.selectedValue = /*selectedValue*/ ctx[2];
				add_flush_callback(() => updating_selectedValue = false);
			}

			select_1.$set(select_1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(select_1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(select_1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(select_1);
			mounted = false;
			dispose();
		}
	};
}

// (254:4) {#if field.helperText}
function create_if_block_2(ctx) {
	let div;
	let small;
	let raw_value = (/*field*/ ctx[0].helperText ?? "") + "";

	return {
		c() {
			div = element("div");
			small = element("small");
			attr(small, "class", "form-text text-muted");
			set_style(div, "padding-top", "0.3em");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, small);
			small.innerHTML = raw_value;
		},
		p(ctx, dirty) {
			if (dirty & /*field*/ 1 && raw_value !== (raw_value = (/*field*/ ctx[0].helperText ?? "") + "")) small.innerHTML = raw_value;;
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

function create_fragment(ctx) {
	let div;
	let t;
	let current_block_type_index;
	let if_block1;
	let current;
	let if_block0 = !/*field*/ ctx[0].hideLabel && create_if_block_4(ctx);
	const if_block_creators = [create_if_block, create_if_block_1, create_else_block];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*state*/ ctx[1] === LoadState.Loading) return 0;
		if (/*state*/ ctx[1] === LoadState.Failed) return 1;
		return 2;
	}

	current_block_type_index = select_block_type(ctx, -1);
	if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			div = element("div");
			if (if_block0) if_block0.c();
			t = space();
			if_block1.c();
		},
		m(target, anchor) {
			insert(target, div, anchor);
			if (if_block0) if_block0.m(div, null);
			append(div, t);
			if_blocks[current_block_type_index].m(div, null);
			current = true;
		},
		p(ctx, [dirty]) {
			if (!/*field*/ ctx[0].hideLabel) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty & /*field*/ 1) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_4(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(div, t);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block1 = if_blocks[current_block_type_index];

				if (!if_block1) {
					if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block1.c();
				}

				transition_in(if_block1, 1);
				if_block1.m(div, null);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);
			current = true;
		},
		o(local) {
			transition_out(if_block0);
			transition_out(if_block1);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (if_block0) if_block0.d();
			if_blocks[current_block_type_index].d();
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	
	let initialized = false;
	let dropdownId;
	let open = false;
	let fuse;
	let { field } = $$props;
	let prevOptions = null;
	let activeToolTip;

	onDestroy(() => {
		disposeToolTip();
	});

	subscribeComponent("show_field_config", props => {
		value = "";
		$$invalidate(3, options = []);
		setup();
	});

	subscribeComponent("combobox_get_options", props => {
		if (props.id === field.id) {
			return options;
		}
	});

	subscribeComponent("combobox_open", props => {
		if (props.id !== field.id) {
			doClose();
		}
	});

	subscribeComponent("option_set_modified", set => {
		if (set.value === field.options) {
			setup();
		}

		if (field.configTarget) {
			setup();
		}
	});

	subscribeFieldChange(onMount, newField => {
		if (newField.id === field.id) {
			value = newField.value ?? "";
			normalizeValue();
		}
	});

	onMount(async () => {
		dropdownId = `${field.name}-${randomString()}`;
		initialized = false;
		value = formStore.getValue(field.id);
		await setup();
	});

	function createFuse() {
		if (!options) {
			return new Fuse([]);
		}

		return new Fuse(options, { keys: ["label", "value"] });
	}

	async function setup() {
		$$invalidate(1, state = LoadState.Loading);
		$$invalidate(3, options = []);

		try {
			if (field.options?.type === "remote" || isString(field.options) || field.options?.type === "local" && isString(field.options.value)) {
				const url = field.options.value || field.options;
				const result = await fetch(url);
				const data = await result.json();

				if (!data) {
					return;
				}

				const parsed = [];

				if (field.loadTransformer) {
					$$invalidate(3, options = field.loadTransformer(data) ?? []);
				} else {
					Object.keys(data).forEach(key => {
						parsed.push({ value: data[key], label: key });
					});

					$$invalidate(3, options = parsed ?? []);
				}
			} else {
				const value = field.options?.value;
				const data = isFunction(value) ? await value() : await value;

				$$invalidate(3, options = (field.loadTransformer
				? field.loadTransformer(data)
				: data) ?? []);
			}

			fuse = createFuse();
			normalizeValue();
			$$invalidate(1, state = LoadState.Finished);
		} catch(ex) {
			console.log(ex);
			$$invalidate(3, options = []);
			$$invalidate(1, state = LoadState.Failed);
		}
	}

	let state = LoadState.Loading;
	let value = "";
	let selectedValue;
	let options = [];
	let filteredBy = "";
	let filtered = new Set();

	function normalizeValue() {
		const option = options?.find(w => stringEquals(w.label, value) || stringEquals(w.value, value));

		if (option) {
			value = option.label ?? "";
			$$invalidate(2, selectedValue = option);
		}
	}

	function select(option) {
		doClose();
		value = option.value;
		$$invalidate(0, field.value = option.value, field);

		formStore.set(field, {
			field: "value",
			value: option.value,
			fromUser: true
		});

		field.onChange?.(field.value);
	}

	function onBodyClick() {
		doClose();
	}

	function onSearch(query) {
		if (options.length === 0) {
			filtered = new Set();
		} else if (query == null || query === "") {
			filtered = new Set();
		} else {
			const result = fuse.search(query);
			filteredBy = "";
			filtered = new Set(result.map(r => r.item.value));
			filteredBy = query;
		}
	}

	function onKeyDown(e) {
		if (e.key === "Escape") {
			doClose();
		} else if (e.key === "ArrowDown") {
			e.preventDefault();
			const option = document.getElementById(`${field.id}-option-0`);
			option?.focus({ preventScroll: true });
		}
	}

	function doOpen() {
		dispatch("combobox_open", { id: field.id });
		open = true;
	}

	function doClose() {
		disposeToolTip();
		open = false;
		filtered.clear();
		filteredBy = "";
	}

	function disposeToolTip() {
		if (activeToolTip) {
			try {
				activeToolTip.dispose();
			} catch(ex) {
				
			}
		}

		activeToolTip = undefined;
	}

	function showTooltip(option, id) {
		//@ts-ignore
		activeToolTip = new bootstrap.Tooltip(document.getElementById(id),
		{
				title: option.label,
				placement: "top",
				trigger: "manual"
			});

		setTimeout(
			() => {
				activeToolTip.show();
			},
			600
		);
	}

	function itemFilter(label, filterText, option) {
		if (filteredBy != filterText) {
			onSearch(filterText);
		}

		return filtered.has(option.value);
	}

	function onSelect(e) {
		e.stopPropagation();
		$$invalidate(0, field.value = e.detail.value, field);

		formStore.set(field, {
			field: "value",
			value: field.value,
			fromUser: true
		});
	}

	function onClear() {
		$$invalidate(0, field.value = undefined, field);

		formStore.set(field, {
			field: "value",
			value: undefined,
			fromUser: true
		});
	}

	function onMouseDown(option, id) {
		disposeToolTip();
		showTooltip(option, id);
	}

	function click_handler(event) {
		bubble($$self, event);
	}

	function select_1_selectedValue_binding(value) {
		selectedValue = value;
		$$invalidate(2, selectedValue);
	}

	$$self.$$set = $$props => {
		if ("field" in $$props) $$invalidate(0, field = $$props.field);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*prevOptions, field*/ 8193) {
			$: {
				if (!fastEquals(prevOptions, field.options)) {
					$$invalidate(13, prevOptions = field.options ?? []);
					setup();
				}
			}
		}
	};

	return [
		field,
		state,
		selectedValue,
		options,
		itemFilter,
		onSelect,
		onClear,
		click_handler,
		select_1_selectedValue_binding
	];
}

class ComboBox extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, { field: 0 });
	}
}

export default ComboBox;