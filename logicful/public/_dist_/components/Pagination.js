import './Pagination.css.proxy.js';
/* src/components/Pagination.svelte generated by Svelte v3.25.1 */
import {
	SvelteComponent,
	append,
	attr,
	destroy_each,
	detach,
	element,
	init,
	insert,
	listen,
	noop,
	run_all,
	safe_not_equal,
	set_data,
	set_style,
	space,
	text
} from "../../web_modules/svelte/internal.js";

import { subscribePrivate } from "../event/EventBus.js";
import { afterUpdate, onMount } from "../../web_modules/svelte.js";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[21] = list[i];
	return child_ctx;
}

// (59:10) {#each rowsPerPageEntries as entry}
function create_each_block(ctx) {
	let li;
	let a;
	let t0;
	let t1_value = /*entry*/ ctx[21] + "";
	let t1;
	let t2;
	let t3;
	let mounted;
	let dispose;

	function click_handler(...args) {
		return /*click_handler*/ ctx[12](/*entry*/ ctx[21], ...args);
	}

	return {
		c() {
			li = element("li");
			a = element("a");
			t0 = text("Show ");
			t1 = text(t1_value);
			t2 = text(" Entries");
			t3 = space();
			attr(a, "class", "dropdown-item");
			attr(a, "href", "javascript:void(0)");
		},
		m(target, anchor) {
			insert(target, li, anchor);
			append(li, a);
			append(a, t0);
			append(a, t1);
			append(a, t2);
			append(li, t3);

			if (!mounted) {
				dispose = listen(a, "click", click_handler);
				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
		},
		d(detaching) {
			if (detaching) detach(li);
			mounted = false;
			dispose();
		}
	};
}

// (82:4) {#if hasPrevious && page - 2 >= 1}
function create_if_block_3(ctx) {
	let li;
	let button;
	let t_value = /*page*/ ctx[0] - 2 + "";
	let t;
	let mounted;
	let dispose;

	return {
		c() {
			li = element("li");
			button = element("button");
			t = text(t_value);
			attr(button, "class", "page-link btn");
			attr(button, "href", "javascript:void(0)");
			attr(li, "class", "page-item");
		},
		m(target, anchor) {
			insert(target, li, anchor);
			append(li, button);
			append(button, t);

			if (!mounted) {
				dispose = listen(button, "click", /*click_handler_2*/ ctx[14]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty & /*page*/ 1 && t_value !== (t_value = /*page*/ ctx[0] - 2 + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(li);
			mounted = false;
			dispose();
		}
	};
}

// (90:4) {#if page > 1}
function create_if_block_2(ctx) {
	let li;
	let button;
	let t_value = /*page*/ ctx[0] - 1 + "";
	let t;
	let mounted;
	let dispose;

	return {
		c() {
			li = element("li");
			button = element("button");
			t = text(t_value);
			attr(button, "class", "page-link btn");
			attr(button, "href", "javascript:void(0)");
			attr(li, "class", "page-item");
		},
		m(target, anchor) {
			insert(target, li, anchor);
			append(li, button);
			append(button, t);

			if (!mounted) {
				dispose = listen(button, "click", /*click_handler_3*/ ctx[15]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty & /*page*/ 1 && t_value !== (t_value = /*page*/ ctx[0] - 1 + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(li);
			mounted = false;
			dispose();
		}
	};
}

// (101:4) {#if hasNext}
function create_if_block_1(ctx) {
	let li;
	let button;
	let t_value = /*page*/ ctx[0] + 1 + "";
	let t;
	let mounted;
	let dispose;

	return {
		c() {
			li = element("li");
			button = element("button");
			t = text(t_value);
			attr(button, "class", "page-link btn");
			attr(button, "href", "javascript:void(0)");
			attr(li, "class", "page-item");
		},
		m(target, anchor) {
			insert(target, li, anchor);
			append(li, button);
			append(button, t);

			if (!mounted) {
				dispose = listen(button, "click", /*click_handler_4*/ ctx[16]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty & /*page*/ 1 && t_value !== (t_value = /*page*/ ctx[0] + 1 + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(li);
			mounted = false;
			dispose();
		}
	};
}

// (109:4) {#if page + 2 <= pages}
function create_if_block(ctx) {
	let li;
	let button;
	let t_value = /*page*/ ctx[0] + 2 + "";
	let t;
	let mounted;
	let dispose;

	return {
		c() {
			li = element("li");
			button = element("button");
			t = text(t_value);
			attr(button, "class", "page-link btn");
			attr(button, "href", "javascript:void(0)");
			attr(li, "class", "page-item");
		},
		m(target, anchor) {
			insert(target, li, anchor);
			append(li, button);
			append(button, t);

			if (!mounted) {
				dispose = listen(button, "click", /*click_handler_5*/ ctx[17]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty & /*page*/ 1 && t_value !== (t_value = /*page*/ ctx[0] + 2 + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(li);
			mounted = false;
			dispose();
		}
	};
}

function create_fragment(ctx) {
	let nav;
	let ul1;
	let li0;
	let div;
	let button0;
	let t0;
	let t1;
	let ul0;
	let t2;
	let li1;
	let button1;
	let t3;
	let button1_disabled_value;
	let t4;
	let t5;
	let t6;
	let li2;
	let button2;
	let t7;
	let t8;
	let t9;
	let t10;
	let li3;
	let button3;
	let t11;
	let button3_disabled_value;
	let mounted;
	let dispose;
	let each_value = /*rowsPerPageEntries*/ ctx[5];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	let if_block0 = /*hasPrevious*/ ctx[3] && /*page*/ ctx[0] - 2 >= 1 && create_if_block_3(ctx);
	let if_block1 = /*page*/ ctx[0] > 1 && create_if_block_2(ctx);
	let if_block2 = /*hasNext*/ ctx[2] && create_if_block_1(ctx);
	let if_block3 = /*page*/ ctx[0] + 2 <= /*pages*/ ctx[1] && create_if_block(ctx);

	return {
		c() {
			nav = element("nav");
			ul1 = element("ul");
			li0 = element("li");
			div = element("div");
			button0 = element("button");
			t0 = text(/*showing*/ ctx[4]);
			t1 = space();
			ul0 = element("ul");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t2 = space();
			li1 = element("li");
			button1 = element("button");
			t3 = text("Previous");
			t4 = space();
			if (if_block0) if_block0.c();
			t5 = space();
			if (if_block1) if_block1.c();
			t6 = space();
			li2 = element("li");
			button2 = element("button");
			t7 = text(/*page*/ ctx[0]);
			t8 = space();
			if (if_block2) if_block2.c();
			t9 = space();
			if (if_block3) if_block3.c();
			t10 = space();
			li3 = element("li");
			button3 = element("button");
			t11 = text("Next");
			attr(button0, "class", "btn btn-secondary dropdown-toggle rows-page-button svelte-179vh0d");
			attr(button0, "type", "button");
			attr(button0, "id", "dropdownMenuButton");
			attr(button0, "data-toggle", "dropdown");
			attr(button0, "aria-expanded", "false");
			attr(ul0, "class", "dropdown-menu");
			attr(ul0, "aria-labelledby", "dropdownMenuButton");
			attr(div, "class", "dropdown");
			set_style(div, "margin-right", ".5em");
			attr(button1, "class", "page-link btn");
			button1.disabled = button1_disabled_value = !/*hasPrevious*/ ctx[3];
			attr(button1, "tabindex", "-1");
			attr(button1, "aria-disabled", "true");
			attr(li1, "class", "page-item");
			attr(button2, "class", "page-link btn");
			attr(button2, "href", "javascript:void(0)");
			attr(li2, "class", "page-item active");
			attr(li2, "aria-current", "page");
			attr(button3, "class", "page-link btn btn-primary");
			button3.disabled = button3_disabled_value = !/*hasNext*/ ctx[2];
			attr(li3, "class", "page-item");
			attr(ul1, "class", "pagination justify-content-end");
			attr(nav, "aria-label", "Table Pagination");
		},
		m(target, anchor) {
			insert(target, nav, anchor);
			append(nav, ul1);
			append(ul1, li0);
			append(li0, div);
			append(div, button0);
			append(button0, t0);
			append(div, t1);
			append(div, ul0);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(ul0, null);
			}

			append(ul1, t2);
			append(ul1, li1);
			append(li1, button1);
			append(button1, t3);
			append(ul1, t4);
			if (if_block0) if_block0.m(ul1, null);
			append(ul1, t5);
			if (if_block1) if_block1.m(ul1, null);
			append(ul1, t6);
			append(ul1, li2);
			append(li2, button2);
			append(button2, t7);
			append(ul1, t8);
			if (if_block2) if_block2.m(ul1, null);
			append(ul1, t9);
			if (if_block3) if_block3.m(ul1, null);
			append(ul1, t10);
			append(ul1, li3);
			append(li3, button3);
			append(button3, t11);

			if (!mounted) {
				dispose = [
					listen(button1, "click", /*click_handler_1*/ ctx[13]),
					listen(button3, "click", /*click_handler_6*/ ctx[18])
				];

				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (dirty & /*showing*/ 16) set_data(t0, /*showing*/ ctx[4]);

			if (dirty & /*setRowsPerPage, rowsPerPageEntries*/ 96) {
				each_value = /*rowsPerPageEntries*/ ctx[5];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(ul0, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}

			if (dirty & /*hasPrevious*/ 8 && button1_disabled_value !== (button1_disabled_value = !/*hasPrevious*/ ctx[3])) {
				button1.disabled = button1_disabled_value;
			}

			if (/*hasPrevious*/ ctx[3] && /*page*/ ctx[0] - 2 >= 1) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_3(ctx);
					if_block0.c();
					if_block0.m(ul1, t5);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*page*/ ctx[0] > 1) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_2(ctx);
					if_block1.c();
					if_block1.m(ul1, t6);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (dirty & /*page*/ 1) set_data(t7, /*page*/ ctx[0]);

			if (/*hasNext*/ ctx[2]) {
				if (if_block2) {
					if_block2.p(ctx, dirty);
				} else {
					if_block2 = create_if_block_1(ctx);
					if_block2.c();
					if_block2.m(ul1, t9);
				}
			} else if (if_block2) {
				if_block2.d(1);
				if_block2 = null;
			}

			if (/*page*/ ctx[0] + 2 <= /*pages*/ ctx[1]) {
				if (if_block3) {
					if_block3.p(ctx, dirty);
				} else {
					if_block3 = create_if_block(ctx);
					if_block3.c();
					if_block3.m(ul1, t10);
				}
			} else if (if_block3) {
				if_block3.d(1);
				if_block3 = null;
			}

			if (dirty & /*hasNext*/ 4 && button3_disabled_value !== (button3_disabled_value = !/*hasNext*/ ctx[2])) {
				button3.disabled = button3_disabled_value;
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(nav);
			destroy_each(each_blocks, detaching);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
			if (if_block3) if_block3.d();
			mounted = false;
			run_all(dispose);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let { id = "" } = $$props;
	let { rowsPerPage = 10 } = $$props;
	let { page = 1 } = $$props;
	let { count = 0 } = $$props;
	let { onRangeChange } = $$props;
	let pages = 1;
	let hasNext = true;
	let hasPrevious = false;
	let rowsPerPageEntries = [10, 25, 50, 100];
	let showing = "";

	afterUpdate(() => {
		onChange();
	});

	onMount(() => {
		subscribePrivate(id, "on_sort", () => {
			$$invalidate(0, page = 1);
		});
	});

	function onChange() {
		$$invalidate(1, pages = Math.ceil(count / rowsPerPage));

		if (page > pages) {
			$$invalidate(0, page = pages || 1);
		}

		$$invalidate(2, hasNext = page < pages);
		$$invalidate(3, hasPrevious = page > 1);
		let showingCount = Math.floor(page * rowsPerPage);
		showingCount = showingCount >= count ? Math.floor(count) : showingCount;
		$$invalidate(4, showing = `Showing ${showingCount} / ${Math.floor(count)} Entries`);
		onRangeChange(range());
		console.log("count", count, "pages", pages, "page", page, "hasNext", hasNext, "hasPrev", hasPrevious, "range", range());
	}

	function setRowsPerPage(newValue) {
		$$invalidate(8, rowsPerPage = newValue);
		$$invalidate(0, page = 1);
	}

	function setPage(newPage) {
		$$invalidate(0, page = newPage);
	}

	function range() {
		const max = rowsPerPage * page;
		const min = max - rowsPerPage;
		return { min, max };
	}

	const click_handler = entry => {
		setRowsPerPage(entry);
	};

	const click_handler_1 = () => setPage(page - 1);
	const click_handler_2 = () => setPage(page - 2);
	const click_handler_3 = () => setPage(page - 1);
	const click_handler_4 = () => setPage(page + 1);
	const click_handler_5 = () => setPage(page + 2);
	const click_handler_6 = () => setPage(page + 1);

	$$self.$$set = $$props => {
		if ("id" in $$props) $$invalidate(9, id = $$props.id);
		if ("rowsPerPage" in $$props) $$invalidate(8, rowsPerPage = $$props.rowsPerPage);
		if ("page" in $$props) $$invalidate(0, page = $$props.page);
		if ("count" in $$props) $$invalidate(10, count = $$props.count);
		if ("onRangeChange" in $$props) $$invalidate(11, onRangeChange = $$props.onRangeChange);
	};

	return [
		page,
		pages,
		hasNext,
		hasPrevious,
		showing,
		rowsPerPageEntries,
		setRowsPerPage,
		setPage,
		rowsPerPage,
		id,
		count,
		onRangeChange,
		click_handler,
		click_handler_1,
		click_handler_2,
		click_handler_3,
		click_handler_4,
		click_handler_5,
		click_handler_6
	];
}

class Pagination extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance, create_fragment, safe_not_equal, {
			id: 9,
			rowsPerPage: 8,
			page: 0,
			count: 10,
			onRangeChange: 11
		});
	}
}

export default Pagination;