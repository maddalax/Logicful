import './Select.css.proxy.js';
/* src/components/select/Select.svelte generated by Svelte v3.25.1 */
import {
	HtmlTag,
	SvelteComponent,
	append,
	assign,
	attr,
	binding_callbacks,
	check_outros,
	create_component,
	destroy_component,
	detach,
	element,
	empty,
	get_spread_object,
	get_spread_update,
	group_outros,
	init,
	insert,
	listen,
	mount_component,
	noop,
	prevent_default,
	run_all,
	safe_not_equal,
	set_attributes,
	set_input_value,
	space,
	svg_element,
	toggle_class,
	transition_in,
	transition_out
} from "../../../web_modules/svelte/internal.js";

import {
	beforeUpdate,
	createEventDispatcher,
	onDestroy,
	onMount,
	tick
} from "../../../web_modules/svelte.js";

import List from "./List.js";
import ItemComponent from "./Item.js";
import SelectionComponent from "./Selection.js";
import MultiSelectionComponent from "./MultiSelection.js";
import isOutOfViewport from "./utils/isOutOfViewport.js";
import debounce from "./utils/debounce.js";

function create_if_block_7(ctx) {
	let switch_instance;
	let switch_instance_anchor;
	let current;
	const switch_instance_spread_levels = [/*iconProps*/ ctx[17]];
	var switch_value = /*Icon*/ ctx[16];

	function switch_props(ctx) {
		let switch_instance_props = {};

		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
		}

		return { props: switch_instance_props };
	}

	if (switch_value) {
		switch_instance = new switch_value(switch_props(ctx));
	}

	return {
		c() {
			if (switch_instance) create_component(switch_instance.$$.fragment);
			switch_instance_anchor = empty();
		},
		m(target, anchor) {
			if (switch_instance) {
				mount_component(switch_instance, target, anchor);
			}

			insert(target, switch_instance_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const switch_instance_changes = (dirty[0] & /*iconProps*/ 131072)
			? get_spread_update(switch_instance_spread_levels, [get_spread_object(/*iconProps*/ ctx[17])])
			: {};

			if (switch_value !== (switch_value = /*Icon*/ ctx[16])) {
				if (switch_instance) {
					group_outros();
					const old_component = switch_instance;

					transition_out(old_component.$$.fragment, 1, 0, () => {
						destroy_component(old_component, 1);
					});

					check_outros();
				}

				if (switch_value) {
					switch_instance = new switch_value(switch_props(ctx));
					create_component(switch_instance.$$.fragment);
					transition_in(switch_instance.$$.fragment, 1);
					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
				} else {
					switch_instance = null;
				}
			} else if (switch_value) {
				switch_instance.$set(switch_instance_changes);
			}
		},
		i(local) {
			if (current) return;
			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
			current = true;
		},
		o(local) {
			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(switch_instance_anchor);
			if (switch_instance) destroy_component(switch_instance, detaching);
		}
	};
}

// (720:2) {#if isMulti && selectedValue && selectedValue.length > 0}
function create_if_block_6(ctx) {
	let switch_instance;
	let switch_instance_anchor;
	let current;
	var switch_value = /*MultiSelection*/ ctx[7];

	function switch_props(ctx) {
		return {
			props: {
				selectedValue: /*selectedValue*/ ctx[3],
				getSelectionLabel: /*getSelectionLabel*/ ctx[12],
				activeSelectedValue: /*activeSelectedValue*/ ctx[23],
				isDisabled: /*isDisabled*/ ctx[9]
			}
		};
	}

	if (switch_value) {
		switch_instance = new switch_value(switch_props(ctx));
		switch_instance.$on("multiItemClear", /*handleMultiItemClear*/ ctx[27]);
		switch_instance.$on("focus", /*handleFocus*/ ctx[30]);
	}

	return {
		c() {
			if (switch_instance) create_component(switch_instance.$$.fragment);
			switch_instance_anchor = empty();
		},
		m(target, anchor) {
			if (switch_instance) {
				mount_component(switch_instance, target, anchor);
			}

			insert(target, switch_instance_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const switch_instance_changes = {};
			if (dirty[0] & /*selectedValue*/ 8) switch_instance_changes.selectedValue = /*selectedValue*/ ctx[3];
			if (dirty[0] & /*getSelectionLabel*/ 4096) switch_instance_changes.getSelectionLabel = /*getSelectionLabel*/ ctx[12];
			if (dirty[0] & /*activeSelectedValue*/ 8388608) switch_instance_changes.activeSelectedValue = /*activeSelectedValue*/ ctx[23];
			if (dirty[0] & /*isDisabled*/ 512) switch_instance_changes.isDisabled = /*isDisabled*/ ctx[9];

			if (switch_value !== (switch_value = /*MultiSelection*/ ctx[7])) {
				if (switch_instance) {
					group_outros();
					const old_component = switch_instance;

					transition_out(old_component.$$.fragment, 1, 0, () => {
						destroy_component(old_component, 1);
					});

					check_outros();
				}

				if (switch_value) {
					switch_instance = new switch_value(switch_props(ctx));
					switch_instance.$on("multiItemClear", /*handleMultiItemClear*/ ctx[27]);
					switch_instance.$on("focus", /*handleFocus*/ ctx[30]);
					create_component(switch_instance.$$.fragment);
					transition_in(switch_instance.$$.fragment, 1);
					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
				} else {
					switch_instance = null;
				}
			} else if (switch_value) {
				switch_instance.$set(switch_instance_changes);
			}
		},
		i(local) {
			if (current) return;
			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
			current = true;
		},
		o(local) {
			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(switch_instance_anchor);
			if (switch_instance) destroy_component(switch_instance, detaching);
		}
	};
}

// (740:2) {:else}
function create_else_block_1(ctx) {
	let input_1;
	let mounted;
	let dispose;

	let input_1_levels = [
		/*_inputAttributes*/ ctx[24],
		{ placeholder: /*placeholderText*/ ctx[26] },
		{ style: /*inputStyles*/ ctx[14] }
	];

	let input_1_data = {};

	for (let i = 0; i < input_1_levels.length; i += 1) {
		input_1_data = assign(input_1_data, input_1_levels[i]);
	}

	return {
		c() {
			input_1 = element("input");
			set_attributes(input_1, input_1_data);
			toggle_class(input_1, "svelte-1kmtf2c", true);
		},
		m(target, anchor) {
			insert(target, input_1, anchor);
			/*input_1_binding_1*/ ctx[60](input_1);
			set_input_value(input_1, /*filterText*/ ctx[4]);

			if (!mounted) {
				dispose = [
					listen(input_1, "focus", /*handleFocus*/ ctx[30]),
					listen(input_1, "input", /*input_1_input_handler_1*/ ctx[61])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			set_attributes(input_1, input_1_data = get_spread_update(input_1_levels, [
				dirty[0] & /*_inputAttributes*/ 16777216 && /*_inputAttributes*/ ctx[24],
				dirty[0] & /*placeholderText*/ 67108864 && { placeholder: /*placeholderText*/ ctx[26] },
				dirty[0] & /*inputStyles*/ 16384 && { style: /*inputStyles*/ ctx[14] }
			]));

			if (dirty[0] & /*filterText*/ 16 && input_1.value !== /*filterText*/ ctx[4]) {
				set_input_value(input_1, /*filterText*/ ctx[4]);
			}

			toggle_class(input_1, "svelte-1kmtf2c", true);
		},
		d(detaching) {
			if (detaching) detach(input_1);
			/*input_1_binding_1*/ ctx[60](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (731:2) {#if isDisabled}
function create_if_block_5(ctx) {
	let input_1;
	let mounted;
	let dispose;

	let input_1_levels = [
		/*_inputAttributes*/ ctx[24],
		{ placeholder: /*placeholderText*/ ctx[26] },
		{ style: /*inputStyles*/ ctx[14] },
		{ disabled: true }
	];

	let input_1_data = {};

	for (let i = 0; i < input_1_levels.length; i += 1) {
		input_1_data = assign(input_1_data, input_1_levels[i]);
	}

	return {
		c() {
			input_1 = element("input");
			set_attributes(input_1, input_1_data);
			toggle_class(input_1, "svelte-1kmtf2c", true);
		},
		m(target, anchor) {
			insert(target, input_1, anchor);
			/*input_1_binding*/ ctx[58](input_1);
			set_input_value(input_1, /*filterText*/ ctx[4]);

			if (!mounted) {
				dispose = [
					listen(input_1, "focus", /*handleFocus*/ ctx[30]),
					listen(input_1, "input", /*input_1_input_handler*/ ctx[59])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			set_attributes(input_1, input_1_data = get_spread_update(input_1_levels, [
				dirty[0] & /*_inputAttributes*/ 16777216 && /*_inputAttributes*/ ctx[24],
				dirty[0] & /*placeholderText*/ 67108864 && { placeholder: /*placeholderText*/ ctx[26] },
				dirty[0] & /*inputStyles*/ 16384 && { style: /*inputStyles*/ ctx[14] },
				{ disabled: true }
			]));

			if (dirty[0] & /*filterText*/ 16 && input_1.value !== /*filterText*/ ctx[4]) {
				set_input_value(input_1, /*filterText*/ ctx[4]);
			}

			toggle_class(input_1, "svelte-1kmtf2c", true);
		},
		d(detaching) {
			if (detaching) detach(input_1);
			/*input_1_binding*/ ctx[58](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (750:2) {#if !isMulti && showSelectedItem}
function create_if_block_4(ctx) {
	let div;
	let switch_instance;
	let current;
	let mounted;
	let dispose;
	var switch_value = /*Selection*/ ctx[6];

	function switch_props(ctx) {
		return {
			props: {
				item: /*selectedValue*/ ctx[3],
				getSelectionLabel: /*getSelectionLabel*/ ctx[12]
			}
		};
	}

	if (switch_value) {
		switch_instance = new switch_value(switch_props(ctx));
	}

	return {
		c() {
			div = element("div");
			if (switch_instance) create_component(switch_instance.$$.fragment);
			attr(div, "class", "selectedItem svelte-1kmtf2c");
		},
		m(target, anchor) {
			insert(target, div, anchor);

			if (switch_instance) {
				mount_component(switch_instance, div, null);
			}

			current = true;

			if (!mounted) {
				dispose = listen(div, "focus", /*handleFocus*/ ctx[30]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			const switch_instance_changes = {};
			if (dirty[0] & /*selectedValue*/ 8) switch_instance_changes.item = /*selectedValue*/ ctx[3];
			if (dirty[0] & /*getSelectionLabel*/ 4096) switch_instance_changes.getSelectionLabel = /*getSelectionLabel*/ ctx[12];

			if (switch_value !== (switch_value = /*Selection*/ ctx[6])) {
				if (switch_instance) {
					group_outros();
					const old_component = switch_instance;

					transition_out(old_component.$$.fragment, 1, 0, () => {
						destroy_component(old_component, 1);
					});

					check_outros();
				}

				if (switch_value) {
					switch_instance = new switch_value(switch_props(ctx));
					create_component(switch_instance.$$.fragment);
					transition_in(switch_instance.$$.fragment, 1);
					mount_component(switch_instance, div, null);
				} else {
					switch_instance = null;
				}
			} else if (switch_value) {
				switch_instance.$set(switch_instance_changes);
			}
		},
		i(local) {
			if (current) return;
			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
			current = true;
		},
		o(local) {
			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (switch_instance) destroy_component(switch_instance);
			mounted = false;
			dispose();
		}
	};
}

// (759:2) {#if showSelectedItem && isClearable && !isDisabled && !isWaiting}
function create_if_block_3(ctx) {
	let div;
	let mounted;
	let dispose;

	return {
		c() {
			div = element("div");

			div.innerHTML = `<svg width="100%" height="100%" viewBox="-2 -2 50 50" focusable="false" role="presentation" class="svelte-1kmtf2c"><path fill="currentColor" d="M34.923,37.251L24,26.328L13.077,37.251L9.436,33.61l10.923-10.923L9.436,11.765l3.641-3.641L24,19.047L34.923,8.124
          l3.641,3.641L27.641,22.688L38.564,33.61L34.923,37.251z"></path></svg>`;

			attr(div, "class", "clearSelect svelte-1kmtf2c");
		},
		m(target, anchor) {
			insert(target, div, anchor);

			if (!mounted) {
				dispose = listen(div, "click", prevent_default(/*handleClear*/ ctx[22]));
				mounted = true;
			}
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(div);
			mounted = false;
			dispose();
		}
	};
}

// (775:2) {#if showIndicator || (showChevron && !selectedValue || (!isSearchable && !isDisabled && !isWaiting && ((showSelectedItem && !isClearable) || !showSelectedItem)))}
function create_if_block_1(ctx) {
	let div;

	function select_block_type_1(ctx, dirty) {
		if (/*indicatorSvg*/ ctx[21]) return create_if_block_2;
		return create_else_block;
	}

	let current_block_type = select_block_type_1(ctx, [-1]);
	let if_block = current_block_type(ctx);

	return {
		c() {
			div = element("div");
			if_block.c();
			attr(div, "class", "indicator svelte-1kmtf2c");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			if_block.m(div, null);
		},
		p(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type_1(ctx, dirty)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(div, null);
				}
			}
		},
		d(detaching) {
			if (detaching) detach(div);
			if_block.d();
		}
	};
}

// (779:6) {:else}
function create_else_block(ctx) {
	let svg;
	let path;

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M4.516 7.548c0.436-0.446 1.043-0.481 1.576 0l3.908 3.747\n            3.908-3.747c0.533-0.481 1.141-0.446 1.574 0 0.436 0.445 0.408 1.197 0\n            1.615-0.406 0.418-4.695 4.502-4.695 4.502-0.217 0.223-0.502\n            0.335-0.787 0.335s-0.57-0.112-0.789-0.335c0\n            0-4.287-4.084-4.695-4.502s-0.436-1.17 0-1.615z");
			attr(svg, "width", "100%");
			attr(svg, "height", "100%");
			attr(svg, "viewBox", "0 0 20 20");
			attr(svg, "focusable", "false");
			attr(svg, "class", "svelte-1kmtf2c");
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

// (777:6) {#if indicatorSvg}
function create_if_block_2(ctx) {
	let html_tag;
	let html_anchor;

	return {
		c() {
			html_anchor = empty();
			html_tag = new HtmlTag(html_anchor);
		},
		m(target, anchor) {
			html_tag.m(/*indicatorSvg*/ ctx[21], target, anchor);
			insert(target, html_anchor, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*indicatorSvg*/ 2097152) html_tag.p(/*indicatorSvg*/ ctx[21]);
		},
		d(detaching) {
			if (detaching) detach(html_anchor);
			if (detaching) html_tag.d();
		}
	};
}

// (796:2) {#if isWaiting}
function create_if_block(ctx) {
	let div;

	return {
		c() {
			div = element("div");
			div.innerHTML = `<svg class="spinner_icon svelte-1kmtf2c" viewBox="25 25 50 50"><circle class="spinner_path svelte-1kmtf2c" cx="50" cy="50" r="20" fill="none" stroke="currentColor" stroke-width="5" stroke-miterlimit="10"></circle></svg>`;
			attr(div, "class", "spinner svelte-1kmtf2c");
		},
		m(target, anchor) {
			insert(target, div, anchor);
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

function create_fragment(ctx) {
	let div;
	let t0;
	let t1;
	let t2;
	let t3;
	let t4;
	let t5;
	let div_class_value;
	let current;
	let mounted;
	let dispose;
	let if_block0 = /*Icon*/ ctx[16] && create_if_block_7(ctx);
	let if_block1 = /*isMulti*/ ctx[8] && /*selectedValue*/ ctx[3] && /*selectedValue*/ ctx[3].length > 0 && create_if_block_6(ctx);

	function select_block_type(ctx, dirty) {
		if (/*isDisabled*/ ctx[9]) return create_if_block_5;
		return create_else_block_1;
	}

	let current_block_type = select_block_type(ctx, [-1]);
	let if_block2 = current_block_type(ctx);
	let if_block3 = !/*isMulti*/ ctx[8] && /*showSelectedItem*/ ctx[25] && create_if_block_4(ctx);
	let if_block4 = /*showSelectedItem*/ ctx[25] && /*isClearable*/ ctx[15] && !/*isDisabled*/ ctx[9] && !/*isWaiting*/ ctx[5] && create_if_block_3(ctx);
	let if_block5 = (/*showIndicator*/ ctx[19] || (/*showChevron*/ ctx[18] && !/*selectedValue*/ ctx[3] || !/*isSearchable*/ ctx[13] && !/*isDisabled*/ ctx[9] && !/*isWaiting*/ ctx[5] && (/*showSelectedItem*/ ctx[25] && !/*isClearable*/ ctx[15] || !/*showSelectedItem*/ ctx[25]))) && create_if_block_1(ctx);
	let if_block6 = /*isWaiting*/ ctx[5] && create_if_block(ctx);

	return {
		c() {
			div = element("div");
			if (if_block0) if_block0.c();
			t0 = space();
			if (if_block1) if_block1.c();
			t1 = space();
			if_block2.c();
			t2 = space();
			if (if_block3) if_block3.c();
			t3 = space();
			if (if_block4) if_block4.c();
			t4 = space();
			if (if_block5) if_block5.c();
			t5 = space();
			if (if_block6) if_block6.c();
			attr(div, "class", div_class_value = "selectContainer " + /*containerClasses*/ ctx[20] + " svelte-1kmtf2c");
			attr(div, "style", /*containerStyles*/ ctx[11]);
			toggle_class(div, "hasError", /*hasError*/ ctx[10]);
			toggle_class(div, "multiSelect", /*isMulti*/ ctx[8]);
			toggle_class(div, "disabled", /*isDisabled*/ ctx[9]);
			toggle_class(div, "focused", /*isFocused*/ ctx[2]);
		},
		m(target, anchor) {
			insert(target, div, anchor);
			if (if_block0) if_block0.m(div, null);
			append(div, t0);
			if (if_block1) if_block1.m(div, null);
			append(div, t1);
			if_block2.m(div, null);
			append(div, t2);
			if (if_block3) if_block3.m(div, null);
			append(div, t3);
			if (if_block4) if_block4.m(div, null);
			append(div, t4);
			if (if_block5) if_block5.m(div, null);
			append(div, t5);
			if (if_block6) if_block6.m(div, null);
			/*div_binding*/ ctx[62](div);
			current = true;

			if (!mounted) {
				dispose = [
					listen(window, "click", /*handleWindowClick*/ ctx[31]),
					listen(window, "keydown", /*handleKeyDown*/ ctx[29]),
					listen(window, "resize", /*getPosition*/ ctx[28]),
					listen(div, "click", /*handleClick*/ ctx[32])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (/*Icon*/ ctx[16]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[0] & /*Icon*/ 65536) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_7(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(div, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (/*isMulti*/ ctx[8] && /*selectedValue*/ ctx[3] && /*selectedValue*/ ctx[3].length > 0) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*isMulti, selectedValue*/ 264) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_6(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, t1);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (current_block_type === (current_block_type = select_block_type(ctx, dirty)) && if_block2) {
				if_block2.p(ctx, dirty);
			} else {
				if_block2.d(1);
				if_block2 = current_block_type(ctx);

				if (if_block2) {
					if_block2.c();
					if_block2.m(div, t2);
				}
			}

			if (!/*isMulti*/ ctx[8] && /*showSelectedItem*/ ctx[25]) {
				if (if_block3) {
					if_block3.p(ctx, dirty);

					if (dirty[0] & /*isMulti, showSelectedItem*/ 33554688) {
						transition_in(if_block3, 1);
					}
				} else {
					if_block3 = create_if_block_4(ctx);
					if_block3.c();
					transition_in(if_block3, 1);
					if_block3.m(div, t3);
				}
			} else if (if_block3) {
				group_outros();

				transition_out(if_block3, 1, 1, () => {
					if_block3 = null;
				});

				check_outros();
			}

			if (/*showSelectedItem*/ ctx[25] && /*isClearable*/ ctx[15] && !/*isDisabled*/ ctx[9] && !/*isWaiting*/ ctx[5]) {
				if (if_block4) {
					if_block4.p(ctx, dirty);
				} else {
					if_block4 = create_if_block_3(ctx);
					if_block4.c();
					if_block4.m(div, t4);
				}
			} else if (if_block4) {
				if_block4.d(1);
				if_block4 = null;
			}

			if (/*showIndicator*/ ctx[19] || (/*showChevron*/ ctx[18] && !/*selectedValue*/ ctx[3] || !/*isSearchable*/ ctx[13] && !/*isDisabled*/ ctx[9] && !/*isWaiting*/ ctx[5] && (/*showSelectedItem*/ ctx[25] && !/*isClearable*/ ctx[15] || !/*showSelectedItem*/ ctx[25]))) {
				if (if_block5) {
					if_block5.p(ctx, dirty);
				} else {
					if_block5 = create_if_block_1(ctx);
					if_block5.c();
					if_block5.m(div, t5);
				}
			} else if (if_block5) {
				if_block5.d(1);
				if_block5 = null;
			}

			if (/*isWaiting*/ ctx[5]) {
				if (if_block6) {
					
				} else {
					if_block6 = create_if_block(ctx);
					if_block6.c();
					if_block6.m(div, null);
				}
			} else if (if_block6) {
				if_block6.d(1);
				if_block6 = null;
			}

			if (!current || dirty[0] & /*containerClasses*/ 1048576 && div_class_value !== (div_class_value = "selectContainer " + /*containerClasses*/ ctx[20] + " svelte-1kmtf2c")) {
				attr(div, "class", div_class_value);
			}

			if (!current || dirty[0] & /*containerStyles*/ 2048) {
				attr(div, "style", /*containerStyles*/ ctx[11]);
			}

			if (dirty[0] & /*containerClasses, hasError*/ 1049600) {
				toggle_class(div, "hasError", /*hasError*/ ctx[10]);
			}

			if (dirty[0] & /*containerClasses, isMulti*/ 1048832) {
				toggle_class(div, "multiSelect", /*isMulti*/ ctx[8]);
			}

			if (dirty[0] & /*containerClasses, isDisabled*/ 1049088) {
				toggle_class(div, "disabled", /*isDisabled*/ ctx[9]);
			}

			if (dirty[0] & /*containerClasses, isFocused*/ 1048580) {
				toggle_class(div, "focused", /*isFocused*/ ctx[2]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);
			transition_in(if_block3);
			current = true;
		},
		o(local) {
			transition_out(if_block0);
			transition_out(if_block1);
			transition_out(if_block3);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if_block2.d();
			if (if_block3) if_block3.d();
			if (if_block4) if_block4.d();
			if (if_block5) if_block5.d();
			if (if_block6) if_block6.d();
			/*div_binding*/ ctx[62](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	const dispatch = createEventDispatcher();
	let { container = undefined } = $$props;
	let { input = undefined } = $$props;
	let { Item = ItemComponent } = $$props;
	let { Selection = SelectionComponent } = $$props;
	let { MultiSelection = MultiSelectionComponent } = $$props;
	let { isMulti = false } = $$props;
	let { isDisabled = false } = $$props;
	let { isCreatable = false } = $$props;
	let { isFocused = false } = $$props;
	let { selectedValue = undefined } = $$props;
	let { filterText = "" } = $$props;
	let { placeholder = "Select..." } = $$props;
	let { items = [] } = $$props;
	let { itemFilter = (label, filterText, option) => label.toLowerCase().includes(filterText.toLowerCase()) } = $$props;
	let { groupBy = undefined } = $$props;
	let { groupFilter = groups => groups } = $$props;
	let { isGroupHeaderSelectable = false } = $$props;

	let { getGroupHeaderLabel = option => {
		return option.label;
	} } = $$props;

	let { getOptionLabel = (option, filterText) => {
		return option.isCreator
		? `Create \"${filterText}\"`
		: option.label;
	} } = $$props;

	let { optionIdentifier = "value" } = $$props;
	let { loadOptions = undefined } = $$props;
	let { hasError = false } = $$props;
	let { containerStyles = "" } = $$props;

	let { getSelectionLabel = option => {
		if (option) return option.label;
	} } = $$props;

	let { createGroupHeaderItem = groupValue => {
		return { value: groupValue, label: groupValue };
	} } = $$props;

	let { createItem = filterText => {
		return { value: filterText, label: filterText };
	} } = $$props;

	let { isSearchable = true } = $$props;
	let { inputStyles = "" } = $$props;
	let { isClearable = true } = $$props;
	let { isWaiting = false } = $$props;
	let { listPlacement = "auto" } = $$props;
	let { listOpen = false } = $$props;
	let { list = undefined } = $$props;
	let { isVirtualList = false } = $$props;
	let { loadOptionsInterval = 300 } = $$props;
	let { noOptionsMessage = "No options" } = $$props;
	let { hideEmptyState = false } = $$props;
	let { filteredItems = [] } = $$props;
	let { inputAttributes = {} } = $$props;
	let { listAutoWidth = true } = $$props;
	let { itemHeight = 40 } = $$props;
	let { Icon = undefined } = $$props;
	let { iconProps = {} } = $$props;
	let { showChevron = false } = $$props;
	let { showIndicator = false } = $$props;
	let { containerClasses = "" } = $$props;
	let { indicatorSvg = undefined } = $$props;
	let target;
	let activeSelectedValue;
	let _items = [];
	let originalItemsClone;
	let prev_selectedValue;
	let prev_listOpen;
	let prev_filterText;
	let prev_isFocused;
	let prev_filteredItems;

	async function resetFilter() {
		await tick();
		$$invalidate(4, filterText = "");
	}

	let getItemsHasInvoked = false;

	const getItems = debounce(
		async () => {
			getItemsHasInvoked = true;
			$$invalidate(5, isWaiting = true);

			let res = await loadOptions(filterText).catch(err => {
				console.warn("svelte-select loadOptions error :>> ", err);
				dispatch("error", { type: "loadOptions", details: err });
			});

			if (res) {
				$$invalidate(33, items = [...res]);
			} else {
				$$invalidate(33, items = []);
			}

			$$invalidate(5, isWaiting = false);
			$$invalidate(2, isFocused = true);
			$$invalidate(34, listOpen = true);
		},
		loadOptionsInterval
	);

	let _inputAttributes = {};

	beforeUpdate(() => {
		if (isMulti && selectedValue && selectedValue.length > 1) {
			checkSelectedValueForDuplicates();
		}

		if (!isMulti && selectedValue && prev_selectedValue !== selectedValue) {
			if (!prev_selectedValue || JSON.stringify(selectedValue[optionIdentifier]) !== JSON.stringify(prev_selectedValue[optionIdentifier])) {
				dispatch("select", selectedValue);
			}
		}

		if (isMulti && JSON.stringify(selectedValue) !== JSON.stringify(prev_selectedValue)) {
			if (checkSelectedValueForDuplicates()) {
				dispatch("select", selectedValue);
			}
		}

		if (container && listOpen !== prev_listOpen) {
			if (listOpen) {
				loadList();
			} else {
				removeList();
			}
		}

		if (filterText !== prev_filterText) {
			if (filterText.length > 0) {
				$$invalidate(2, isFocused = true);
				$$invalidate(34, listOpen = true);

				if (loadOptions) {
					getItems();
				} else {
					loadList();
					$$invalidate(34, listOpen = true);

					if (isMulti) {
						$$invalidate(23, activeSelectedValue = undefined);
					}
				}
			} else {
				setList([]);
			}

			if (list) {
				list.$set({ filterText });
			}
		}

		if (isFocused !== prev_isFocused) {
			if (isFocused || listOpen) {
				handleFocus();
			} else {
				resetFilter();
				if (input) input.blur();
			}
		}

		if (prev_filteredItems !== filteredItems) {
			let _filteredItems = [...filteredItems];

			if (isCreatable && filterText) {
				const itemToCreate = createItem(filterText);
				itemToCreate.isCreator = true;

				const existingItemWithFilterValue = _filteredItems.find(item => {
					return item[optionIdentifier] === itemToCreate[optionIdentifier];
				});

				let existingSelectionWithFilterValue;

				if (selectedValue) {
					if (isMulti) {
						existingSelectionWithFilterValue = selectedValue.find(selection => {
							return selection[optionIdentifier] === itemToCreate[optionIdentifier];
						});
					} else if (selectedValue[optionIdentifier] === itemToCreate[optionIdentifier]) {
						existingSelectionWithFilterValue = selectedValue;
					}
				}

				if (!existingItemWithFilterValue && !existingSelectionWithFilterValue) {
					_filteredItems = [..._filteredItems, itemToCreate];
				}
			}

			setList(_filteredItems);
		}

		prev_selectedValue = selectedValue;
		prev_listOpen = listOpen;
		prev_filterText = filterText;
		prev_isFocused = isFocused;
		prev_filteredItems = filteredItems;
	});

	function checkSelectedValueForDuplicates() {
		let noDuplicates = true;

		if (selectedValue) {
			const ids = [];
			const uniqueValues = [];

			selectedValue.forEach(val => {
				if (!ids.includes(val[optionIdentifier])) {
					ids.push(val[optionIdentifier]);
					uniqueValues.push(val);
				} else {
					noDuplicates = false;
				}
			});

			if (!noDuplicates) $$invalidate(3, selectedValue = uniqueValues);
		}

		return noDuplicates;
	}

	async function setList(items) {
		await tick();
		if (list) return list.$set({ items });
		if (loadOptions && getItemsHasInvoked && items.length > 0) loadList();
	}

	function handleMultiItemClear(event) {
		const { detail } = event;
		const itemToRemove = selectedValue[detail ? detail.i : selectedValue.length - 1];

		if (selectedValue.length === 1) {
			$$invalidate(3, selectedValue = undefined);
		} else {
			$$invalidate(3, selectedValue = selectedValue.filter(item => {
				return item !== itemToRemove;
			}));
		}

		dispatch("clear", itemToRemove);
		getPosition();
	}

	async function getPosition() {
		await tick();
		if (!target || !container) return;
		const { top, height, width } = container.getBoundingClientRect();
		target.style["min-width"] = `${width}px`;
		target.style.width = `${listAutoWidth ? "auto" : "100%"}`;
		target.style.left = "0";

		if (listPlacement === "top") {
			target.style.bottom = `${height + 5}px`;
		} else {
			target.style.top = `${height + 5}px`;
		}

		target = target;

		if (listPlacement === "auto" && isOutOfViewport(target).bottom) {
			target.style.top = ``;
			target.style.bottom = `${height + 5}px`;
		}

		target.style.visibility = "";
	}

	function handleKeyDown(e) {
		if (!isFocused) return;

		switch (e.key) {
			case "ArrowDown":
				e.preventDefault();
				$$invalidate(34, listOpen = true);
				$$invalidate(23, activeSelectedValue = undefined);
				break;
			case "ArrowUp":
				e.preventDefault();
				$$invalidate(34, listOpen = true);
				$$invalidate(23, activeSelectedValue = undefined);
				break;
			case "Tab":
				if (!listOpen) $$invalidate(2, isFocused = false);
				break;
			case "Backspace":
				if (!isMulti || filterText.length > 0) return;
				if (isMulti && selectedValue && selectedValue.length > 0) {
					handleMultiItemClear(activeSelectedValue !== undefined
					? activeSelectedValue
					: selectedValue.length - 1);

					if (activeSelectedValue === 0 || activeSelectedValue === undefined) break;

					$$invalidate(23, activeSelectedValue = selectedValue.length > activeSelectedValue
					? activeSelectedValue - 1
					: undefined);
				}
				break;
			case "ArrowLeft":
				if (list) list.$set({ hoverItemIndex: -1 });
				if (!isMulti || filterText.length > 0) return;
				if (activeSelectedValue === undefined) {
					$$invalidate(23, activeSelectedValue = selectedValue.length - 1);
				} else if (selectedValue.length > activeSelectedValue && activeSelectedValue !== 0) {
					$$invalidate(23, activeSelectedValue -= 1);
				}
				break;
			case "ArrowRight":
				if (list) list.$set({ hoverItemIndex: -1 });
				if (!isMulti || filterText.length > 0 || activeSelectedValue === undefined) return;
				if (activeSelectedValue === selectedValue.length - 1) {
					$$invalidate(23, activeSelectedValue = undefined);
				} else if (activeSelectedValue < selectedValue.length - 1) {
					$$invalidate(23, activeSelectedValue += 1);
				}
				break;
		}
	}

	function handleFocus() {
		$$invalidate(2, isFocused = true);
		if (input) input.focus();
	}

	function removeList() {
		resetFilter();
		$$invalidate(23, activeSelectedValue = undefined);
		if (!list) return;
		list.$destroy();
		$$invalidate(35, list = undefined);
		if (!target) return;
		if (target.parentNode) target.parentNode.removeChild(target);
		target = undefined;
		$$invalidate(35, list);
		target = target;
	}

	function handleWindowClick(event) {
		if (!container) return;

		const eventTarget = event.path && event.path.length > 0
		? event.path[0]
		: event.target;

		if (container.contains(eventTarget)) return;
		$$invalidate(2, isFocused = false);
		$$invalidate(34, listOpen = false);
		$$invalidate(23, activeSelectedValue = undefined);
		if (input) input.blur();
	}

	function handleClick() {
		if (isDisabled) return;
		$$invalidate(2, isFocused = true);
		$$invalidate(34, listOpen = !listOpen);
	}

	function handleClear() {
		$$invalidate(3, selectedValue = undefined);
		$$invalidate(34, listOpen = false);
		dispatch("clear", selectedValue);
		handleFocus();
	}

	async function loadList() {
		await tick();
		if (target && list) return;

		const data = {
			Item,
			filterText,
			optionIdentifier,
			noOptionsMessage,
			hideEmptyState,
			isVirtualList,
			selectedValue,
			isMulti,
			getGroupHeaderLabel,
			items: filteredItems,
			itemHeight
		};

		if (getOptionLabel) {
			data.getOptionLabel = getOptionLabel;
		}

		target = document.createElement("div");

		Object.assign(target.style, {
			position: "absolute",
			"z-index": 2,
			visibility: "hidden"
		});

		$$invalidate(35, list);
		target = target;
		if (container) container.appendChild(target);
		$$invalidate(35, list = new List({ target, props: data }));

		list.$on("itemSelected", event => {
			const { detail } = event;

			if (detail) {
				const item = Object.assign({}, detail);

				if (!item.isGroupHeader || item.isSelectable) {
					if (isMulti) {
						$$invalidate(3, selectedValue = selectedValue ? selectedValue.concat([item]) : [item]);
					} else {
						$$invalidate(3, selectedValue = item);
					}

					resetFilter();
					(($$invalidate(3, selectedValue), $$invalidate(46, optionIdentifier)), $$invalidate(8, isMulti));

					setTimeout(() => {
						$$invalidate(34, listOpen = false);
						$$invalidate(23, activeSelectedValue = undefined);
					});
				}
			}
		});

		list.$on("itemCreated", event => {
			const { detail } = event;

			if (isMulti) {
				$$invalidate(3, selectedValue = selectedValue || []);
				$$invalidate(3, selectedValue = [...selectedValue, createItem(detail)]);
			} else {
				$$invalidate(3, selectedValue = createItem(detail));
			}

			$$invalidate(4, filterText = "");
			$$invalidate(34, listOpen = false);
			$$invalidate(23, activeSelectedValue = undefined);
			resetFilter();
		});

		list.$on("closeList", () => {
			$$invalidate(34, listOpen = false);
		});

		($$invalidate(35, list), target = target);
		getPosition();
	}

	onMount(() => {
		if (isFocused) input.focus();
		if (listOpen) loadList();

		if (items && items.length > 0) {
			$$invalidate(64, originalItemsClone = JSON.stringify(items));
		}
	});

	onDestroy(() => {
		removeList();
	});

	function input_1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			input = $$value;
			$$invalidate(1, input);
		});
	}

	function input_1_input_handler() {
		filterText = this.value;
		$$invalidate(4, filterText);
	}

	function input_1_binding_1($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			input = $$value;
			$$invalidate(1, input);
		});
	}

	function input_1_input_handler_1() {
		filterText = this.value;
		$$invalidate(4, filterText);
	}

	function div_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			container = $$value;
			$$invalidate(0, container);
		});
	}

	$$self.$$set = $$props => {
		if ("container" in $$props) $$invalidate(0, container = $$props.container);
		if ("input" in $$props) $$invalidate(1, input = $$props.input);
		if ("Item" in $$props) $$invalidate(37, Item = $$props.Item);
		if ("Selection" in $$props) $$invalidate(6, Selection = $$props.Selection);
		if ("MultiSelection" in $$props) $$invalidate(7, MultiSelection = $$props.MultiSelection);
		if ("isMulti" in $$props) $$invalidate(8, isMulti = $$props.isMulti);
		if ("isDisabled" in $$props) $$invalidate(9, isDisabled = $$props.isDisabled);
		if ("isCreatable" in $$props) $$invalidate(38, isCreatable = $$props.isCreatable);
		if ("isFocused" in $$props) $$invalidate(2, isFocused = $$props.isFocused);
		if ("selectedValue" in $$props) $$invalidate(3, selectedValue = $$props.selectedValue);
		if ("filterText" in $$props) $$invalidate(4, filterText = $$props.filterText);
		if ("placeholder" in $$props) $$invalidate(39, placeholder = $$props.placeholder);
		if ("items" in $$props) $$invalidate(33, items = $$props.items);
		if ("itemFilter" in $$props) $$invalidate(40, itemFilter = $$props.itemFilter);
		if ("groupBy" in $$props) $$invalidate(41, groupBy = $$props.groupBy);
		if ("groupFilter" in $$props) $$invalidate(42, groupFilter = $$props.groupFilter);
		if ("isGroupHeaderSelectable" in $$props) $$invalidate(43, isGroupHeaderSelectable = $$props.isGroupHeaderSelectable);
		if ("getGroupHeaderLabel" in $$props) $$invalidate(44, getGroupHeaderLabel = $$props.getGroupHeaderLabel);
		if ("getOptionLabel" in $$props) $$invalidate(45, getOptionLabel = $$props.getOptionLabel);
		if ("optionIdentifier" in $$props) $$invalidate(46, optionIdentifier = $$props.optionIdentifier);
		if ("loadOptions" in $$props) $$invalidate(47, loadOptions = $$props.loadOptions);
		if ("hasError" in $$props) $$invalidate(10, hasError = $$props.hasError);
		if ("containerStyles" in $$props) $$invalidate(11, containerStyles = $$props.containerStyles);
		if ("getSelectionLabel" in $$props) $$invalidate(12, getSelectionLabel = $$props.getSelectionLabel);
		if ("createGroupHeaderItem" in $$props) $$invalidate(48, createGroupHeaderItem = $$props.createGroupHeaderItem);
		if ("createItem" in $$props) $$invalidate(49, createItem = $$props.createItem);
		if ("isSearchable" in $$props) $$invalidate(13, isSearchable = $$props.isSearchable);
		if ("inputStyles" in $$props) $$invalidate(14, inputStyles = $$props.inputStyles);
		if ("isClearable" in $$props) $$invalidate(15, isClearable = $$props.isClearable);
		if ("isWaiting" in $$props) $$invalidate(5, isWaiting = $$props.isWaiting);
		if ("listPlacement" in $$props) $$invalidate(50, listPlacement = $$props.listPlacement);
		if ("listOpen" in $$props) $$invalidate(34, listOpen = $$props.listOpen);
		if ("list" in $$props) $$invalidate(35, list = $$props.list);
		if ("isVirtualList" in $$props) $$invalidate(51, isVirtualList = $$props.isVirtualList);
		if ("loadOptionsInterval" in $$props) $$invalidate(52, loadOptionsInterval = $$props.loadOptionsInterval);
		if ("noOptionsMessage" in $$props) $$invalidate(53, noOptionsMessage = $$props.noOptionsMessage);
		if ("hideEmptyState" in $$props) $$invalidate(54, hideEmptyState = $$props.hideEmptyState);
		if ("filteredItems" in $$props) $$invalidate(36, filteredItems = $$props.filteredItems);
		if ("inputAttributes" in $$props) $$invalidate(55, inputAttributes = $$props.inputAttributes);
		if ("listAutoWidth" in $$props) $$invalidate(56, listAutoWidth = $$props.listAutoWidth);
		if ("itemHeight" in $$props) $$invalidate(57, itemHeight = $$props.itemHeight);
		if ("Icon" in $$props) $$invalidate(16, Icon = $$props.Icon);
		if ("iconProps" in $$props) $$invalidate(17, iconProps = $$props.iconProps);
		if ("showChevron" in $$props) $$invalidate(18, showChevron = $$props.showChevron);
		if ("showIndicator" in $$props) $$invalidate(19, showIndicator = $$props.showIndicator);
		if ("containerClasses" in $$props) $$invalidate(20, containerClasses = $$props.containerClasses);
		if ("indicatorSvg" in $$props) $$invalidate(21, indicatorSvg = $$props.indicatorSvg);
	};

	let disabled;
	let showSelectedItem;
	let placeholderText;

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*isDisabled*/ 512) {
			$: disabled = isDisabled;
		}

		if ($$self.$$.dirty[0] & /*selectedValue, isMulti*/ 264 | $$self.$$.dirty[1] & /*optionIdentifier*/ 32768) {
			$: {
				if (typeof selectedValue === "string") {
					$$invalidate(3, selectedValue = {
						[optionIdentifier]: selectedValue,
						label: selectedValue
					});
				} else if (isMulti && Array.isArray(selectedValue) && selectedValue.length > 0) {
					$$invalidate(3, selectedValue = selectedValue.map(item => typeof item === "string"
					? { value: item, label: item }
					: item));
				}
			}
		}

		if ($$self.$$.dirty[1] & /*noOptionsMessage, list*/ 4194320) {
			$: {
				if (noOptionsMessage && list) list.$set({ noOptionsMessage });
			}
		}

		if ($$self.$$.dirty[0] & /*selectedValue, filterText*/ 24) {
			$: $$invalidate(25, showSelectedItem = selectedValue && filterText.length === 0);
		}

		if ($$self.$$.dirty[0] & /*selectedValue*/ 8 | $$self.$$.dirty[1] & /*placeholder*/ 256) {
			$: $$invalidate(26, placeholderText = selectedValue ? "" : placeholder);
		}

		if ($$self.$$.dirty[0] & /*isSearchable*/ 8192 | $$self.$$.dirty[1] & /*inputAttributes*/ 16777216) {
			$: {
				$$invalidate(24, _inputAttributes = Object.assign(inputAttributes, {
					autocomplete: "off",
					autocorrect: "off",
					spellcheck: false
				}));

				if (!isSearchable) {
					$$invalidate(24, _inputAttributes.readonly = true, _inputAttributes);
				}
			}
		}

		if ($$self.$$.dirty[0] & /*filterText, isMulti, selectedValue*/ 280 | $$self.$$.dirty[1] & /*items, loadOptions, optionIdentifier, itemFilter, getOptionLabel, groupBy, createGroupHeaderItem, isGroupHeaderSelectable, groupFilter*/ 253444 | $$self.$$.dirty[2] & /*originalItemsClone*/ 4) {
			$: {
				let _filteredItems;
				let _items = items;

				if (items && items.length > 0 && typeof items[0] !== "object") {
					_items = items.map((item, index) => {
						return { index, value: item, label: item };
					});
				}

				if (loadOptions && filterText.length === 0 && originalItemsClone) {
					_filteredItems = JSON.parse(originalItemsClone);
					_items = JSON.parse(originalItemsClone);
				} else {
					_filteredItems = loadOptions
					? filterText.length === 0 ? [] : _items
					: _items.filter(item => {
							let keepItem = true;

							if (isMulti && selectedValue) {
								keepItem = !selectedValue.some(value => {
									return value[optionIdentifier] === item[optionIdentifier];
								});
							}

							if (!keepItem) return false;
							if (filterText.length < 1) return true;
							return itemFilter(getOptionLabel(item, filterText), filterText, item);
						});
				}

				if (groupBy) {
					const groupValues = [];
					const groups = {};

					_filteredItems.forEach(item => {
						const groupValue = groupBy(item);

						if (!groupValues.includes(groupValue)) {
							groupValues.push(groupValue);
							groups[groupValue] = [];

							if (groupValue) {
								groups[groupValue].push(Object.assign(createGroupHeaderItem(groupValue, item), {
									id: groupValue,
									isGroupHeader: true,
									isSelectable: isGroupHeaderSelectable
								}));
							}
						}

						groups[groupValue].push(Object.assign({ isGroupItem: !!groupValue }, item));
					});

					const sortedGroupedItems = [];

					groupFilter(groupValues).forEach(groupValue => {
						sortedGroupedItems.push(...groups[groupValue]);
					});

					$$invalidate(36, filteredItems = sortedGroupedItems);
				} else {
					$$invalidate(36, filteredItems = _filteredItems);
				}
			}
		}
	};

	return [
		container,
		input,
		isFocused,
		selectedValue,
		filterText,
		isWaiting,
		Selection,
		MultiSelection,
		isMulti,
		isDisabled,
		hasError,
		containerStyles,
		getSelectionLabel,
		isSearchable,
		inputStyles,
		isClearable,
		Icon,
		iconProps,
		showChevron,
		showIndicator,
		containerClasses,
		indicatorSvg,
		handleClear,
		activeSelectedValue,
		_inputAttributes,
		showSelectedItem,
		placeholderText,
		handleMultiItemClear,
		getPosition,
		handleKeyDown,
		handleFocus,
		handleWindowClick,
		handleClick,
		items,
		listOpen,
		list,
		filteredItems,
		Item,
		isCreatable,
		placeholder,
		itemFilter,
		groupBy,
		groupFilter,
		isGroupHeaderSelectable,
		getGroupHeaderLabel,
		getOptionLabel,
		optionIdentifier,
		loadOptions,
		createGroupHeaderItem,
		createItem,
		listPlacement,
		isVirtualList,
		loadOptionsInterval,
		noOptionsMessage,
		hideEmptyState,
		inputAttributes,
		listAutoWidth,
		itemHeight,
		input_1_binding,
		input_1_input_handler,
		input_1_binding_1,
		input_1_input_handler_1,
		div_binding
	];
}

class Select extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance,
			create_fragment,
			safe_not_equal,
			{
				container: 0,
				input: 1,
				Item: 37,
				Selection: 6,
				MultiSelection: 7,
				isMulti: 8,
				isDisabled: 9,
				isCreatable: 38,
				isFocused: 2,
				selectedValue: 3,
				filterText: 4,
				placeholder: 39,
				items: 33,
				itemFilter: 40,
				groupBy: 41,
				groupFilter: 42,
				isGroupHeaderSelectable: 43,
				getGroupHeaderLabel: 44,
				getOptionLabel: 45,
				optionIdentifier: 46,
				loadOptions: 47,
				hasError: 10,
				containerStyles: 11,
				getSelectionLabel: 12,
				createGroupHeaderItem: 48,
				createItem: 49,
				isSearchable: 13,
				inputStyles: 14,
				isClearable: 15,
				isWaiting: 5,
				listPlacement: 50,
				listOpen: 34,
				list: 35,
				isVirtualList: 51,
				loadOptionsInterval: 52,
				noOptionsMessage: 53,
				hideEmptyState: 54,
				filteredItems: 36,
				inputAttributes: 55,
				listAutoWidth: 56,
				itemHeight: 57,
				Icon: 16,
				iconProps: 17,
				showChevron: 18,
				showIndicator: 19,
				containerClasses: 20,
				indicatorSvg: 21,
				handleClear: 22
			},
			[-1, -1, -1]
		);
	}

	get handleClear() {
		return this.$$.ctx[22];
	}
}

export default Select;