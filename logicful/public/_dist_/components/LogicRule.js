/* src/components/LogicRule.svelte generated by Svelte v3.25.1 */
import {
	SvelteComponent,
	append,
	attr,
	check_outros,
	create_component,
	destroy_component,
	destroy_each,
	detach,
	element,
	empty,
	group_outros,
	init,
	insert,
	listen,
	mount_component,
	safe_not_equal,
	set_style,
	space,
	transition_in,
	transition_out
} from "../../web_modules/svelte/internal.js";

import { dispatch } from "../event/EventBus.js";
import { onMount } from "../../web_modules/svelte.js";
import { dispatchSingle } from "../event/EventBus.js";
import Field from "../features/form/edit/Field.js";
import { randomString } from "../util/Generate.js";
import { subscribeFieldChange } from "../event/FieldEvent.js";
import formStore from "../store/FormStore.js";
import { isObject } from "../guards/Guard.js";
import Label from "../inputs/Label.js";
import { firstNotEmpty } from "../util/Format.js";
import { assertExists } from "../util/Selection.js";
import { fastClone, isEmptyOrNull } from "../util/Compare.js";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[12] = list[i];
	child_ctx[14] = i;
	return child_ctx;
}

// (254:8) {#if field.logic?.rules?.[i]?.field}
function create_if_block_4(ctx) {
	let field_1;
	let current;

	field_1 = new Field({
			props: {
				config: { search: true },
				field: {
					id: randomString(),
					customCss: customCss(),
					label: "Select Your Condition",
					value: {
						type: "local",
						value: /*field*/ ctx[0].logic?.rules?.[/*i*/ ctx[14]]?.condition
					},
					type: "combobox",
					required: true,
					configFieldTarget: `logic.rules[${/*i*/ ctx[14]}].condition`,
					configTarget: /*field*/ ctx[0].id,
					options: {
						type: "local",
						value: /*conditions*/ ctx[6](/*i*/ ctx[14])
					}
				}
			}
		});

	return {
		c() {
			create_component(field_1.$$.fragment);
		},
		m(target, anchor) {
			mount_component(field_1, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const field_1_changes = {};

			if (dirty & /*field*/ 1) field_1_changes.field = {
				id: randomString(),
				customCss: customCss(),
				label: "Select Your Condition",
				value: {
					type: "local",
					value: /*field*/ ctx[0].logic?.rules?.[/*i*/ ctx[14]]?.condition
				},
				type: "combobox",
				required: true,
				configFieldTarget: `logic.rules[${/*i*/ ctx[14]}].condition`,
				configTarget: /*field*/ ctx[0].id,
				options: {
					type: "local",
					value: /*conditions*/ ctx[6](/*i*/ ctx[14])
				}
			};

			field_1.$set(field_1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(field_1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(field_1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(field_1, detaching);
		}
	};
}

// (261:8) {#if field.logic?.rules?.[i]?.condition && options[i]?.showValue}
function create_if_block_1(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block_2, create_if_block_3];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*options*/ ctx[2][/*i*/ ctx[14]].valueType === "text") return 0;
		if (/*options*/ ctx[2][/*i*/ ctx[14]].valueType === "combobox") return 1;
		return -1;
	}

	if (~(current_block_type_index = select_block_type(ctx, -1))) {
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	}

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (~current_block_type_index) {
				if_blocks[current_block_type_index].m(target, anchor);
			}

			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if (~current_block_type_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				}
			} else {
				if (if_block) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
				}

				if (~current_block_type_index) {
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					}

					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				} else {
					if_block = null;
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (~current_block_type_index) {
				if_blocks[current_block_type_index].d(detaching);
			}

			if (detaching) detach(if_block_anchor);
		}
	};
}

// (265:56) 
function create_if_block_3(ctx) {
	let field_1;
	let current;

	field_1 = new Field({
			props: {
				field: {
					id: randomString(),
					customCss: customCss(),
					helperText: /*options*/ ctx[2][/*i*/ ctx[14]].helperText,
					placeholder: /*options*/ ctx[2][/*i*/ ctx[14]].placeholder,
					label: "Provide Value For Conditional",
					value: {
						type: "local",
						value: /*field*/ ctx[0].logic?.rules?.[/*i*/ ctx[14]]?.value
					},
					type: "combobox",
					required: true,
					configFieldTarget: `logic.rules[${/*i*/ ctx[14]}].value`,
					configTarget: /*field*/ ctx[0].id,
					options: {
						type: "local",
						value: /*options*/ ctx[2][/*i*/ ctx[14]].options
					}
				}
			}
		});

	return {
		c() {
			create_component(field_1.$$.fragment);
		},
		m(target, anchor) {
			mount_component(field_1, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const field_1_changes = {};

			if (dirty & /*options, field*/ 5) field_1_changes.field = {
				id: randomString(),
				customCss: customCss(),
				helperText: /*options*/ ctx[2][/*i*/ ctx[14]].helperText,
				placeholder: /*options*/ ctx[2][/*i*/ ctx[14]].placeholder,
				label: "Provide Value For Conditional",
				value: {
					type: "local",
					value: /*field*/ ctx[0].logic?.rules?.[/*i*/ ctx[14]]?.value
				},
				type: "combobox",
				required: true,
				configFieldTarget: `logic.rules[${/*i*/ ctx[14]}].value`,
				configTarget: /*field*/ ctx[0].id,
				options: {
					type: "local",
					value: /*options*/ ctx[2][/*i*/ ctx[14]].options
				}
			};

			field_1.$set(field_1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(field_1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(field_1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(field_1, detaching);
		}
	};
}

// (262:10) {#if options[i].valueType === 'text'}
function create_if_block_2(ctx) {
	let field_1;
	let current;

	field_1 = new Field({
			props: {
				field: {
					id: randomString(),
					customCss: customCss(),
					helperText: /*options*/ ctx[2][/*i*/ ctx[14]].helperText,
					placeholder: /*options*/ ctx[2][/*i*/ ctx[14]].placeholder,
					label: "Provide Value For Conditional",
					value: {
						type: "local",
						value: /*field*/ ctx[0].logic?.rules?.[/*i*/ ctx[14]]?.value
					},
					type: "string",
					required: true,
					configFieldTarget: `logic.rules[${/*i*/ ctx[14]}].value`,
					configTarget: /*field*/ ctx[0].id
				}
			}
		});

	return {
		c() {
			create_component(field_1.$$.fragment);
		},
		m(target, anchor) {
			mount_component(field_1, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const field_1_changes = {};

			if (dirty & /*options, field*/ 5) field_1_changes.field = {
				id: randomString(),
				customCss: customCss(),
				helperText: /*options*/ ctx[2][/*i*/ ctx[14]].helperText,
				placeholder: /*options*/ ctx[2][/*i*/ ctx[14]].placeholder,
				label: "Provide Value For Conditional",
				value: {
					type: "local",
					value: /*field*/ ctx[0].logic?.rules?.[/*i*/ ctx[14]]?.value
				},
				type: "string",
				required: true,
				configFieldTarget: `logic.rules[${/*i*/ ctx[14]}].value`,
				configTarget: /*field*/ ctx[0].id
			};

			field_1.$set(field_1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(field_1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(field_1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(field_1, detaching);
		}
	};
}

// (231:2) {#each field.logic?.rules ?? [] as option, i}
function create_each_block(ctx) {
	let div5;
	let div2;
	let div1;
	let div0;
	let button;
	let t0;
	let field_1;
	let t1;
	let div3;
	let t2;
	let div4;
	let t3;
	let br;
	let current;
	let mounted;
	let dispose;

	function click_handler(...args) {
		return /*click_handler*/ ctx[8](/*i*/ ctx[14], ...args);
	}

	field_1 = new Field({
			props: {
				config: { search: true },
				field: {
					id: randomString(),
					loadTransformer: /*fieldsTransformer*/ ctx[7],
					helperText: "Select which field the conditional should be ran against.",
					label: "Select Field",
					value: {
						type: "local",
						value: /*field*/ ctx[0].logic?.rules?.[/*i*/ ctx[14]]?.field
					},
					type: "combobox",
					required: true,
					configFieldTarget: `logic.rules[${/*i*/ ctx[14]}].field`,
					configTarget: /*field*/ ctx[0].id,
					options: {
						type: "local",
						value: /*getFields*/ ctx[3]
					}
				}
			}
		});

	let if_block0 = /*field*/ ctx[0].logic?.rules?.[/*i*/ ctx[14]]?.field && create_if_block_4(ctx);
	let if_block1 = /*field*/ ctx[0].logic?.rules?.[/*i*/ ctx[14]]?.condition && /*options*/ ctx[2][/*i*/ ctx[14]]?.showValue && create_if_block_1(ctx);

	return {
		c() {
			div5 = element("div");
			div2 = element("div");
			div1 = element("div");
			div0 = element("div");
			button = element("button");
			button.innerHTML = `<span class="icon-brand"><span class="fas fa-trash"></span></span>`;
			t0 = space();
			create_component(field_1.$$.fragment);
			t1 = space();
			div3 = element("div");
			if (if_block0) if_block0.c();
			t2 = space();
			div4 = element("div");
			if (if_block1) if_block1.c();
			t3 = space();
			br = element("br");
			attr(button, "type", "button");
			attr(button, "class", "btn btn-secondary");
			set_style(button, "font-size", "0.5rem");
			set_style(button, "padding", "0.25rem 0.5rem");
			attr(div0, "class", "float-right");
			set_style(div0, "position", "relative");
			set_style(div0, "display", "inline-flex");
			set_style(div0, "vertical-align", "middle");
			set_style(div0, "top", "0.8em");
			set_style(div0, "right", "0.6em");
			attr(div1, "class", "col");
			attr(div2, "class", "row");
			attr(div3, "class", "row");
			attr(div4, "class", "row");
			attr(div5, "class", "container");
			set_style(div5, "background-color", "rgb(245 249 253)");
			set_style(div5, "padding-left", "0.3em");
			set_style(div5, "padding-right", "0.3em");
		},
		m(target, anchor) {
			insert(target, div5, anchor);
			append(div5, div2);
			append(div2, div1);
			append(div1, div0);
			append(div0, button);
			append(div1, t0);
			mount_component(field_1, div1, null);
			append(div5, t1);
			append(div5, div3);
			if (if_block0) if_block0.m(div3, null);
			append(div5, t2);
			append(div5, div4);
			if (if_block1) if_block1.m(div4, null);
			insert(target, t3, anchor);
			insert(target, br, anchor);
			current = true;

			if (!mounted) {
				dispose = listen(button, "click", click_handler);
				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			const field_1_changes = {};

			if (dirty & /*field*/ 1) field_1_changes.field = {
				id: randomString(),
				loadTransformer: /*fieldsTransformer*/ ctx[7],
				helperText: "Select which field the conditional should be ran against.",
				label: "Select Field",
				value: {
					type: "local",
					value: /*field*/ ctx[0].logic?.rules?.[/*i*/ ctx[14]]?.field
				},
				type: "combobox",
				required: true,
				configFieldTarget: `logic.rules[${/*i*/ ctx[14]}].field`,
				configTarget: /*field*/ ctx[0].id,
				options: {
					type: "local",
					value: /*getFields*/ ctx[3]
				}
			};

			field_1.$set(field_1_changes);

			if (/*field*/ ctx[0].logic?.rules?.[/*i*/ ctx[14]]?.field) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty & /*field*/ 1) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_4(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(div3, null);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (/*field*/ ctx[0].logic?.rules?.[/*i*/ ctx[14]]?.condition && /*options*/ ctx[2][/*i*/ ctx[14]]?.showValue) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty & /*field, options*/ 5) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_1(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div4, null);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(field_1.$$.fragment, local);
			transition_in(if_block0);
			transition_in(if_block1);
			current = true;
		},
		o(local) {
			transition_out(field_1.$$.fragment, local);
			transition_out(if_block0);
			transition_out(if_block1);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div5);
			destroy_component(field_1);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (detaching) detach(t3);
			if (detaching) detach(br);
			mounted = false;
			dispose();
		}
	};
}

// (274:2) {#if helperText}
function create_if_block(ctx) {
	let div;
	let raw_value = (/*helperText*/ ctx[1] ?? "") + "";

	return {
		c() {
			div = element("div");
			attr(div, "class", "helper-text");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			div.innerHTML = raw_value;
		},
		p(ctx, dirty) {
			if (dirty & /*helperText*/ 2 && raw_value !== (raw_value = (/*helperText*/ ctx[1] ?? "") + "")) div.innerHTML = raw_value;;
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

function create_fragment(ctx) {
	let div;
	let t0;
	let t1;
	let button;
	let current;
	let mounted;
	let dispose;
	let each_value = /*field*/ ctx[0].logic?.rules ?? [];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	let if_block = /*helperText*/ ctx[1] && create_if_block(ctx);

	return {
		c() {
			div = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t0 = space();
			if (if_block) if_block.c();
			t1 = space();
			button = element("button");
			button.textContent = "Add Rule";
			attr(button, "class", "btn-primary btn");
		},
		m(target, anchor) {
			insert(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}

			append(div, t0);
			if (if_block) if_block.m(div, null);
			append(div, t1);
			append(div, button);
			current = true;

			if (!mounted) {
				dispose = listen(button, "click", /*addNew*/ ctx[5]);
				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (dirty & /*randomString, customCss, options, field, conditions, fieldsTransformer, getFields, remove*/ 221) {
				each_value = /*field*/ ctx[0].logic?.rules ?? [];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(div, t0);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}

			if (/*helperText*/ ctx[1]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					if_block.m(div, t1);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_each(each_blocks, detaching);
			if (if_block) if_block.d();
			mounted = false;
			dispose();
		}
	};
}

function customCss() {
	return "padding-top: 0em; padding-left: 0.6em; padding-right: 0.6em; padding-bottom: 0.7em;";
}

function instance($$self, $$props, $$invalidate) {
	
	
	
	let { helperText = "" } = $$props;
	let { field } = $$props;
	let options = [];

	subscribeFieldChange(onMount, (newField, change) => {
		if (change.field === "value") {
			return;
		}

		if (field.id === newField.id) {
			$$invalidate(0, field = newField);

			if (field.logic?.action && isEmptyOrNull(field.logic?.rules)) {
				addNew();
			}

			if (field.logic?.rules) {
				field.logic.rules.forEach((f, i) => {
					$$invalidate(2, options[i] = getOptions(i), options);
				});
			}
		}
	});

	function getFields() {
		let fields = dispatchSingle("get_form_fields", {});
		fields = fields.filter(w => w.id !== field.id && w.type !== "spacer");
		return fields;
	}

	function remove(option) {
		const temp = fastClone(field.logic.rules);
		temp.splice(option, 1);
		$$invalidate(0, field.logic.rules = temp, field);
		formStore.set(field);
	}

	function addNew() {
		if (!field.logic?.rules) {
			$$invalidate(0, field.logic = field.logic ?? { rules: [], action: "" }, field);
			$$invalidate(0, field.logic.rules = [], field);
		}

		$$invalidate(0, field.logic.rules = field.logic.rules.concat([{ field: "", value: "", condition: "" }]), field);
		formStore.set(field);
	}

	function shouldShowValue(index) {
		const condition = field.logic?.rules?.[index]?.condition ?? "";
		const toNotShow = ["hasValue", "isTrue", "isFalse", "notHaveValue"];

		if (toNotShow.includes(condition)) {
			return false;
		}

		return true;
	}

	function getOptions(index) {
		const value = field.logic?.rules?.[index]?.condition;
		const condition = conditions(index).find(w => w.value === value);

		if (!condition) {
			return {
				valueType: "text",
				showValue: false,
				options: () => Promise.resolve([]),
				helperText: "",
				placeholder: ""
			};
		}

		return {
			valueType: condition.valueInput ?? "text",
			showValue: shouldShowValue(index),
			options: () => loadOptions(index),
			helperText: condition.helper ?? "",
			placeholder: condition.placeholder ?? ""
		};
	}

	function loadOptions(index) {
		const id = field.logic?.rules?.[index]?.field;

		if (!id) {
			return Promise.resolve([]);
		}

		return dispatchSingle("combobox_get_options", { id });
	}

	function conditions(index) {
		const targetFieldId = field.logic?.rules?.[index]?.field;

		if (!targetFieldId) {
			return [];
		}

		const fields = getFields();
		const targetField = fields.find(w => w.id === targetFieldId);

		if (!targetField) {
			return [];
		}

		if (targetField.type === "string") {
			return [
				{ label: "Contains", value: "contains" },
				{
					label: "Starts With",
					value: "startsWith"
				},
				{ label: "Ends With", value: "endsWith" },
				{ label: "Equals", value: "eq" },
				{ label: "Has Value", value: "hasValue" }
			];
		}

		if (targetField.type === "combobox") {
			return [
				{
					label: "Equals",
					value: "eq",
					valueInput: "combobox",
					options: loadOptions
				},
				{
					label: "Not Equals",
					value: "notEq",
					valueInput: "combobox",
					options: loadOptions
				},
				{
					label: "Has Selected Option",
					value: "hasValue"
				}
			];
		}

		if (targetField.type === "switch") {
			return [
				{ label: "Is Toggled", value: "isTrue" },
				{
					label: "Is Not Toggled",
					value: "isFalse"
				}
			];
		}

		if (targetField.type === "file") {
			return [
				{
					label: "Has Chosen File",
					value: "hasValue"
				},
				{
					label: "Has Not Chosen File",
					value: "notHaveValue"
				},
				{
					label: "Is File Extension",
					value: "isFileExtension",
					helper: "You can include multiple extensions by seperating with a comma.",
					placeholder: "pdf, txt, png"
				},
				{
					label: "Is Not File Extension",
					helper: "You can include multiple extensions by seperating with a comma.",
					value: "isNotFileExtension",
					placeholder: "pdf, txt, png"
				}
			];
		}

		if (targetField.type === "number") {
			return [
				{ label: "Greater Than", value: "gt" },
				{ label: "Less Than", value: "lt" },
				{
					label: "Less Than or Equal To",
					value: "lte"
				},
				{
					label: "Greater Than or Equal To",
					value: "gte"
				},
				{ label: "Equal To", value: "eq" },
				{ label: "Has Value", value: "hasValue" }
			];
		}

		return [];
	}

	function fieldsTransformer(fields) {
		return fields.map(f => {
			return {
				label: `${firstNotEmpty(f.label, f.name)} - ${f.type}`,
				value: f.id
			};
		});
	}

	const click_handler = i => remove(i);

	$$self.$$set = $$props => {
		if ("helperText" in $$props) $$invalidate(1, helperText = $$props.helperText);
		if ("field" in $$props) $$invalidate(0, field = $$props.field);
	};

	return [
		field,
		helperText,
		options,
		getFields,
		remove,
		addNew,
		conditions,
		fieldsTransformer,
		click_handler
	];
}

class LogicRule extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, { helperText: 1, field: 0 });
	}
}

export default LogicRule;