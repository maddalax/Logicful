/* src/features/folders/FolderSettings.svelte generated by Svelte v3.25.1 */
import {
	SvelteComponent,
	attr,
	check_outros,
	create_component,
	destroy_component,
	detach,
	element,
	empty,
	group_outros,
	init,
	insert,
	listen,
	mount_component,
	safe_not_equal,
	set_input_value,
	space,
	transition_in,
	transition_out
} from "../../../web_modules/svelte/internal.js";

import Dialog from "../../components/layout/Dialog.js";
import { dispatch } from "../../event/EventBus.js";
import { deleteApi, putApi } from "../../services/ApiService.js";

function create_if_block_1(ctx) {
	let dialog;
	let current;

	dialog = new Dialog({
			props: {
				isOpen: true,
				actions: /*deleteActions*/ ctx[3],
				title: `Confirm Deletion For ${/*folder*/ ctx[0].name}`,
				onClose: /*onClose*/ ctx[1],
				$$slots: { default: [create_default_slot_1] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(dialog.$$.fragment);
		},
		m(target, anchor) {
			mount_component(dialog, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const dialog_changes = {};
			if (dirty & /*folder*/ 1) dialog_changes.title = `Confirm Deletion For ${/*folder*/ ctx[0].name}`;
			if (dirty & /*onClose*/ 2) dialog_changes.onClose = /*onClose*/ ctx[1];

			if (dirty & /*$$scope*/ 256) {
				dialog_changes.$$scope = { dirty, ctx };
			}

			dialog.$set(dialog_changes);
		},
		i(local) {
			if (current) return;
			transition_in(dialog.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(dialog.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(dialog, detaching);
		}
	};
}

// (46:2) <Dialog isOpen={true} actions={deleteActions} title={`Confirm Deletion For ${folder.name}`} {onClose}>
function create_default_slot_1(ctx) {
	let p;

	return {
		c() {
			p = element("p");
			p.textContent = "Are you sure you want to delete this folder? All forms in this folder will be moved to uncategorized.";
		},
		m(target, anchor) {
			insert(target, p, anchor);
		},
		d(detaching) {
			if (detaching) detach(p);
		}
	};
}

// (51:0) {#if folder && !deleting}
function create_if_block(ctx) {
	let dialog;
	let current;

	dialog = new Dialog({
			props: {
				isOpen: true,
				actions: /*actions*/ ctx[4],
				title: `Editing ${/*folder*/ ctx[0].name}`,
				onClose: /*onClose*/ ctx[1],
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(dialog.$$.fragment);
		},
		m(target, anchor) {
			mount_component(dialog, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const dialog_changes = {};
			if (dirty & /*folder*/ 1) dialog_changes.title = `Editing ${/*folder*/ ctx[0].name}`;
			if (dirty & /*onClose*/ 2) dialog_changes.onClose = /*onClose*/ ctx[1];

			if (dirty & /*$$scope, folder*/ 257) {
				dialog_changes.$$scope = { dirty, ctx };
			}

			dialog.$set(dialog_changes);
		},
		i(local) {
			if (current) return;
			transition_in(dialog.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(dialog.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(dialog, detaching);
		}
	};
}

// (52:2) <Dialog isOpen={true} {actions} title={`Editing ${folder.name}`} {onClose}>
function create_default_slot(ctx) {
	let label;
	let t1;
	let input;
	let mounted;
	let dispose;

	return {
		c() {
			label = element("label");
			label.textContent = "Name";
			t1 = space();
			input = element("input");
			attr(label, "for", "name");
			attr(input, "type", "text");
			attr(input, "class", "form-control");
			attr(input, "name", "name");
		},
		m(target, anchor) {
			insert(target, label, anchor);
			insert(target, t1, anchor);
			insert(target, input, anchor);
			set_input_value(input, /*folder*/ ctx[0].name);

			if (!mounted) {
				dispose = listen(input, "input", /*input_input_handler*/ ctx[5]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty & /*folder*/ 1 && input.value !== /*folder*/ ctx[0].name) {
				set_input_value(input, /*folder*/ ctx[0].name);
			}
		},
		d(detaching) {
			if (detaching) detach(label);
			if (detaching) detach(t1);
			if (detaching) detach(input);
			mounted = false;
			dispose();
		}
	};
}

function create_fragment(ctx) {
	let t;
	let if_block1_anchor;
	let current;
	let if_block0 = /*deleting*/ ctx[2] && create_if_block_1(ctx);
	let if_block1 = /*folder*/ ctx[0] && !/*deleting*/ ctx[2] && create_if_block(ctx);

	return {
		c() {
			if (if_block0) if_block0.c();
			t = space();
			if (if_block1) if_block1.c();
			if_block1_anchor = empty();
		},
		m(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert(target, t, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert(target, if_block1_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			if (/*deleting*/ ctx[2]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty & /*deleting*/ 4) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_1(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(t.parentNode, t);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (/*folder*/ ctx[0] && !/*deleting*/ ctx[2]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty & /*folder, deleting*/ 5) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);
			current = true;
		},
		o(local) {
			transition_out(if_block0);
			transition_out(if_block1);
			current = false;
		},
		d(detaching) {
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach(t);
			if (if_block1) if_block1.d(detaching);
			if (detaching) detach(if_block1_anchor);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	
	
	let { folder } = $$props;
	let { onClose } = $$props;
	let deleting = false;

	let deleteActions = [
		{
			label: "Confirm",
			onClick: deleteFolder,
			type: "danger"
		},
		{
			label: "Cancel",
			onClick: () => $$invalidate(2, deleting = false),
			type: "secondary",
			onClose: false
		}
	];

	let actions = [
		{
			label: "Delete",
			onClick: () => $$invalidate(2, deleting = true),
			type: "danger",
			onClose: false
		},
		{
			label: "Save",
			onClick: save,
			type: "primary"
		}
	];

	async function deleteFolder() {
		await deleteApi(`folder/${folder.id}`, {});
		dispatch("folder_deleted", folder);
	}

	async function save() {
		await putApi(`folder/${folder.id}`, folder);
		dispatch("folder_updated", folder);
	}

	function input_input_handler() {
		folder.name = this.value;
		$$invalidate(0, folder);
	}

	$$self.$$set = $$props => {
		if ("folder" in $$props) $$invalidate(0, folder = $$props.folder);
		if ("onClose" in $$props) $$invalidate(1, onClose = $$props.onClose);
	};

	return [folder, onClose, deleting, deleteActions, actions, input_input_handler];
}

class FolderSettings extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, { folder: 0, onClose: 1 });
	}
}

export default FolderSettings;