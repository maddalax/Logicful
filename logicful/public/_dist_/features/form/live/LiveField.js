import './LiveField.css.proxy.js';
/* src/features/form/live/LiveField.svelte generated by Svelte v3.25.1 */
import {
	SvelteComponent,
	append,
	assign,
	attr,
	check_outros,
	create_component,
	destroy_component,
	detach,
	element,
	get_spread_object,
	get_spread_update,
	group_outros,
	init,
	insert,
	mount_component,
	noop,
	safe_not_equal,
	set_style,
	toggle_class,
	transition_in,
	transition_out
} from "../../../../web_modules/svelte/internal.js";

import TextInput from "../../../inputs/TextInput.js";
import { afterUpdate, onMount } from "../../../../web_modules/svelte.js";
import ComboBox from "../../../inputs/ComboBox.js";
import { LoadState } from "../../../models/LoadState.js";
import { FieldValueLoader } from "../../../loader/FieldValueLoader.js";
import Address from "../../../inputs/Address.js";
import TextArea from "../../../inputs/TextArea.js";
import Spacer from "../../../inputs/Spacer.js";
import formStore from "../../../store/FormStore.js";
import { fade } from "../../../../web_modules/svelte/transition.js";
import RichTextDisplay from "../../../inputs/RichTextDisplay.js";
import Switch from "../../../inputs/Switch.js";
import DatePicker from "../../../components/DatePicker.js";
import { firstNotEmpty } from "../../../util/Format.js";
import { fastClone, fastEquals } from "../../../util/Compare.js";
import FileUpload from "../../../inputs/FileUpload.js";
import FullName from "../../../inputs/FullName.js";
import CheckboxGroup from "../../../inputs/CheckboxGroup.js";
import RadioGroup from "../../../inputs/RadioGroup.js";

function create_else_block(ctx) {
	let div;
	let current_block_type_index;
	let if_block;
	let current;

	const if_block_creators = [
		create_if_block_1,
		create_if_block_2,
		create_if_block_3,
		create_if_block_4,
		create_if_block_5,
		create_if_block_6,
		create_if_block_7,
		create_if_block_8,
		create_if_block_9,
		create_if_block_10,
		create_if_block_11,
		create_if_block_12,
		create_if_block_13
	];

	const if_blocks = [];

	function select_block_type_1(ctx, dirty) {
		if (/*field*/ ctx[0].type === "address") return 0;
		if (/*field*/ ctx[0].type === "string") return 1;
		if (/*field*/ ctx[0].type === "number") return 2;
		if (/*field*/ ctx[0].type === "combobox") return 3;
		if (/*field*/ ctx[0].type === "block") return 4;
		if (/*field*/ ctx[0].type === "block-editor") return 5;
		if (/*field*/ ctx[0].type === "spacer") return 6;
		if (/*field*/ ctx[0].type === "switch") return 7;
		if (/*field*/ ctx[0].type === "date") return 8;
		if (/*field*/ ctx[0].type === "file") return 9;
		if (/*field*/ ctx[0].type === "checkbox-group") return 10;
		if (/*field*/ ctx[0].type === "radio-group") return 11;
		if (/*field*/ ctx[0].type === "full-name") return 12;
		return -1;
	}

	if (~(current_block_type_index = select_block_type_1(ctx, -1))) {
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	}

	return {
		c() {
			div = element("div");
			if (if_block) if_block.c();
		},
		m(target, anchor) {
			insert(target, div, anchor);

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_1(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if (~current_block_type_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				}
			} else {
				if (if_block) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
				}

				if (~current_block_type_index) {
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					}

					transition_in(if_block, 1);
					if_block.m(div, null);
				} else {
					if_block = null;
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].d();
			}
		}
	};
}

// (70:4) {#if hidden}
function create_if_block(ctx) {
	let span;

	return {
		c() {
			span = element("span");
		},
		m(target, anchor) {
			insert(target, span, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (98:45) 
function create_if_block_13(ctx) {
	let fullname;
	let current;

	fullname = new FullName({
			props: {
				field: /*field*/ ctx[0],
				value: /*value*/ ctx[3]
			}
		});

	return {
		c() {
			create_component(fullname.$$.fragment);
		},
		m(target, anchor) {
			mount_component(fullname, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const fullname_changes = {};
			if (dirty & /*field*/ 1) fullname_changes.field = /*field*/ ctx[0];
			if (dirty & /*value*/ 8) fullname_changes.value = /*value*/ ctx[3];
			fullname.$set(fullname_changes);
		},
		i(local) {
			if (current) return;
			transition_in(fullname.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(fullname.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(fullname, detaching);
		}
	};
}

// (96:47) 
function create_if_block_12(ctx) {
	let radiogroup;
	let current;
	radiogroup = new RadioGroup({ props: { field: /*field*/ ctx[0] } });

	return {
		c() {
			create_component(radiogroup.$$.fragment);
		},
		m(target, anchor) {
			mount_component(radiogroup, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const radiogroup_changes = {};
			if (dirty & /*field*/ 1) radiogroup_changes.field = /*field*/ ctx[0];
			radiogroup.$set(radiogroup_changes);
		},
		i(local) {
			if (current) return;
			transition_in(radiogroup.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(radiogroup.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(radiogroup, detaching);
		}
	};
}

// (94:50) 
function create_if_block_11(ctx) {
	let checkboxgroup;
	let current;
	checkboxgroup = new CheckboxGroup({ props: { field: /*field*/ ctx[0] } });

	return {
		c() {
			create_component(checkboxgroup.$$.fragment);
		},
		m(target, anchor) {
			mount_component(checkboxgroup, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const checkboxgroup_changes = {};
			if (dirty & /*field*/ 1) checkboxgroup_changes.field = /*field*/ ctx[0];
			checkboxgroup.$set(checkboxgroup_changes);
		},
		i(local) {
			if (current) return;
			transition_in(checkboxgroup.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(checkboxgroup.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(checkboxgroup, detaching);
		}
	};
}

// (92:40) 
function create_if_block_10(ctx) {
	let fileupload;
	let current;
	fileupload = new FileUpload({ props: { field: /*field*/ ctx[0] } });

	return {
		c() {
			create_component(fileupload.$$.fragment);
		},
		m(target, anchor) {
			mount_component(fileupload, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const fileupload_changes = {};
			if (dirty & /*field*/ 1) fileupload_changes.field = /*field*/ ctx[0];
			fileupload.$set(fileupload_changes);
		},
		i(local) {
			if (current) return;
			transition_in(fileupload.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(fileupload.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(fileupload, detaching);
		}
	};
}

// (90:40) 
function create_if_block_9(ctx) {
	let datepicker;
	let current;
	const datepicker_spread_levels = [{ field: /*field*/ ctx[0] }, /*config*/ ctx[1]];
	let datepicker_props = {};

	for (let i = 0; i < datepicker_spread_levels.length; i += 1) {
		datepicker_props = assign(datepicker_props, datepicker_spread_levels[i]);
	}

	datepicker = new DatePicker({ props: datepicker_props });

	return {
		c() {
			create_component(datepicker.$$.fragment);
		},
		m(target, anchor) {
			mount_component(datepicker, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const datepicker_changes = (dirty & /*field, config*/ 3)
			? get_spread_update(datepicker_spread_levels, [
					dirty & /*field*/ 1 && { field: /*field*/ ctx[0] },
					dirty & /*config*/ 2 && get_spread_object(/*config*/ ctx[1])
				])
			: {};

			datepicker.$set(datepicker_changes);
		},
		i(local) {
			if (current) return;
			transition_in(datepicker.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(datepicker.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(datepicker, detaching);
		}
	};
}

// (88:42) 
function create_if_block_8(ctx) {
	let switch_1;
	let current;
	const switch_1_spread_levels = [{ field: /*field*/ ctx[0] }, /*config*/ ctx[1]];
	let switch_1_props = {};

	for (let i = 0; i < switch_1_spread_levels.length; i += 1) {
		switch_1_props = assign(switch_1_props, switch_1_spread_levels[i]);
	}

	switch_1 = new Switch({ props: switch_1_props });

	return {
		c() {
			create_component(switch_1.$$.fragment);
		},
		m(target, anchor) {
			mount_component(switch_1, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const switch_1_changes = (dirty & /*field, config*/ 3)
			? get_spread_update(switch_1_spread_levels, [
					dirty & /*field*/ 1 && { field: /*field*/ ctx[0] },
					dirty & /*config*/ 2 && get_spread_object(/*config*/ ctx[1])
				])
			: {};

			switch_1.$set(switch_1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(switch_1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(switch_1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(switch_1, detaching);
		}
	};
}

// (86:42) 
function create_if_block_7(ctx) {
	let spacer;
	let current;
	spacer = new Spacer({ props: { field: /*field*/ ctx[0] } });

	return {
		c() {
			create_component(spacer.$$.fragment);
		},
		m(target, anchor) {
			mount_component(spacer, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const spacer_changes = {};
			if (dirty & /*field*/ 1) spacer_changes.field = /*field*/ ctx[0];
			spacer.$set(spacer_changes);
		},
		i(local) {
			if (current) return;
			transition_in(spacer.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(spacer.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(spacer, detaching);
		}
	};
}

// (84:48) 
function create_if_block_6(ctx) {
	let textarea;
	let current;
	const textarea_spread_levels = [{ field: /*field*/ ctx[0] }, /*config*/ ctx[1]];
	let textarea_props = {};

	for (let i = 0; i < textarea_spread_levels.length; i += 1) {
		textarea_props = assign(textarea_props, textarea_spread_levels[i]);
	}

	textarea = new TextArea({ props: textarea_props });

	return {
		c() {
			create_component(textarea.$$.fragment);
		},
		m(target, anchor) {
			mount_component(textarea, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const textarea_changes = (dirty & /*field, config*/ 3)
			? get_spread_update(textarea_spread_levels, [
					dirty & /*field*/ 1 && { field: /*field*/ ctx[0] },
					dirty & /*config*/ 2 && get_spread_object(/*config*/ ctx[1])
				])
			: {};

			textarea.$set(textarea_changes);
		},
		i(local) {
			if (current) return;
			transition_in(textarea.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(textarea.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(textarea, detaching);
		}
	};
}

// (82:41) 
function create_if_block_5(ctx) {
	let richtextdisplay;
	let current;
	richtextdisplay = new RichTextDisplay({ props: { field: /*field*/ ctx[0] } });

	return {
		c() {
			create_component(richtextdisplay.$$.fragment);
		},
		m(target, anchor) {
			mount_component(richtextdisplay, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const richtextdisplay_changes = {};
			if (dirty & /*field*/ 1) richtextdisplay_changes.field = /*field*/ ctx[0];
			richtextdisplay.$set(richtextdisplay_changes);
		},
		i(local) {
			if (current) return;
			transition_in(richtextdisplay.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(richtextdisplay.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(richtextdisplay, detaching);
		}
	};
}

// (80:44) 
function create_if_block_4(ctx) {
	let combobox;
	let current;
	const combobox_spread_levels = [{ field: /*field*/ ctx[0] }, /*config*/ ctx[1]];
	let combobox_props = {};

	for (let i = 0; i < combobox_spread_levels.length; i += 1) {
		combobox_props = assign(combobox_props, combobox_spread_levels[i]);
	}

	combobox = new ComboBox({ props: combobox_props });

	return {
		c() {
			create_component(combobox.$$.fragment);
		},
		m(target, anchor) {
			mount_component(combobox, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const combobox_changes = (dirty & /*field, config*/ 3)
			? get_spread_update(combobox_spread_levels, [
					dirty & /*field*/ 1 && { field: /*field*/ ctx[0] },
					dirty & /*config*/ 2 && get_spread_object(/*config*/ ctx[1])
				])
			: {};

			combobox.$set(combobox_changes);
		},
		i(local) {
			if (current) return;
			transition_in(combobox.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(combobox.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(combobox, detaching);
		}
	};
}

// (78:42) 
function create_if_block_3(ctx) {
	let textinput;
	let current;

	textinput = new TextInput({
			props: { field: /*field*/ ctx[0], type: "number" }
		});

	return {
		c() {
			create_component(textinput.$$.fragment);
		},
		m(target, anchor) {
			mount_component(textinput, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const textinput_changes = {};
			if (dirty & /*field*/ 1) textinput_changes.field = /*field*/ ctx[0];
			textinput.$set(textinput_changes);
		},
		i(local) {
			if (current) return;
			transition_in(textinput.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(textinput.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(textinput, detaching);
		}
	};
}

// (76:42) 
function create_if_block_2(ctx) {
	let textinput;
	let current;
	textinput = new TextInput({ props: { field: /*field*/ ctx[0] } });

	return {
		c() {
			create_component(textinput.$$.fragment);
		},
		m(target, anchor) {
			mount_component(textinput, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const textinput_changes = {};
			if (dirty & /*field*/ 1) textinput_changes.field = /*field*/ ctx[0];
			textinput.$set(textinput_changes);
		},
		i(local) {
			if (current) return;
			transition_in(textinput.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(textinput.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(textinput, detaching);
		}
	};
}

// (74:8) {#if field.type === 'address'}
function create_if_block_1(ctx) {
	let address;
	let current;

	address = new Address({
			props: {
				field: /*field*/ ctx[0],
				value: /*value*/ ctx[3]
			}
		});

	return {
		c() {
			create_component(address.$$.fragment);
		},
		m(target, anchor) {
			mount_component(address, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const address_changes = {};
			if (dirty & /*field*/ 1) address_changes.field = /*field*/ ctx[0];
			if (dirty & /*value*/ 8) address_changes.value = /*value*/ ctx[3];
			address.$set(address_changes);
		},
		i(local) {
			if (current) return;
			transition_in(address.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(address.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(address, detaching);
		}
	};
}

function create_fragment(ctx) {
	let div1;
	let div0;
	let current_block_type_index;
	let if_block;
	let div1_style_value;
	let current;
	const if_block_creators = [create_if_block, create_else_block];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*hidden*/ ctx[2]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx, -1);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			div1 = element("div");
			div0 = element("div");
			if_block.c();
			set_style(div0, "border-radius", "1em");
			attr(div1, "style", div1_style_value = /*spacing*/ ctx[4]());
			attr(div1, "class", "svelte-18kj95s");
			toggle_class(div1, "hidden", /*hidden*/ ctx[2]);
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			append(div1, div0);
			if_blocks[current_block_type_index].m(div0, null);
			current = true;
		},
		p(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(div0, null);
			}

			if (dirty & /*hidden*/ 4) {
				toggle_class(div1, "hidden", /*hidden*/ ctx[2]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div1);
			if_blocks[current_block_type_index].d();
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	
	let { field } = $$props;
	let state = LoadState.NotStarted;
	let value;
	let lastValue;
	let { padding = true } = $$props;
	let { config = {} } = $$props;
	let { hidden = false } = $$props;
	onMount(load);

	afterUpdate(async () => {
		if (field.value && !fastEquals(field.value, lastValue)) {
			await load();
		}
	});

	async function load() {
		lastValue = field.value;

		if ((field.value ?? field.defaultValue) != null) {
			state = LoadState.Loading;

			try {
				const loader = new FieldValueLoader();
				const result = await loader.load(field);
				$$invalidate(3, value = result);
				$$invalidate(0, field.value = result, field);
				lastValue = result;

				formStore.set(field, {
					value: result,
					field: "value",
					fromUser: false
				});

				state = LoadState.Finished;
			} catch(e) {
				console.error(e);
				state = LoadState.Failed;
			}
		}
	}

	function spacing() {
		if (!padding) {
			return "";
		}

		if (field.type === "address") {
			return "margin-bottom: .85em";
		}

		return "margin-bottom: 1.3em";
	}

	$$self.$$set = $$props => {
		if ("field" in $$props) $$invalidate(0, field = $$props.field);
		if ("padding" in $$props) $$invalidate(5, padding = $$props.padding);
		if ("config" in $$props) $$invalidate(1, config = $$props.config);
		if ("hidden" in $$props) $$invalidate(2, hidden = $$props.hidden);
	};

	return [field, config, hidden, value, spacing, padding];
}

class LiveField extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance, create_fragment, safe_not_equal, {
			field: 0,
			padding: 5,
			config: 1,
			hidden: 2
		});
	}
}

export default LiveField;