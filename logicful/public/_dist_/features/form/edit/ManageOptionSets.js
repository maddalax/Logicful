/* src/features/form/edit/ManageOptionSets.svelte generated by Svelte v3.25.1 */
import {
	SvelteComponent,
	append,
	attr,
	check_outros,
	create_component,
	destroy_component,
	destroy_each,
	detach,
	element,
	group_outros,
	init,
	insert,
	mount_component,
	noop,
	safe_not_equal,
	set_data,
	set_style,
	space,
	text,
	transition_in,
	transition_out
} from "../../../../web_modules/svelte/internal.js";

import { onMount } from "../../../../web_modules/svelte.js";
import Field from "./Field.js";
import Repeater from "../../../components/Repeater.js";
import { getUrlParameter } from "../../../util/Http.js";
import DropdownButton from "../../../components/DropdownButton.js";
import OptionSetsList from "./OptionSetsList.js";
import { dispatch } from "../../../event/EventBus.js";
import { isString } from "../../../guards/Guard.js";
import { getApi, postApi, putApi } from "../../../services/ApiService.js";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[15] = list[i];
	child_ctx[16] = list;
	child_ctx[17] = i;
	return child_ctx;
}

// (116:2) {:else}
function create_else_block_1(ctx) {
	let div1;

	return {
		c() {
			div1 = element("div");
			div1.innerHTML = `<div class="spinner-border text-secondary" role="status"><span class="sr-only">Loading...</span></div>`;
			set_style(div1, "text-align", "center");
			set_style(div1, "padding-top", "1em");
			set_style(div1, "padding-bottom", "1em");
		},
		m(target, anchor) {
			insert(target, div1, anchor);
		},
		d(detaching) {
			if (detaching) detach(div1);
		}
	};
}

// (114:2) {#if sets.length > 0}
function create_if_block_3(ctx) {
	return { c: noop, m: noop, d: noop };
}

// (158:8) {:else}
function create_else_block(ctx) {
	let repeater;
	let current;

	function func_3(...args) {
		return /*func_3*/ ctx[11](/*index*/ ctx[17], ...args);
	}

	repeater = new Repeater({
			props: {
				options: isString(/*set*/ ctx[15].value)
				? []
				: /*set*/ ctx[15].value,
				onChange: func_3
			}
		});

	return {
		c() {
			create_component(repeater.$$.fragment);
		},
		m(target, anchor) {
			mount_component(repeater, target, anchor);
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			const repeater_changes = {};

			if (dirty & /*sets*/ 2) repeater_changes.options = isString(/*set*/ ctx[15].value)
			? []
			: /*set*/ ctx[15].value;

			repeater.$set(repeater_changes);
		},
		i(local) {
			if (current) return;
			transition_in(repeater.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(repeater.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(repeater, detaching);
		}
	};
}

// (156:26) 
function create_if_block_2(ctx) {
	let t;

	return {
		c() {
			t = text("Failed to load, please try re-opening this dialog.");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (154:26) 
function create_if_block_1(ctx) {
	let div;

	return {
		c() {
			div = element("div");
			attr(div, "class", "loader");
		},
		m(target, anchor) {
			insert(target, div, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

// (148:8) {#if set.type === 'remote'}
function create_if_block(ctx) {
	let field;
	let current;

	function func_2(...args) {
		return /*func_2*/ ctx[10](/*set*/ ctx[15], /*each_value*/ ctx[16], /*index*/ ctx[17], ...args);
	}

	field = new Field({
			props: {
				field: {
					helperText: "See <a href=\"test\" target=\"_blank\">Remote Option Set Guide</a> for information on how to structure your endpoint response.",
					onChange: func_2,
					id: `${/*set*/ ctx[15].name}-url`,
					type: "string",
					value: /*set*/ ctx[15].value,
					name: "url",
					label: "Url",
					required: true
				}
			}
		});

	return {
		c() {
			create_component(field.$$.fragment);
		},
		m(target, anchor) {
			mount_component(field, target, anchor);
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			const field_changes = {};

			if (dirty & /*sets*/ 2) field_changes.field = {
				helperText: "See <a href=\"test\" target=\"_blank\">Remote Option Set Guide</a> for information on how to structure your endpoint response.",
				onChange: func_2,
				id: `${/*set*/ ctx[15].name}-url`,
				type: "string",
				value: /*set*/ ctx[15].value,
				name: "url",
				label: "Url",
				required: true
			};

			field.$set(field_changes);
		},
		i(local) {
			if (current) return;
			transition_in(field.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(field.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(field, detaching);
		}
	};
}

// (121:2) {#each sets as set, index}
function create_each_block(ctx) {
	let div1;
	let h2;
	let t0_value = (/*set*/ ctx[15].name ?? "") + "";
	let t0;
	let t1;
	let div0;
	let field0;
	let t2;
	let field1;
	let t3;
	let current_block_type_index;
	let if_block;
	let div0_id_value;
	let current;

	function func(...args) {
		return /*func*/ ctx[8](/*set*/ ctx[15], /*each_value*/ ctx[16], /*index*/ ctx[17], ...args);
	}

	field0 = new Field({
			props: {
				field: {
					id: `${/*set*/ ctx[15].id}-name`,
					type: "string",
					required: true,
					name: "name",
					label: "Name",
					placeholder: "Name",
					value: /*set*/ ctx[15].name,
					onChange: func
				}
			}
		});

	function func_1(...args) {
		return /*func_1*/ ctx[9](/*set*/ ctx[15], /*each_value*/ ctx[16], /*index*/ ctx[17], ...args);
	}

	field1 = new Field({
			props: {
				field: {
					onChange: func_1,
					id: `${/*set*/ ctx[15].id}-type`,
					type: "combobox",
					value: /*set*/ ctx[15].type,
					options: {
						type: "local",
						value: [
							{ label: "Inline", value: "local" },
							{ label: "Remote", value: "remote" }
						]
					},
					name: "type",
					label: "Type",
					helperText: "Choose whether you want to automatically load options in from a remote url or manually specify them here."
				}
			}
		});

	const if_block_creators = [create_if_block, create_if_block_1, create_if_block_2, create_else_block];
	const if_blocks = [];

	function select_block_type_1(ctx, dirty) {
		if (/*set*/ ctx[15].type === "remote") return 0;
		if (/*loading*/ ctx[2]) return 1;
		if (/*errored*/ ctx[3]) return 2;
		return 3;
	}

	current_block_type_index = select_block_type_1(ctx, -1);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			div1 = element("div");
			h2 = element("h2");
			t0 = text(t0_value);
			t1 = space();
			div0 = element("div");
			create_component(field0.$$.fragment);
			t2 = space();
			create_component(field1.$$.fragment);
			t3 = space();
			if_block.c();
			attr(div0, "id", div0_id_value = /*set*/ ctx[15].name ?? "");
			set_style(div1, "margin-top", "1em");
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			append(div1, h2);
			append(h2, t0);
			append(div1, t1);
			append(div1, div0);
			mount_component(field0, div0, null);
			append(div0, t2);
			mount_component(field1, div0, null);
			append(div0, t3);
			if_blocks[current_block_type_index].m(div0, null);
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			if ((!current || dirty & /*sets*/ 2) && t0_value !== (t0_value = (/*set*/ ctx[15].name ?? "") + "")) set_data(t0, t0_value);
			const field0_changes = {};

			if (dirty & /*sets*/ 2) field0_changes.field = {
				id: `${/*set*/ ctx[15].id}-name`,
				type: "string",
				required: true,
				name: "name",
				label: "Name",
				placeholder: "Name",
				value: /*set*/ ctx[15].name,
				onChange: func
			};

			field0.$set(field0_changes);
			const field1_changes = {};

			if (dirty & /*sets, isNew*/ 3) field1_changes.field = {
				onChange: func_1,
				id: `${/*set*/ ctx[15].id}-type`,
				type: "combobox",
				value: /*set*/ ctx[15].type,
				options: {
					type: "local",
					value: [
						{ label: "Inline", value: "local" },
						{ label: "Remote", value: "remote" }
					]
				},
				name: "type",
				label: "Type",
				helperText: "Choose whether you want to automatically load options in from a remote url or manually specify them here."
			};

			field1.$set(field1_changes);
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_1(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(div0, null);
			}

			if (!current || dirty & /*sets*/ 2 && div0_id_value !== (div0_id_value = /*set*/ ctx[15].name ?? "")) {
				attr(div0, "id", div0_id_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in(field0.$$.fragment, local);
			transition_in(field1.$$.fragment, local);
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(field0.$$.fragment, local);
			transition_out(field1.$$.fragment, local);
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div1);
			destroy_component(field0);
			destroy_component(field1);
			if_blocks[current_block_type_index].d();
		}
	};
}

function create_fragment(ctx) {
	let div1;
	let t0;
	let t1;
	let div0;
	let dropdownbutton;
	let current;

	function select_block_type(ctx, dirty) {
		if (/*sets*/ ctx[1].length > 0) return create_if_block_3;
		return create_else_block_1;
	}

	let current_block_type = select_block_type(ctx, -1);
	let if_block = current_block_type(ctx);
	let each_value = /*sets*/ ctx[1];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	dropdownbutton = new DropdownButton({
			props: {
				label: "Save",
				processingLabel: "Saving...",
				actions: [
					{
						label: "Save as Draft",
						onClick: /*save*/ ctx[6]
					},
					{
						label: "Save and Publish",
						onClick: /*save*/ ctx[6]
					}
				]
			}
		});

	return {
		c() {
			div1 = element("div");
			if_block.c();
			t0 = space();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t1 = space();
			div0 = element("div");
			create_component(dropdownbutton.$$.fragment);
			attr(div0, "class", "float-right");
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			if_block.m(div1, null);
			append(div1, t0);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div1, null);
			}

			append(div1, t1);
			append(div1, div0);
			mount_component(dropdownbutton, div0, null);
			current = true;
		},
		p(ctx, [dirty]) {
			if (current_block_type !== (current_block_type = select_block_type(ctx, dirty))) {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(div1, t0);
				}
			}

			if (dirty & /*sets, loading, errored, isString, onRepeaterChange, isNew, undefined, loadLocalOptions*/ 63) {
				each_value = /*sets*/ ctx[1];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(div1, t1);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			transition_in(dropdownbutton.$$.fragment, local);
			current = true;
		},
		o(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			transition_out(dropdownbutton.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div1);
			if_block.d();
			destroy_each(each_blocks, detaching);
			destroy_component(dropdownbutton);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	
	
	let sets = [];
	let loading = false;
	let errored = false;
	let { name } = $$props;
	let { isNew } = $$props;

	onMount(async () => {
		if (isNew) {
			$$invalidate(1, sets = sets.concat([
				{
					value: [{ label: "", value: "" }],
					type: "local"
				}
			]));
		} else {
			await load();
		}
	});

	async function load() {
		$$invalidate(2, loading = true);
		const data = await getApi("option-set");
		const result = data.find(w => w.name === name);

		if (!result) {
			return;
		}

		if (result.type === "local") {
			result.localSaveId = result.value;
			result.value = await convertUrlToLocal(result);
		}

		$$invalidate(1, sets = [result]);
		$$invalidate(2, loading = false);
	}

	async function loadLocalOptions(index) {
		$$invalidate(1, sets[index].value = await convertUrlToLocal(sets[index]), sets);
	}

	async function convertUrlToLocal(set) {
		$$invalidate(2, loading = true);

		try {
			const url = set.value ?? set.localSaveId;

			if (!url) {
				return [{ label: "", value: "" }];
			}

			const response = await fetch(url);
			const data = await response.json();
			const results = [];

			Object.keys(data).forEach(key => {
				results.push({ label: key, value: data[key] });
			});

			return results;
		} catch(ex) {
			$$invalidate(3, errored = true);
			return [];
		} finally {
			$$invalidate(2, loading = false);
		}
	}

	function onRepeaterChange(data, index) {
		$$invalidate(1, sets[index].value = data, sets);
	}

	async function save() {
		const promises = sets.map(async s => {
			if (s.type === "local") {
				s.value = await generateInlineUrl(s);
			}

			return s;
		});

		const toSave = await Promise.all(promises);
		await postApi("option-set", toSave[0]);
		dispatch("option_set_modified", toSave[0]);

		dispatch("dialog_show", {
			child: OptionSetsList,
			closeOnOutsideClick: false,
			confirmCloseOnDirty: true,
			title: "Manage Option Sets"
		});
	}

	async function generateInlineUrl(set) {
		const body = {};
		const v = set.value;

		v.forEach(s => {
			body[s.label] = s.value;
		});

		const saveId = getUrlParameter("id", set.localSaveId);
		const qs = saveId ? `?id=${saveId}` : "";

		const { message } = qs
		? await putApi(`s3/json?${qs}`, body)
		: await postApi(`s3/json?${qs}`, body);

		return message;
	}

	const func = (set, each_value, index, value) => {
		$$invalidate(1, each_value[index].name = value, sets);
	};

	const func_1 = (set, each_value, index, value) => {
		if (value === "local") {
			$$invalidate(1, each_value[index].remoteUrl = set.value, sets);
			$$invalidate(1, each_value[index].value = set.localOptions, sets);

			if (!isNew && set.localOptions?.length === 0) {
				$$invalidate(1, each_value[index].value = undefined, sets);
				loadLocalOptions(index);
			}
		}

		if (value === "remote") {
			$$invalidate(1, each_value[index].localOptions = set.value ?? [], sets);
			$$invalidate(1, each_value[index].value = set.remoteUrl, sets);
		}

		$$invalidate(1, each_value[index].type = value, sets);
	};

	const func_2 = (set, each_value, index, value) => {
		$$invalidate(1, each_value[index].value = value, sets);
	};

	const func_3 = (index, data) => {
		onRepeaterChange(data, index);
	};

	$$self.$$set = $$props => {
		if ("name" in $$props) $$invalidate(7, name = $$props.name);
		if ("isNew" in $$props) $$invalidate(0, isNew = $$props.isNew);
	};

	return [
		isNew,
		sets,
		loading,
		errored,
		loadLocalOptions,
		onRepeaterChange,
		save,
		name,
		func,
		func_1,
		func_2,
		func_3
	];
}

class ManageOptionSets extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, { name: 7, isNew: 0 });
	}
}

export default ManageOptionSets;