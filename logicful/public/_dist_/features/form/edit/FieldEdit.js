/* src/features/form/edit/FieldEdit.svelte generated by Svelte v3.25.1 */
import {
	SvelteComponent,
	append,
	attr,
	check_outros,
	create_component,
	destroy_component,
	detach,
	element,
	group_outros,
	init,
	insert,
	mount_component,
	safe_not_equal,
	set_style,
	space,
	transition_in,
	transition_out
} from "../../../../web_modules/svelte/internal.js";

import { afterUpdate, onMount } from "../../../../web_modules/svelte.js";
import { randomString } from "../../../util/Generate.js";
import FieldTypeEditor from "./FieldTypeEditor.js";
import LogicAccordion from "./LogicAccordion.js";
import ContentBlockEditor from "./ContentBlockEditor.js";
import AddressEditor from "./AddressEditor.js";
import CheckboxGroupEditor from "./CheckboxGroupEditor.js";
import RadioGroupEditor from "./RadioGroupEditor.js";
import Field from "./Field.js";
import Button from "../../../components/Button.js";
import LogicBuilder from "./LogicBuilder.js";
import GroupAccordion from "./GroupAccordion.js";

function create_else_block(ctx) {
	let div0;
	let t2;
	let div1;
	let show_if = !/*cantBeRequired*/ ctx[1].includes(/*field*/ ctx[0].type);
	let t3;
	let field0;
	let t4;
	let field1;
	let t5;
	let field2;
	let t6;
	let field3;
	let t7;
	let fieldtypeeditor;
	let div1_id_value;
	let current;
	let if_block = show_if && create_if_block_2(ctx);

	field0 = new Field({
			props: {
				field: {
					id: randomString(),
					label: "Name",
					required: true,
					value: /*field*/ ctx[0].name,
					type: "string",
					configFieldTarget: "name",
					configTarget: /*field*/ ctx[0].id
				}
			}
		});

	field1 = new Field({
			props: {
				field: {
					id: randomString(),
					label: "Label",
					value: /*field*/ ctx[0].label,
					type: "string",
					configFieldTarget: "label",
					configTarget: /*field*/ ctx[0].id
				}
			}
		});

	field2 = new Field({
			props: {
				field: {
					id: randomString(),
					label: "Helper Text",
					value: /*field*/ ctx[0].helperText,
					type: "string",
					configFieldTarget: "helperText",
					configTarget: /*field*/ ctx[0].id
				}
			}
		});

	field3 = new Field({
			props: {
				field: {
					id: randomString(),
					label: "Field Type",
					value: {
						type: "local",
						value: /*field*/ ctx[0].type
					},
					type: "combobox",
					required: true,
					configFieldTarget: "type",
					configTarget: /*field*/ ctx[0].id,
					options: {
						type: "remote",
						value: "http://localhost:8080/field-types.json"
					}
				}
			}
		});

	fieldtypeeditor = new FieldTypeEditor({ props: { field: /*field*/ ctx[0] } });

	return {
		c() {
			div0 = element("div");

			div0.innerHTML = `<h5 style="padding-bottom: 0.2em;">Field Settings</h5> 
        <hr/>`;

			t2 = space();
			div1 = element("div");
			if (if_block) if_block.c();
			t3 = space();
			create_component(field0.$$.fragment);
			t4 = space();
			create_component(field1.$$.fragment);
			t5 = space();
			create_component(field2.$$.fragment);
			t6 = space();
			create_component(field3.$$.fragment);
			t7 = space();
			create_component(fieldtypeeditor.$$.fragment);
			set_style(div0, "padding-left", "0.5em");
			attr(div1, "id", div1_id_value = `field-button-${/*field*/ ctx[0].id}`);
		},
		m(target, anchor) {
			insert(target, div0, anchor);
			insert(target, t2, anchor);
			insert(target, div1, anchor);
			if (if_block) if_block.m(div1, null);
			append(div1, t3);
			mount_component(field0, div1, null);
			append(div1, t4);
			mount_component(field1, div1, null);
			append(div1, t5);
			mount_component(field2, div1, null);
			append(div1, t6);
			mount_component(field3, div1, null);
			append(div1, t7);
			mount_component(fieldtypeeditor, div1, null);
			current = true;
		},
		p(ctx, dirty) {
			if (dirty & /*field*/ 1) show_if = !/*cantBeRequired*/ ctx[1].includes(/*field*/ ctx[0].type);

			if (show_if) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*field*/ 1) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_2(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(div1, t3);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			const field0_changes = {};

			if (dirty & /*field*/ 1) field0_changes.field = {
				id: randomString(),
				label: "Name",
				required: true,
				value: /*field*/ ctx[0].name,
				type: "string",
				configFieldTarget: "name",
				configTarget: /*field*/ ctx[0].id
			};

			field0.$set(field0_changes);
			const field1_changes = {};

			if (dirty & /*field*/ 1) field1_changes.field = {
				id: randomString(),
				label: "Label",
				value: /*field*/ ctx[0].label,
				type: "string",
				configFieldTarget: "label",
				configTarget: /*field*/ ctx[0].id
			};

			field1.$set(field1_changes);
			const field2_changes = {};

			if (dirty & /*field*/ 1) field2_changes.field = {
				id: randomString(),
				label: "Helper Text",
				value: /*field*/ ctx[0].helperText,
				type: "string",
				configFieldTarget: "helperText",
				configTarget: /*field*/ ctx[0].id
			};

			field2.$set(field2_changes);
			const field3_changes = {};

			if (dirty & /*field*/ 1) field3_changes.field = {
				id: randomString(),
				label: "Field Type",
				value: {
					type: "local",
					value: /*field*/ ctx[0].type
				},
				type: "combobox",
				required: true,
				configFieldTarget: "type",
				configTarget: /*field*/ ctx[0].id,
				options: {
					type: "remote",
					value: "http://localhost:8080/field-types.json"
				}
			};

			field3.$set(field3_changes);
			const fieldtypeeditor_changes = {};
			if (dirty & /*field*/ 1) fieldtypeeditor_changes.field = /*field*/ ctx[0];
			fieldtypeeditor.$set(fieldtypeeditor_changes);

			if (!current || dirty & /*field*/ 1 && div1_id_value !== (div1_id_value = `field-button-${/*field*/ ctx[0].id}`)) {
				attr(div1, "id", div1_id_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			transition_in(field0.$$.fragment, local);
			transition_in(field1.$$.fragment, local);
			transition_in(field2.$$.fragment, local);
			transition_in(field3.$$.fragment, local);
			transition_in(fieldtypeeditor.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			transition_out(field0.$$.fragment, local);
			transition_out(field1.$$.fragment, local);
			transition_out(field2.$$.fragment, local);
			transition_out(field3.$$.fragment, local);
			transition_out(fieldtypeeditor.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div0);
			if (detaching) detach(t2);
			if (detaching) detach(div1);
			if (if_block) if_block.d();
			destroy_component(field0);
			destroy_component(field1);
			destroy_component(field2);
			destroy_component(field3);
			destroy_component(fieldtypeeditor);
		}
	};
}

// (26:37) 
function create_if_block_1(ctx) {
	let contentblockeditor;
	let current;

	contentblockeditor = new ContentBlockEditor({
			props: {
				field: /*field*/ ctx[0],
				expanded: /*field*/ ctx[0].expanded
			}
		});

	return {
		c() {
			create_component(contentblockeditor.$$.fragment);
		},
		m(target, anchor) {
			mount_component(contentblockeditor, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const contentblockeditor_changes = {};
			if (dirty & /*field*/ 1) contentblockeditor_changes.field = /*field*/ ctx[0];
			if (dirty & /*field*/ 1) contentblockeditor_changes.expanded = /*field*/ ctx[0].expanded;
			contentblockeditor.$set(contentblockeditor_changes);
		},
		i(local) {
			if (current) return;
			transition_in(contentblockeditor.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(contentblockeditor.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(contentblockeditor, detaching);
		}
	};
}

// (22:4) {#if field.type === 'spacer'}
function create_if_block(ctx) {
	let field_1;
	let current;

	field_1 = new Field({
			props: {
				field: {
					id: randomString(),
					label: "Increase value to add more spacing between the previous and next field.",
					required: true,
					value: /*field*/ ctx[0].options?.spacer ?? 1,
					type: "number",
					configFieldTarget: "options.spacer",
					configTarget: /*field*/ ctx[0].id
				}
			}
		});

	return {
		c() {
			create_component(field_1.$$.fragment);
		},
		m(target, anchor) {
			mount_component(field_1, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const field_1_changes = {};

			if (dirty & /*field*/ 1) field_1_changes.field = {
				id: randomString(),
				label: "Increase value to add more spacing between the previous and next field.",
				required: true,
				value: /*field*/ ctx[0].options?.spacer ?? 1,
				type: "number",
				configFieldTarget: "options.spacer",
				configTarget: /*field*/ ctx[0].id
			};

			field_1.$set(field_1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(field_1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(field_1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(field_1, detaching);
		}
	};
}

// (34:8) {#if !cantBeRequired.includes(field.type)}
function create_if_block_2(ctx) {
	let field_1;
	let current;

	field_1 = new Field({
			props: {
				config: { search: false },
				field: {
					id: randomString(),
					customCss: "padding-bottom: 0em;",
					label: "Required",
					value: {
						type: "local",
						value: /*field*/ ctx[0].required
					},
					type: "switch",
					configFieldTarget: "required",
					configTarget: /*field*/ ctx[0].id,
					options: {
						type: "local",
						value: [{ label: "Yes", value: true }, { label: "No", value: false }]
					}
				}
			}
		});

	return {
		c() {
			create_component(field_1.$$.fragment);
		},
		m(target, anchor) {
			mount_component(field_1, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const field_1_changes = {};

			if (dirty & /*field*/ 1) field_1_changes.field = {
				id: randomString(),
				customCss: "padding-bottom: 0em;",
				label: "Required",
				value: {
					type: "local",
					value: /*field*/ ctx[0].required
				},
				type: "switch",
				configFieldTarget: "required",
				configTarget: /*field*/ ctx[0].id,
				options: {
					type: "local",
					value: [{ label: "Yes", value: true }, { label: "No", value: false }]
				}
			};

			field_1.$set(field_1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(field_1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(field_1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(field_1, detaching);
		}
	};
}

function create_fragment(ctx) {
	let div1;
	let div0;
	let current_block_type_index;
	let if_block;
	let t0;
	let logicaccordion;
	let t1;
	let groupaccordion;
	let current;
	const if_block_creators = [create_if_block, create_if_block_1, create_else_block];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*field*/ ctx[0].type === "spacer") return 0;
		if (/*field*/ ctx[0].type === "block") return 1;
		return 2;
	}

	current_block_type_index = select_block_type(ctx, -1);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	logicaccordion = new LogicAccordion({ props: { field: /*field*/ ctx[0] } });
	groupaccordion = new GroupAccordion({ props: { field: /*field*/ ctx[0] } });

	return {
		c() {
			div1 = element("div");
			div0 = element("div");
			if_block.c();
			t0 = space();
			create_component(logicaccordion.$$.fragment);
			t1 = space();
			create_component(groupaccordion.$$.fragment);
			set_style(div0, "max-height", "95vh");
			set_style(div0, "overflow", "auto");
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			append(div1, div0);
			if_blocks[current_block_type_index].m(div0, null);
			append(div0, t0);
			mount_component(logicaccordion, div0, null);
			append(div0, t1);
			mount_component(groupaccordion, div0, null);
			current = true;
		},
		p(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(div0, t0);
			}

			const logicaccordion_changes = {};
			if (dirty & /*field*/ 1) logicaccordion_changes.field = /*field*/ ctx[0];
			logicaccordion.$set(logicaccordion_changes);
			const groupaccordion_changes = {};
			if (dirty & /*field*/ 1) groupaccordion_changes.field = /*field*/ ctx[0];
			groupaccordion.$set(groupaccordion_changes);
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			transition_in(logicaccordion.$$.fragment, local);
			transition_in(groupaccordion.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			transition_out(logicaccordion.$$.fragment, local);
			transition_out(groupaccordion.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div1);
			if_blocks[current_block_type_index].d();
			destroy_component(logicaccordion);
			destroy_component(groupaccordion);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	
	
	let { field } = $$props;
	let { config = {} } = $$props;
	let cantBeRequired = ["switch"];

	$$self.$$set = $$props => {
		if ("field" in $$props) $$invalidate(0, field = $$props.field);
		if ("config" in $$props) $$invalidate(2, config = $$props.config);
	};

	return [field, cantBeRequired, config];
}

class FieldEdit extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, { field: 0, config: 2 });
	}
}

export default FieldEdit;