import './Field.css.proxy.js';
/* src/features/form/edit/Field.svelte generated by Svelte v3.25.1 */
import {
	SvelteComponent,
	append,
	assign,
	attr,
	check_outros,
	create_component,
	destroy_component,
	detach,
	element,
	get_spread_object,
	get_spread_update,
	group_outros,
	init,
	insert,
	listen,
	mount_component,
	noop,
	run_all,
	safe_not_equal,
	set_data,
	set_style,
	space,
	stop_propagation,
	text,
	toggle_class,
	transition_in,
	transition_out
} from "../../../../web_modules/svelte/internal.js";

import TextInput from "../../../inputs/TextInput.js";
import { onMount } from "../../../../web_modules/svelte.js";
import ComboBox from "../../../inputs/ComboBox.js";
import { LoadState } from "../../../models/LoadState.js";
import { FieldValueLoader } from "../../../loader/FieldValueLoader.js";
import Address from "../../../inputs/Address.js";
import FullName from "../../../inputs/FullName.js";
import TextArea from "../../../inputs/TextArea.js";
import CheckboxGroup from "../../../inputs/CheckboxGroup.js";
import Spacer from "../../../inputs/Spacer.js";
import RadioGroup from "../../../inputs/RadioGroup.js";
import formStore from "../../../store/FormStore.js";
import { fade } from "../../../../web_modules/svelte/transition.js";
import RichTextDisplay from "../../../inputs/RichTextDisplay.js";
import { dispatch } from "../../../event/EventBus.js";
import Switch from "../../../inputs/Switch.js";
import { subscribeComponent } from "../../../event/EventBus.js";
import DatePicker from "../../../components/DatePicker.js";
import { firstNotEmpty } from "../../../util/Format.js";
import { subscribeFieldChange } from "../../../event/FieldEvent.js";
import { fastClone } from "../../../util/Compare.js";
import FileUpload from "../../../inputs/FileUpload.js";
import Dialog from "../../../components/layout/Dialog.js";

function create_if_block_15(ctx) {
	let div;
	let button0;
	let t;
	let button1;
	let mounted;
	let dispose;

	return {
		c() {
			div = element("div");
			button0 = element("button");
			button0.innerHTML = `<span class="icon-brand"><span class="far fa-clone"></span></span>`;
			t = space();
			button1 = element("button");
			button1.innerHTML = `<span class="icon-brand"><span class="fas fa-trash"></span></span>`;
			attr(button0, "type", "button");
			attr(button0, "class", "btn btn-secondary svelte-gpg6ej");
			set_style(button0, "font-size", "0.5rem");
			set_style(button0, "padding", "0.25rem 0.5rem");
			attr(button1, "type", "button");
			attr(button1, "class", "btn btn-secondary svelte-gpg6ej");
			set_style(button1, "font-size", "0.5rem");
			set_style(button1, "padding", "0.25rem 0.5rem");
			attr(div, "class", "btn-group float-right svelte-gpg6ej");
			attr(div, "role", "group");
			attr(div, "aria-label", "Selected");
			set_style(div, "top", "-0.5em");
			set_style(div, "right", "1em");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, button0);
			append(div, t);
			append(div, button1);

			if (!mounted) {
				dispose = [
					listen(button0, "click", stop_propagation(/*onClone*/ ctx[5])),
					listen(button1, "click", stop_propagation(/*click_handler*/ ctx[9]))
				];

				mounted = true;
			}
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(div);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (135:4) {:else}
function create_else_block(ctx) {
	let p;
	let t0;
	let t1_value = JSON.stringify(/*field*/ ctx[0], null, 2) + "";
	let t1;

	return {
		c() {
			p = element("p");
			t0 = text("No field found for field. ");
			t1 = text(t1_value);
		},
		m(target, anchor) {
			insert(target, p, anchor);
			append(p, t0);
			append(p, t1);
		},
		p(ctx, dirty) {
			if (dirty & /*field*/ 1 && t1_value !== (t1_value = JSON.stringify(/*field*/ ctx[0], null, 2) + "")) set_data(t1, t1_value);
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(p);
		}
	};
}

// (133:41) 
function create_if_block_14(ctx) {
	let fullname;
	let current;

	fullname = new FullName({
			props: {
				field: /*field*/ ctx[0],
				value: /*value*/ ctx[4]
			}
		});

	return {
		c() {
			create_component(fullname.$$.fragment);
		},
		m(target, anchor) {
			mount_component(fullname, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const fullname_changes = {};
			if (dirty & /*field*/ 1) fullname_changes.field = /*field*/ ctx[0];
			if (dirty & /*value*/ 16) fullname_changes.value = /*value*/ ctx[4];
			fullname.$set(fullname_changes);
		},
		i(local) {
			if (current) return;
			transition_in(fullname.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(fullname.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(fullname, detaching);
		}
	};
}

// (131:43) 
function create_if_block_13(ctx) {
	let radiogroup;
	let current;
	radiogroup = new RadioGroup({ props: { field: /*field*/ ctx[0] } });

	return {
		c() {
			create_component(radiogroup.$$.fragment);
		},
		m(target, anchor) {
			mount_component(radiogroup, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const radiogroup_changes = {};
			if (dirty & /*field*/ 1) radiogroup_changes.field = /*field*/ ctx[0];
			radiogroup.$set(radiogroup_changes);
		},
		i(local) {
			if (current) return;
			transition_in(radiogroup.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(radiogroup.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(radiogroup, detaching);
		}
	};
}

// (129:46) 
function create_if_block_12(ctx) {
	let checkboxgroup;
	let current;
	checkboxgroup = new CheckboxGroup({ props: { field: /*field*/ ctx[0] } });

	return {
		c() {
			create_component(checkboxgroup.$$.fragment);
		},
		m(target, anchor) {
			mount_component(checkboxgroup, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const checkboxgroup_changes = {};
			if (dirty & /*field*/ 1) checkboxgroup_changes.field = /*field*/ ctx[0];
			checkboxgroup.$set(checkboxgroup_changes);
		},
		i(local) {
			if (current) return;
			transition_in(checkboxgroup.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(checkboxgroup.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(checkboxgroup, detaching);
		}
	};
}

// (127:36) 
function create_if_block_11(ctx) {
	let fileupload;
	let current;
	fileupload = new FileUpload({ props: { field: /*field*/ ctx[0] } });

	return {
		c() {
			create_component(fileupload.$$.fragment);
		},
		m(target, anchor) {
			mount_component(fileupload, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const fileupload_changes = {};
			if (dirty & /*field*/ 1) fileupload_changes.field = /*field*/ ctx[0];
			fileupload.$set(fileupload_changes);
		},
		i(local) {
			if (current) return;
			transition_in(fileupload.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(fileupload.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(fileupload, detaching);
		}
	};
}

// (122:43) 
function create_if_block_10(ctx) {
	let div;

	return {
		c() {
			div = element("div");

			div.innerHTML = `<i class="fas fa-grip-horizontal"></i> 
        <p>You have no fields, drag one from the left sidebar to get started.</p>`;

			attr(div, "class", "placeholder svelte-gpg6ej");
		},
		m(target, anchor) {
			insert(target, div, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

// (120:36) 
function create_if_block_9(ctx) {
	let datepicker;
	let current;
	const datepicker_spread_levels = [{ field: /*field*/ ctx[0] }, /*config*/ ctx[2]];
	let datepicker_props = {};

	for (let i = 0; i < datepicker_spread_levels.length; i += 1) {
		datepicker_props = assign(datepicker_props, datepicker_spread_levels[i]);
	}

	datepicker = new DatePicker({ props: datepicker_props });

	return {
		c() {
			create_component(datepicker.$$.fragment);
		},
		m(target, anchor) {
			mount_component(datepicker, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const datepicker_changes = (dirty & /*field, config*/ 5)
			? get_spread_update(datepicker_spread_levels, [
					dirty & /*field*/ 1 && { field: /*field*/ ctx[0] },
					dirty & /*config*/ 4 && get_spread_object(/*config*/ ctx[2])
				])
			: {};

			datepicker.$set(datepicker_changes);
		},
		i(local) {
			if (current) return;
			transition_in(datepicker.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(datepicker.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(datepicker, detaching);
		}
	};
}

// (118:38) 
function create_if_block_8(ctx) {
	let switch_1;
	let current;
	const switch_1_spread_levels = [{ field: /*field*/ ctx[0] }, /*config*/ ctx[2]];
	let switch_1_props = {};

	for (let i = 0; i < switch_1_spread_levels.length; i += 1) {
		switch_1_props = assign(switch_1_props, switch_1_spread_levels[i]);
	}

	switch_1 = new Switch({ props: switch_1_props });

	return {
		c() {
			create_component(switch_1.$$.fragment);
		},
		m(target, anchor) {
			mount_component(switch_1, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const switch_1_changes = (dirty & /*field, config*/ 5)
			? get_spread_update(switch_1_spread_levels, [
					dirty & /*field*/ 1 && { field: /*field*/ ctx[0] },
					dirty & /*config*/ 4 && get_spread_object(/*config*/ ctx[2])
				])
			: {};

			switch_1.$set(switch_1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(switch_1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(switch_1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(switch_1, detaching);
		}
	};
}

// (116:38) 
function create_if_block_7(ctx) {
	let spacer;
	let current;
	spacer = new Spacer({ props: { field: /*field*/ ctx[0] } });

	return {
		c() {
			create_component(spacer.$$.fragment);
		},
		m(target, anchor) {
			mount_component(spacer, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const spacer_changes = {};
			if (dirty & /*field*/ 1) spacer_changes.field = /*field*/ ctx[0];
			spacer.$set(spacer_changes);
		},
		i(local) {
			if (current) return;
			transition_in(spacer.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(spacer.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(spacer, detaching);
		}
	};
}

// (114:44) 
function create_if_block_6(ctx) {
	let textarea;
	let current;
	const textarea_spread_levels = [{ field: /*field*/ ctx[0] }, /*config*/ ctx[2], { isPreview: true }];
	let textarea_props = {};

	for (let i = 0; i < textarea_spread_levels.length; i += 1) {
		textarea_props = assign(textarea_props, textarea_spread_levels[i]);
	}

	textarea = new TextArea({ props: textarea_props });

	return {
		c() {
			create_component(textarea.$$.fragment);
		},
		m(target, anchor) {
			mount_component(textarea, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const textarea_changes = (dirty & /*field, config*/ 5)
			? get_spread_update(textarea_spread_levels, [
					dirty & /*field*/ 1 && { field: /*field*/ ctx[0] },
					dirty & /*config*/ 4 && get_spread_object(/*config*/ ctx[2]),
					textarea_spread_levels[2]
				])
			: {};

			textarea.$set(textarea_changes);
		},
		i(local) {
			if (current) return;
			transition_in(textarea.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(textarea.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(textarea, detaching);
		}
	};
}

// (112:37) 
function create_if_block_5(ctx) {
	let richtextdisplay;
	let current;

	richtextdisplay = new RichTextDisplay({
			props: { field: /*field*/ ctx[0], isPreview: true }
		});

	return {
		c() {
			create_component(richtextdisplay.$$.fragment);
		},
		m(target, anchor) {
			mount_component(richtextdisplay, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const richtextdisplay_changes = {};
			if (dirty & /*field*/ 1) richtextdisplay_changes.field = /*field*/ ctx[0];
			richtextdisplay.$set(richtextdisplay_changes);
		},
		i(local) {
			if (current) return;
			transition_in(richtextdisplay.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(richtextdisplay.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(richtextdisplay, detaching);
		}
	};
}

// (110:40) 
function create_if_block_4(ctx) {
	let combobox;
	let current;
	const combobox_spread_levels = [{ field: /*field*/ ctx[0] }, /*config*/ ctx[2]];
	let combobox_props = {};

	for (let i = 0; i < combobox_spread_levels.length; i += 1) {
		combobox_props = assign(combobox_props, combobox_spread_levels[i]);
	}

	combobox = new ComboBox({ props: combobox_props });

	return {
		c() {
			create_component(combobox.$$.fragment);
		},
		m(target, anchor) {
			mount_component(combobox, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const combobox_changes = (dirty & /*field, config*/ 5)
			? get_spread_update(combobox_spread_levels, [
					dirty & /*field*/ 1 && { field: /*field*/ ctx[0] },
					dirty & /*config*/ 4 && get_spread_object(/*config*/ ctx[2])
				])
			: {};

			combobox.$set(combobox_changes);
		},
		i(local) {
			if (current) return;
			transition_in(combobox.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(combobox.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(combobox, detaching);
		}
	};
}

// (108:38) 
function create_if_block_3(ctx) {
	let textinput;
	let current;

	textinput = new TextInput({
			props: { field: /*field*/ ctx[0], type: "number" }
		});

	return {
		c() {
			create_component(textinput.$$.fragment);
		},
		m(target, anchor) {
			mount_component(textinput, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const textinput_changes = {};
			if (dirty & /*field*/ 1) textinput_changes.field = /*field*/ ctx[0];
			textinput.$set(textinput_changes);
		},
		i(local) {
			if (current) return;
			transition_in(textinput.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(textinput.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(textinput, detaching);
		}
	};
}

// (106:38) 
function create_if_block_2(ctx) {
	let textinput;
	let current;
	textinput = new TextInput({ props: { field: /*field*/ ctx[0] } });

	return {
		c() {
			create_component(textinput.$$.fragment);
		},
		m(target, anchor) {
			mount_component(textinput, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const textinput_changes = {};
			if (dirty & /*field*/ 1) textinput_changes.field = /*field*/ ctx[0];
			textinput.$set(textinput_changes);
		},
		i(local) {
			if (current) return;
			transition_in(textinput.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(textinput.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(textinput, detaching);
		}
	};
}

// (104:39) 
function create_if_block_1(ctx) {
	let address;
	let current;

	address = new Address({
			props: {
				field: /*field*/ ctx[0],
				value: /*value*/ ctx[4]
			}
		});

	return {
		c() {
			create_component(address.$$.fragment);
		},
		m(target, anchor) {
			mount_component(address, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const address_changes = {};
			if (dirty & /*field*/ 1) address_changes.field = /*field*/ ctx[0];
			if (dirty & /*value*/ 16) address_changes.value = /*value*/ ctx[4];
			address.$set(address_changes);
		},
		i(local) {
			if (current) return;
			transition_in(address.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(address.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(address, detaching);
		}
	};
}

// (102:4) {#if hidden}
function create_if_block(ctx) {
	let p;
	let t0_value = firstNotEmpty(/*field*/ ctx[0].label, /*field*/ ctx[0].name) + "";
	let t0;
	let t1;

	return {
		c() {
			p = element("p");
			t0 = text(t0_value);
			t1 = text(" is hidden by rules defined in logic. This message is only displayed on this preview.");
		},
		m(target, anchor) {
			insert(target, p, anchor);
			append(p, t0);
			append(p, t1);
		},
		p(ctx, dirty) {
			if (dirty & /*field*/ 1 && t0_value !== (t0_value = firstNotEmpty(/*field*/ ctx[0].label, /*field*/ ctx[0].name) + "")) set_data(t0, t0_value);
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(p);
		}
	};
}

function create_fragment(ctx) {
	let div1;
	let t;
	let div0;
	let current_block_type_index;
	let if_block1;
	let div0_style_value;
	let current;
	let mounted;
	let dispose;
	let if_block0 = /*field*/ ctx[0].selected && create_if_block_15(ctx);

	const if_block_creators = [
		create_if_block,
		create_if_block_1,
		create_if_block_2,
		create_if_block_3,
		create_if_block_4,
		create_if_block_5,
		create_if_block_6,
		create_if_block_7,
		create_if_block_8,
		create_if_block_9,
		create_if_block_10,
		create_if_block_11,
		create_if_block_12,
		create_if_block_13,
		create_if_block_14,
		create_else_block
	];

	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*hidden*/ ctx[3]) return 0;
		if (/*field*/ ctx[0].type === "address") return 1;
		if (/*field*/ ctx[0].type === "string") return 2;
		if (/*field*/ ctx[0].type === "number") return 3;
		if (/*field*/ ctx[0].type === "combobox") return 4;
		if (/*field*/ ctx[0].type === "block") return 5;
		if (/*field*/ ctx[0].type === "block-editor") return 6;
		if (/*field*/ ctx[0].type === "spacer") return 7;
		if (/*field*/ ctx[0].type === "switch") return 8;
		if (/*field*/ ctx[0].type === "date") return 9;
		if (/*field*/ ctx[0].type === "placeholder") return 10;
		if (/*field*/ ctx[0].type === "file") return 11;
		if (/*field*/ ctx[0].type === "checkbox-group") return 12;
		if (/*field*/ ctx[0].type === "radio-group") return 13;
		if (/*field*/ ctx[0].type === "full-name") return 14;
		return 15;
	}

	current_block_type_index = select_block_type(ctx, -1);
	if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			div1 = element("div");
			if (if_block0) if_block0.c();
			t = space();
			div0 = element("div");
			if_block1.c();
			attr(div0, "style", div0_style_value = /*styles*/ ctx[6]());
			attr(div1, "class", "svelte-gpg6ej");
			toggle_class(div1, "hidden", /*hidden*/ ctx[3]);
			toggle_class(div1, "wrapper", !/*field*/ ctx[0].configTarget && !/*editor*/ ctx[1] && /*field*/ ctx[0].type !== "placeholder");
			toggle_class(div1, "selected", /*field*/ ctx[0].selected);
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			if (if_block0) if_block0.m(div1, null);
			append(div1, t);
			append(div1, div0);
			if_blocks[current_block_type_index].m(div0, null);
			current = true;

			if (!mounted) {
				dispose = listen(div1, "click", stop_propagation(/*select*/ ctx[7]));
				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (/*field*/ ctx[0].selected) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_15(ctx);
					if_block0.c();
					if_block0.m(div1, t);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block1 = if_blocks[current_block_type_index];

				if (!if_block1) {
					if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block1.c();
				}

				transition_in(if_block1, 1);
				if_block1.m(div0, null);
			}

			if (dirty & /*hidden*/ 8) {
				toggle_class(div1, "hidden", /*hidden*/ ctx[3]);
			}

			if (dirty & /*field, editor*/ 3) {
				toggle_class(div1, "wrapper", !/*field*/ ctx[0].configTarget && !/*editor*/ ctx[1] && /*field*/ ctx[0].type !== "placeholder");
			}

			if (dirty & /*field*/ 1) {
				toggle_class(div1, "selected", /*field*/ ctx[0].selected);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block1);
			current = true;
		},
		o(local) {
			transition_out(if_block1);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div1);
			if (if_block0) if_block0.d();
			if_blocks[current_block_type_index].d();
			mounted = false;
			dispose();
		}
	};
}

let deleting = false;

function instance($$self, $$props, $$invalidate) {
	
	let { field } = $$props;
	let state = LoadState.NotStarted;
	let value;
	let lastValue;
	let { editor = false } = $$props;
	let { config = {} } = $$props;
	let { hidden = false } = $$props;
	let { padding = true } = $$props;
	onMount(load);

	function onClone() {
		dispatch("field_clone", { field });
	}

	function styles() {
		if (field.type === "placeholder") {
			return "";
		}

		if (padding && field.type === "address") {
			return `padding: .75em 0.6em; border-radius: 1em; padding-bottom: .1em;`;
		}

		if (padding) {
			return `padding: .75em 0.6em; border-radius: 1em;`;
		}

		if (field.customCss) {
			return ` ${field.customCss} padding-left: 0.6em;`;
		}

		return "";
	}

	function select() {
		if (field.configTarget || editor) {
			return;
		}

		$$invalidate(0, field.selected = !field.selected, field);

		formStore.set(field, {
			field: "selected",
			value: field.selected,
			fromUser: false
		});
	}

	async function load() {
		lastValue = field.value;

		if ((field.value ?? field.defaultValue) != null) {
			state = LoadState.Loading;

			try {
				const loader = new FieldValueLoader();
				const result = await loader.load(field);
				$$invalidate(4, value = result);
				$$invalidate(0, field.value = result, field);

				formStore.set(field, {
					value: result,
					field: "value",
					fromUser: false
				});

				state = LoadState.Finished;
			} catch(e) {
				console.error(e);
				state = LoadState.Failed;
			}
		}
	}

	const click_handler = () => dispatch("confirm_field_deletion", {});

	$$self.$$set = $$props => {
		if ("field" in $$props) $$invalidate(0, field = $$props.field);
		if ("editor" in $$props) $$invalidate(1, editor = $$props.editor);
		if ("config" in $$props) $$invalidate(2, config = $$props.config);
		if ("hidden" in $$props) $$invalidate(3, hidden = $$props.hidden);
		if ("padding" in $$props) $$invalidate(8, padding = $$props.padding);
	};

	return [
		field,
		editor,
		config,
		hidden,
		value,
		onClone,
		styles,
		select,
		padding,
		click_handler
	];
}

class Field extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance, create_fragment, safe_not_equal, {
			field: 0,
			editor: 1,
			config: 2,
			hidden: 3,
			padding: 8
		});
	}
}

export default Field;