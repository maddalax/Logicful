import { S as SvelteComponent, i as init, s as safe_not_equal, T as empty, h as insert, A as group_outros, u as transition_out, B as check_outros, r as transition_in, d as detach, o as onMount, e as element, c as claim_element, a as children, f as attr, n as noop, t as text, k as space, m as create_component, b as claim_text, l as claim_space, p as claim_component, g as set_style, j as append, q as mount_component, v as destroy_component, z as subscribe, w as goto, C as listen, y as set_data, N as update_keyed_each, O as outro_and_destroy_block, ac as Dialog, x as dispatch, P as tick, I as run_all, U as destroy_each, a3 as set_input_value, ae as dispatchSingle, L as add_render_callback, af as create_bidirectional_transition, Q as create_slot, G as stop_propagation, K as update_slot, F as bubble, Z as get_spread_update, _ as get_spread_object, a1 as assign } from './client.a93cf518.js';
import { f as formStore, s as subscribeFieldChange, i as debounce, h as firstNotEmpty } from './FileUpload.6e1eb6f3.js';
import { r as randomString, f as fastClone, d as randomStringSmall, i as isString, e as isEmptyOrNull } from './fuse.esm.4840cecb.js';
import { g as getApi, p as putApi, a as postApi, b as apiEndpoint } from './ApiService.7fbbc2d7.js';
import { L as LogicBuilder$1, s as slide } from './LogicBuilder.d2e791a5.js';
import { F as Field, a as FormEditSettings, b as saveToLocalStorage, s as saveForm } from './SaveForm.c378ae11.js';
import { g as getUrlParameter } from './Http.ea6dfc47.js';
import { T as ToastManager, R as RemoteTable } from './RemoteTable.a0e2c4e2.js';
import './Sidebar.87636085.js';

/* src\features\form\edit\GroupEditSidebar.svelte generated by Svelte v3.24.1 */

function create_else_block(ctx) {
	let div;

	return {
		c() {
			div = element("div");
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			children(div).forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "spinner");
		},
		m(target, anchor) {
			insert(target, div, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

// (26:0) {#if group}
function create_if_block(ctx) {
	let div0;
	let h5;
	let t0;
	let t1;
	let hr;
	let t2;
	let div1;
	let field;
	let current;

	field = new Field({
			props: {
				field: {
					id: randomString(),
					required: true,
					label: "Group Name",
					value: {
						type: "local",
						value: /*group*/ ctx[0].label
					},
					type: "string",
					configFieldTarget: `groups[${/*index*/ ctx[1]}].label`,
					configTarget: "form"
				}
			}
		});

	return {
		c() {
			div0 = element("div");
			h5 = element("h5");
			t0 = text("Group Settings");
			t1 = space();
			hr = element("hr");
			t2 = space();
			div1 = element("div");
			create_component(field.$$.fragment);
			this.h();
		},
		l(nodes) {
			div0 = claim_element(nodes, "DIV", { style: true });
			var div0_nodes = children(div0);
			h5 = claim_element(div0_nodes, "H5", { style: true });
			var h5_nodes = children(h5);
			t0 = claim_text(h5_nodes, "Group Settings");
			h5_nodes.forEach(detach);
			t1 = claim_space(div0_nodes);
			hr = claim_element(div0_nodes, "HR", {});
			div0_nodes.forEach(detach);
			t2 = claim_space(nodes);
			div1 = claim_element(nodes, "DIV", { style: true });
			var div1_nodes = children(div1);
			claim_component(field.$$.fragment, div1_nodes);
			div1_nodes.forEach(detach);
			this.h();
		},
		h() {
			set_style(h5, "padding-bottom", "0.2em");
			set_style(div0, "padding-left", "0.5em");
			set_style(div1, "padding", ".75em 0.6em");
		},
		m(target, anchor) {
			insert(target, div0, anchor);
			append(div0, h5);
			append(h5, t0);
			append(div0, t1);
			append(div0, hr);
			insert(target, t2, anchor);
			insert(target, div1, anchor);
			mount_component(field, div1, null);
			current = true;
		},
		p(ctx, dirty) {
			const field_changes = {};

			if (dirty & /*group, index*/ 3) field_changes.field = {
				id: randomString(),
				required: true,
				label: "Group Name",
				value: {
					type: "local",
					value: /*group*/ ctx[0].label
				},
				type: "string",
				configFieldTarget: `groups[${/*index*/ ctx[1]}].label`,
				configTarget: "form"
			};

			field.$set(field_changes);
		},
		i(local) {
			if (current) return;
			transition_in(field.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(field.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div0);
			if (detaching) detach(t2);
			if (detaching) detach(div1);
			destroy_component(field);
		}
	};
}

function create_fragment(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block, create_else_block];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*group*/ ctx[0]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		l(nodes) {
			if_block.l(nodes);
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	
	
	let { groupId } = $$props;
	let form;
	let group;
	let index;

	onMount(() => {
		var _a;
		form = formStore.getForm();
		let groups = (_a = form.groups) !== null && _a !== void 0 ? _a : [];

		$$invalidate(1, index = groups.findIndex(group => {
			return group.value === groupId;
		}));

		$$invalidate(0, group = groups[index]);
		console.log("index", index);
	});

	$$self.$$set = $$props => {
		if ("groupId" in $$props) $$invalidate(2, groupId = $$props.groupId);
	};

	return [group, index, groupId];
}

class GroupEditSidebar extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, { groupId: 2 });
	}
}

/* src\features\form\edit\FormEdit.svelte generated by Svelte v3.24.1 */

function create_else_block$1(ctx) {
	let div;

	return {
		c() {
			div = element("div");
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			children(div).forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "spinner");
		},
		m(target, anchor) {
			insert(target, div, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

// (26:0) {#if form}
function create_if_block$1(ctx) {
	let div0;
	let h5;
	let t0;
	let t1;
	let hr;
	let t2;
	let div2;
	let div1;
	let button;
	let span;
	let t3;
	let t4;
	let field;
	let t5;
	let formeditsettings;
	let current;
	let mounted;
	let dispose;

	field = new Field({
			props: {
				field: {
					id: randomString(),
					type: "switch",
					label: "Enable Logic For Preview",
					value: {
						type: "local",
						value: /*form*/ ctx[0].enableLogic ?? true
					},
					configFieldTarget: "enableLogic",
					configTarget: "form"
				}
			}
		});

	formeditsettings = new FormEditSettings({ props: { form: /*form*/ ctx[0] } });

	return {
		c() {
			div0 = element("div");
			h5 = element("h5");
			t0 = text("Form Settings");
			t1 = space();
			hr = element("hr");
			t2 = space();
			div2 = element("div");
			div1 = element("div");
			button = element("button");
			span = element("span");
			t3 = text("  Manage Workflows");
			t4 = space();
			create_component(field.$$.fragment);
			t5 = space();
			create_component(formeditsettings.$$.fragment);
			this.h();
		},
		l(nodes) {
			div0 = claim_element(nodes, "DIV", { style: true });
			var div0_nodes = children(div0);
			h5 = claim_element(div0_nodes, "H5", { style: true });
			var h5_nodes = children(h5);
			t0 = claim_text(h5_nodes, "Form Settings");
			h5_nodes.forEach(detach);
			t1 = claim_space(div0_nodes);
			hr = claim_element(div0_nodes, "HR", {});
			div0_nodes.forEach(detach);
			t2 = claim_space(nodes);
			div2 = claim_element(nodes, "DIV", { style: true });
			var div2_nodes = children(div2);
			div1 = claim_element(div2_nodes, "DIV", { class: true, style: true });
			var div1_nodes = children(div1);
			button = claim_element(div1_nodes, "BUTTON", { target: true, class: true });
			var button_nodes = children(button);
			span = claim_element(button_nodes, "SPAN", { class: true });
			children(span).forEach(detach);
			t3 = claim_text(button_nodes, "  Manage Workflows");
			button_nodes.forEach(detach);
			div1_nodes.forEach(detach);
			t4 = claim_space(div2_nodes);
			claim_component(field.$$.fragment, div2_nodes);
			t5 = claim_space(div2_nodes);
			claim_component(formeditsettings.$$.fragment, div2_nodes);
			div2_nodes.forEach(detach);
			this.h();
		},
		h() {
			set_style(h5, "padding-bottom", "0.2em");
			set_style(div0, "padding-left", "0.5em");
			attr(span, "class", "fas fa-cog");
			attr(button, "target", "_blank");
			attr(button, "class", "btn btn-sm btn-outline-dark");
			attr(div1, "class", "");
			set_style(div1, "padding", "0.75em 0.4em");
			set_style(div2, "padding-right", "1.5em");
		},
		m(target, anchor) {
			insert(target, div0, anchor);
			append(div0, h5);
			append(h5, t0);
			append(div0, t1);
			append(div0, hr);
			insert(target, t2, anchor);
			insert(target, div2, anchor);
			append(div2, div1);
			append(div1, button);
			append(button, span);
			append(button, t3);
			append(div2, t4);
			mount_component(field, div2, null);
			append(div2, t5);
			mount_component(formeditsettings, div2, null);
			current = true;

			if (!mounted) {
				dispose = listen(button, "click", /*onWorkflows*/ ctx[1]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			const field_changes = {};

			if (dirty & /*form*/ 1) field_changes.field = {
				id: randomString(),
				type: "switch",
				label: "Enable Logic For Preview",
				value: {
					type: "local",
					value: /*form*/ ctx[0].enableLogic ?? true
				},
				configFieldTarget: "enableLogic",
				configTarget: "form"
			};

			field.$set(field_changes);
			const formeditsettings_changes = {};
			if (dirty & /*form*/ 1) formeditsettings_changes.form = /*form*/ ctx[0];
			formeditsettings.$set(formeditsettings_changes);
		},
		i(local) {
			if (current) return;
			transition_in(field.$$.fragment, local);
			transition_in(formeditsettings.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(field.$$.fragment, local);
			transition_out(formeditsettings.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div0);
			if (detaching) detach(t2);
			if (detaching) detach(div2);
			destroy_component(field);
			destroy_component(formeditsettings);
			mounted = false;
			dispose();
		}
	};
}

function create_fragment$1(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$1, create_else_block$1];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*form*/ ctx[0]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		l(nodes) {
			if_block.l(nodes);
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function instance$1($$self, $$props, $$invalidate) {
	
	let form;

	onMount(() => {
		$$invalidate(0, form = formStore.getForm());
		console.log(form);

		subscribe("form_updated", props => {
			$$invalidate(0, form = props);
		});
	});

	function onWorkflows() {
		goto(`./form-settings/${form.id}/workflows`);
	}

	return [form, onWorkflows];
}

class FormEdit extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$1, create_fragment$1, safe_not_equal, {});
	}
}

var DynamicFormMode;
(function (DynamicFormMode) {
    DynamicFormMode[DynamicFormMode["Preview"] = 0] = "Preview";
    DynamicFormMode[DynamicFormMode["Live"] = 1] = "Live";
})(DynamicFormMode || (DynamicFormMode = {}));

/* src\features\form\edit\DynamicForm.svelte generated by Svelte v3.24.1 */

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[9] = list[i];
	return child_ctx;
}

// (82:0) {#if deleting}
function create_if_block_1(ctx) {
	let dialog;
	let current;

	dialog = new Dialog({
			props: {
				title: "Confirm Deletion",
				isOpen: true,
				actions: [
					{
						label: `Delete Field`,
						type: "danger",
						onClick: /*onDelete*/ ctx[3],
						focus: true
					},
					{ label: "Cancel", type: "secondary" }
				],
				onClose: /*func*/ ctx[5],
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(dialog.$$.fragment);
		},
		l(nodes) {
			claim_component(dialog.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(dialog, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const dialog_changes = {};
			if (dirty & /*deleting*/ 2) dialog_changes.onClose = /*func*/ ctx[5];

			if (dirty & /*$$scope*/ 4096) {
				dialog_changes.$$scope = { dirty, ctx };
			}

			dialog.$set(dialog_changes);
		},
		i(local) {
			if (current) return;
			transition_in(dialog.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(dialog.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(dialog, detaching);
		}
	};
}

// (83:2) <Dialog      title={'Confirm Deletion'}      isOpen={true}      actions={[{ label: `Delete Field`, type: 'danger', onClick: onDelete, focus: true }, { label: 'Cancel', type: 'secondary' }]}      onClose={() => {        deleting = false      }}>
function create_default_slot(ctx) {
	let p0;
	let t0;
	let t1;
	let p1;
	let t2;

	return {
		c() {
			p0 = element("p");
			t0 = text("Are you sure you want to delete this field? Deletion is permanent and cannot be reversed.");
			t1 = space();
			p1 = element("p");
			t2 = text("Changes will be applied after the form is saved.");
		},
		l(nodes) {
			p0 = claim_element(nodes, "P", {});
			var p0_nodes = children(p0);
			t0 = claim_text(p0_nodes, "Are you sure you want to delete this field? Deletion is permanent and cannot be reversed.");
			p0_nodes.forEach(detach);
			t1 = claim_space(nodes);
			p1 = claim_element(nodes, "P", {});
			var p1_nodes = children(p1);
			t2 = claim_text(p1_nodes, "Changes will be applied after the form is saved.");
			p1_nodes.forEach(detach);
		},
		m(target, anchor) {
			insert(target, p0, anchor);
			append(p0, t0);
			insert(target, t1, anchor);
			insert(target, p1, anchor);
			append(p1, t2);
		},
		d(detaching) {
			if (detaching) detach(p0);
			if (detaching) detach(t1);
			if (detaching) detach(p1);
		}
	};
}

// (109:6) {:else}
function create_else_block$2(ctx) {
	let div;
	let field;
	let t;
	let div_id_value;
	let current;

	field = new Field({
			props: {
				field: fastClone(/*field*/ ctx[9]),
				hidden: true
			}
		});

	return {
		c() {
			div = element("div");
			create_component(field.$$.fragment);
			t = space();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { id: true });
			var div_nodes = children(div);
			claim_component(field.$$.fragment, div_nodes);
			t = claim_space(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "id", div_id_value = `form-field-${/*field*/ ctx[9].id}`);
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(field, div, null);
			append(div, t);
			current = true;
		},
		p(ctx, dirty) {
			const field_changes = {};
			if (dirty & /*form*/ 1) field_changes.field = fastClone(/*field*/ ctx[9]);
			field.$set(field_changes);

			if (!current || dirty & /*form*/ 1 && div_id_value !== (div_id_value = `form-field-${/*field*/ ctx[9].id}`)) {
				attr(div, "id", div_id_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in(field.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(field.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(field);
		}
	};
}

// (105:6) {#if display(field)}
function create_if_block$2(ctx) {
	let div;
	let field;
	let t;
	let div_id_value;
	let current;

	field = new Field({
			props: { field: fastClone(/*field*/ ctx[9]) }
		});

	return {
		c() {
			div = element("div");
			create_component(field.$$.fragment);
			t = space();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { id: true });
			var div_nodes = children(div);
			claim_component(field.$$.fragment, div_nodes);
			t = claim_space(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "id", div_id_value = `form-field-${/*field*/ ctx[9].id}`);
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(field, div, null);
			append(div, t);
			current = true;
		},
		p(ctx, dirty) {
			const field_changes = {};
			if (dirty & /*form*/ 1) field_changes.field = fastClone(/*field*/ ctx[9]);
			field.$set(field_changes);

			if (!current || dirty & /*form*/ 1 && div_id_value !== (div_id_value = `form-field-${/*field*/ ctx[9].id}`)) {
				attr(div, "id", div_id_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in(field.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(field.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(field);
		}
	};
}

// (104:4) {#each form.fields as field (field.id)}
function create_each_block(key_1, ctx) {
	let first;
	let show_if;
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$2, create_else_block$2];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (dirty & /*form*/ 1) show_if = !!/*display*/ ctx[2](/*field*/ ctx[9]);
		if (show_if) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx, -1);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		key: key_1,
		first: null,
		c() {
			first = empty();
			if_block.c();
			if_block_anchor = empty();
			this.h();
		},
		l(nodes) {
			first = empty();
			if_block.l(nodes);
			if_block_anchor = empty();
			this.h();
		},
		h() {
			this.first = first;
		},
		m(target, anchor) {
			insert(target, first, anchor);
			if_blocks[current_block_type_index].m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(first);
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function create_fragment$2(ctx) {
	let t0;
	let div2;
	let div0;
	let h4;
	let t1_value = (/*form*/ ctx[0].title || "Form Title") + "";
	let t1;
	let t2;
	let small;
	let t3_value = (/*form*/ ctx[0].description ?? "") + "";
	let t3;
	let t4;
	let div1;
	let a;
	let t5;
	let a_href_value;
	let t6;
	let hr;
	let t7;
	let form_1;
	let div3;
	let each_blocks = [];
	let each_1_lookup = new Map();
	let t8;
	let button;
	let t9;
	let current;
	let if_block = /*deleting*/ ctx[1] && create_if_block_1(ctx);
	let each_value = /*form*/ ctx[0].fields;
	const get_key = ctx => /*field*/ ctx[9].id;

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context(ctx, each_value, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
	}

	return {
		c() {
			if (if_block) if_block.c();
			t0 = space();
			div2 = element("div");
			div0 = element("div");
			h4 = element("h4");
			t1 = text(t1_value);
			t2 = space();
			small = element("small");
			t3 = text(t3_value);
			t4 = space();
			div1 = element("div");
			a = element("a");
			t5 = text("Preview Form");
			t6 = space();
			hr = element("hr");
			t7 = space();
			form_1 = element("form");
			div3 = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t8 = space();
			button = element("button");
			t9 = text("Submit");
			this.h();
		},
		l(nodes) {
			if (if_block) if_block.l(nodes);
			t0 = claim_space(nodes);
			div2 = claim_element(nodes, "DIV", { class: true, style: true });
			var div2_nodes = children(div2);
			div0 = claim_element(div2_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			h4 = claim_element(div0_nodes, "H4", {});
			var h4_nodes = children(h4);
			t1 = claim_text(h4_nodes, t1_value);
			h4_nodes.forEach(detach);
			t2 = claim_space(div0_nodes);
			small = claim_element(div0_nodes, "SMALL", { class: true });
			var small_nodes = children(small);
			t3 = claim_text(small_nodes, t3_value);
			small_nodes.forEach(detach);
			div0_nodes.forEach(detach);
			t4 = claim_space(div2_nodes);
			div1 = claim_element(div2_nodes, "DIV", { class: true, style: true });
			var div1_nodes = children(div1);
			a = claim_element(div1_nodes, "A", { href: true, target: true, class: true });
			var a_nodes = children(a);
			t5 = claim_text(a_nodes, "Preview Form");
			a_nodes.forEach(detach);
			div1_nodes.forEach(detach);
			div2_nodes.forEach(detach);
			t6 = claim_space(nodes);
			hr = claim_element(nodes, "HR", { style: true });
			t7 = claim_space(nodes);
			form_1 = claim_element(nodes, "FORM", { class: true, id: true });
			var form_1_nodes = children(form_1);
			div3 = claim_element(form_1_nodes, "DIV", { style: true, id: true });
			var div3_nodes = children(div3);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(div3_nodes);
			}

			div3_nodes.forEach(detach);
			t8 = claim_space(form_1_nodes);
			button = claim_element(form_1_nodes, "BUTTON", { style: true, class: true, type: true });
			var button_nodes = children(button);
			t9 = claim_text(button_nodes, "Submit");
			button_nodes.forEach(detach);
			form_1_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(small, "class", "text-gray-700");
			attr(div0, "class", "col");
			attr(a, "href", a_href_value = `/preview?formId=${/*form*/ ctx[0].id}`);
			attr(a, "target", "_blank");
			attr(a, "class", "btn btn-xs btn-outline-dark");
			attr(div1, "class", "col-auto");
			set_style(div1, "text-align", "right");
			attr(div2, "class", "row");
			set_style(div2, "padding-left", "0.5em");
			set_style(div2, "display", "flex");
			set_style(hr, "margin-top", "0.5rem");
			set_style(hr, "margin-bottom", "0.7rem");
			set_style(div3, "padding-bottom", "1em");
			attr(div3, "id", "form-preview-fields");
			set_style(button, "margin-left", "0.5em");
			attr(button, "class", "btn btn-primary");
			attr(button, "type", "submit");
			attr(form_1, "class", "preview-padding");
			attr(form_1, "id", "form-preview");
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, t0, anchor);
			insert(target, div2, anchor);
			append(div2, div0);
			append(div0, h4);
			append(h4, t1);
			append(div0, t2);
			append(div0, small);
			append(small, t3);
			append(div2, t4);
			append(div2, div1);
			append(div1, a);
			append(a, t5);
			insert(target, t6, anchor);
			insert(target, hr, anchor);
			insert(target, t7, anchor);
			insert(target, form_1, anchor);
			append(form_1, div3);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div3, null);
			}

			append(form_1, t8);
			append(form_1, button);
			append(button, t9);
			current = true;
		},
		p(ctx, [dirty]) {
			if (/*deleting*/ ctx[1]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*deleting*/ 2) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_1(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(t0.parentNode, t0);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			if ((!current || dirty & /*form*/ 1) && t1_value !== (t1_value = (/*form*/ ctx[0].title || "Form Title") + "")) set_data(t1, t1_value);
			if ((!current || dirty & /*form*/ 1) && t3_value !== (t3_value = (/*form*/ ctx[0].description ?? "") + "")) set_data(t3, t3_value);

			if (!current || dirty & /*form*/ 1 && a_href_value !== (a_href_value = `/preview?formId=${/*form*/ ctx[0].id}`)) {
				attr(a, "href", a_href_value);
			}

			if (dirty & /*form, fastClone, display*/ 5) {
				const each_value = /*form*/ ctx[0].fields;
				group_outros();
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, div3, outro_and_destroy_block, create_each_block, null, get_each_context);
				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			transition_out(if_block);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach(t0);
			if (detaching) detach(div2);
			if (detaching) detach(t6);
			if (detaching) detach(hr);
			if (detaching) detach(t7);
			if (detaching) detach(form_1);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}
		}
	};
}

function instance$2($$self, $$props, $$invalidate) {
	
	
	let { form } = $$props;
	let { mode = DynamicFormMode.Live } = $$props;
	let hasPlaceholder = false;
	let deleting = false;

	onMount(() => {
		subscribe("confirm_field_deletion", () => {
			$$invalidate(1, deleting = true);
		});

		subscribe("form_placeholder_changed", props => {
			hasPlaceholder = props.added;
		});
	});

	subscribeFieldChange(updatedField => {
		if (!form || !form.fields) {
			return;
		}

		const index = form.fields.findIndex(w => w.id === updatedField.id);

		if (index === -1) {
			return;
		}

		$$invalidate(0, form.fields[index].updated = !form.fields[index].updated, form);

		const fieldsWithRules = form.fields.filter(w => {
			if (!w.logic || !w.logic.rules) {
				return false;
			}

			const hasRule = w.logic.rules.find(rule => rule.field === updatedField.id);
			return hasRule != null;
		});

		for (let fieldWithRule of fieldsWithRules) {
			let ruleIndex = form.fields.findIndex(w => w.id === fieldWithRule.id);
			$$invalidate(0, form.fields[ruleIndex].updated = !form.fields[ruleIndex].updated, form);
		}
	});

	function display(field) {
		if (!form.enableLogic) {
			return true;
		}

		if (!field.logic) {
			return true;
		}

		const builder = new LogicBuilder$1();
		return builder.evaluate(field);
	}

	function onDelete() {
		const selected = form.fields.find(w => w.selected);

		if (selected) {
			dispatch("field_delete", { field: selected });
		}
	}

	const func = () => {
		$$invalidate(1, deleting = false);
	};

	$$self.$$set = $$props => {
		if ("form" in $$props) $$invalidate(0, form = $$props.form);
		if ("mode" in $$props) $$invalidate(4, mode = $$props.mode);
	};

	return [form, deleting, display, onDelete, mode, func];
}

class DynamicForm extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$2, create_fragment$2, safe_not_equal, { form: 0, mode: 4 });
	}
}

const debounceSave = debounce(() => {
    const form = formStore.getForm();
    saveToLocalStorage(form);
}, 500);
function startPreviewSaver() {
    subscribeFieldChange(() => {
        debounceSave();
    });
    subscribe("form_updated", () => {
        debounceSave();
    });
}

function setFieldDefaults(field) {
    if (field.type === 'checkbox-group') {
        field.value = { "Option 1": "Option 1" };
        field.options = ["Option 1", "Option 2"];
    }
    if (field.type === 'radio-group') {
        field.value = { "Option 1": "Option 1" };
        field.options = ["Option 1", "Option 2"];
    }
    return field;
}

/* src\features\form\edit\FormBuilder.svelte generated by Svelte v3.24.1 */

function create_else_block$3(ctx) {
	let div1;
	let div0;
	let current_block_type_index;
	let if_block;
	let current;
	const if_block_creators = [create_if_block_1$1, create_else_block_1];
	const if_blocks = [];

	function select_block_type_1(ctx, dirty) {
		if (/*dragForm*/ ctx[1]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_1(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			div1 = element("div");
			div0 = element("div");
			if_block.c();
			this.h();
		},
		l(nodes) {
			div1 = claim_element(nodes, "DIV", { class: true, style: true });
			var div1_nodes = children(div1);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			if_block.l(div0_nodes);
			div0_nodes.forEach(detach);
			div1_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div0, "class", "row");
			attr(div1, "class", "container");
			set_style(div1, "padding-left", "0.4em");
			set_style(div1, "padding-top", "0.5em");
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			append(div1, div0);
			if_blocks[current_block_type_index].m(div0, null);
			current = true;
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_1(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(div0, null);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div1);
			if_blocks[current_block_type_index].d();
		}
	};
}

// (242:2) {#if form == null || loadingActive}
function create_if_block$3(ctx) {
	let div2;
	let div1;
	let div0;
	let span;
	let t;

	return {
		c() {
			div2 = element("div");
			div1 = element("div");
			div0 = element("div");
			span = element("span");
			t = text("Loading...");
			this.h();
		},
		l(nodes) {
			div2 = claim_element(nodes, "DIV", { class: true });
			var div2_nodes = children(div2);
			div1 = claim_element(div2_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			div0 = claim_element(div1_nodes, "DIV", { class: true, style: true, role: true });
			var div0_nodes = children(div0);
			span = claim_element(div0_nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t = claim_text(span_nodes, "Loading...");
			span_nodes.forEach(detach);
			div0_nodes.forEach(detach);
			div1_nodes.forEach(detach);
			div2_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(span, "class", "sr-only");
			attr(div0, "class", "spinner-border");
			set_style(div0, "width", "3rem");
			set_style(div0, "height", "3rem");
			set_style(div0, "margin-top", "2em");
			attr(div0, "role", "status");
			attr(div1, "class", "d-flex justify-content-center");
			attr(div2, "class", "flex-column justify-content-center align-items-center");
		},
		m(target, anchor) {
			insert(target, div2, anchor);
			append(div2, div1);
			append(div1, div0);
			append(div0, span);
			append(span, t);
		},
		p: noop,
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div2);
		}
	};
}

// (257:8) {:else}
function create_else_block_1(ctx) {
	let div;
	let dynamicform;
	let div_class_value;
	let current;

	dynamicform = new DynamicForm({
			props: {
				form: /*form*/ ctx[2],
				mode: DynamicFormMode.Preview
			}
		});

	return {
		c() {
			div = element("div");
			create_component(dynamicform.$$.fragment);
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			claim_component(dynamicform.$$.fragment, div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", div_class_value = "col-md no-gutters max-width");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(dynamicform, div, null);
			current = true;
		},
		p(ctx, dirty) {
			const dynamicform_changes = {};
			if (dirty & /*form*/ 4) dynamicform_changes.form = /*form*/ ctx[2];
			dynamicform.$set(dynamicform_changes);
		},
		i(local) {
			if (current) return;
			transition_in(dynamicform.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(dynamicform.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(dynamicform);
		}
	};
}

// (253:8) {#if dragForm}
function create_if_block_1$1(ctx) {
	let div;
	let dynamicform;
	let div_class_value;
	let current;

	dynamicform = new DynamicForm({
			props: {
				form: /*dragForm*/ ctx[1],
				mode: DynamicFormMode.Preview
			}
		});

	return {
		c() {
			div = element("div");
			create_component(dynamicform.$$.fragment);
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			claim_component(dynamicform.$$.fragment, div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", div_class_value = "col-md no-gutters max-width");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(dynamicform, div, null);
			current = true;
		},
		p(ctx, dirty) {
			const dynamicform_changes = {};
			if (dirty & /*dragForm*/ 2) dynamicform_changes.form = /*dragForm*/ ctx[1];
			dynamicform.$set(dynamicform_changes);
		},
		i(local) {
			if (current) return;
			transition_in(dynamicform.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(dynamicform.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(dynamicform);
		}
	};
}

function create_fragment$3(ctx) {
	let div;
	let toastmanager;
	let t;
	let current_block_type_index;
	let if_block;
	let current;
	toastmanager = new ToastManager({});
	const if_block_creators = [create_if_block$3, create_else_block$3];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*form*/ ctx[2] == null || /*loadingActive*/ ctx[0]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			div = element("div");
			create_component(toastmanager.$$.fragment);
			t = space();
			if_block.c();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", {});
			var div_nodes = children(div);
			claim_component(toastmanager.$$.fragment, div_nodes);
			t = claim_space(div_nodes);
			if_block.l(div_nodes);
			div_nodes.forEach(detach);
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(toastmanager, div, null);
			append(div, t);
			if_blocks[current_block_type_index].m(div, null);
			current = true;
		},
		p(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(div, null);
			}
		},
		i(local) {
			if (current) return;
			transition_in(toastmanager.$$.fragment, local);
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(toastmanager.$$.fragment, local);
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(toastmanager);
			if_blocks[current_block_type_index].d();
		}
	};
}

function instance$3($$self, $$props, $$invalidate) {
	var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
		function adopt(value) {
			return value instanceof P
			? value
			: new P(function (resolve) {
						resolve(value);
					});
		}

		return new (P || (P = Promise))(function (resolve, reject) {
				function fulfilled(value) {
					try {
						step(generator.next(value));
					} catch(e) {
						reject(e);
					}
				}

				function rejected(value) {
					try {
						step(generator["throw"](value));
					} catch(e) {
						reject(e);
					}
				}

				function step(result) {
					result.done
					? resolve(result.value)
					: adopt(result.value).then(fulfilled, rejected);
				}

				step((generator = generator.apply(thisArg, _arguments || [])).next());
			});
	};

	
	
	let loadingActive = false;
	let dragForm;
	let form;

	function loadForm() {
		var _a;

		return __awaiter(this, void 0, void 0, function* () {
			$$invalidate(0, loadingActive = true);

			const formId = (_a = getUrlParameter("formId")) !== null && _a !== void 0
			? _a
			: "new";

			try {
				if (formId === "new") {
					$$invalidate(2, form = { fields: [], title: "My New Form" });
				} else {
					$$invalidate(2, form = yield getApi(`form/${formId}`));
				}

				if (!form) {
					return;
				}

				if (!form.fields) {
					$$invalidate(2, form.fields = [], form);
				}

				$$invalidate(
					2,
					form.fields = form.fields.map(w => {
						w.selected = false;
						return w;
					}),
					form
				);

				// todo remove this, just for testing
				$$invalidate(
					2,
					form.groups = [
						{ value: "123", label: "Personal Details" },
						{
							value: "456",
							label: "Experience Questions"
						}
					],
					form
				);

				addPlaceHolder();
				formStore.setForm(form);
				dispatch("form_loaded", { form });
				startPreviewSaver();
			} finally {
				$$invalidate(0, loadingActive = false);
			}
		});
	}

	function removePlaceHolder() {
		const placeholder = form.fields.findIndex(w => w.type === "placeholder");

		if (placeholder !== -1) {
			const temp = fastClone(form.fields);
			temp.splice(placeholder, 1);
			$$invalidate(2, form.fields = temp, form);
			dispatch("form_placeholder_changed", { added: false });
		}
	}

	function addPlaceHolder() {
		if (form.fields.filter(w => w.type !== "placeholder").length !== 0) {
			removePlaceHolder();
			return;
		}

		if (form.fields.find(w => w.type === "placeholder")) {
			return;
		}

		$$invalidate(
			2,
			form.fields = form.fields.concat([
				{
					name: "placeholder-field",
					label: "You have no fields",
					type: "placeholder",
					id: "placeholder"
				}
			]),
			form
		);

		dispatch("form_placeholder_changed", { added: true });
	}

	onMount(() => __awaiter(void 0, void 0, void 0, function* () {
		subscribe("form_updated", props => {
			$$invalidate(2, form = props);
			addPlaceHolder();
		});

		subscribe("field_delete", params => {
			const index = form.fields.findIndex(w => w.id === params.field.id);
			const temp = [...form.fields];
			temp.splice(index, 1);
			$$invalidate(2, form.fields = temp, form);
			formStore.setForm(form);
		});

		subscribe("right_sidebar_loaded", () => {
			form && dispatch("form_loaded", { form });
		});

		subscribe("add_field", params => {
			$$invalidate(
				2,
				form.fields = form.fields.map(w => {
					w.selected = false;
					return w;
				}),
				form
			);

			const id = randomString();

			let field = {
				name: "new-field-" + randomStringSmall(),
				label: "New Field " + randomStringSmall(),
				type: params.type,
				id,
				selected: true,
				value: undefined,
				expanded: true
			};

			field = setFieldDefaults(field);
			$$invalidate(2, form.fields = form.fields.concat(field), form);
			removePlaceHolder();
			formStore.setForm(form);
		});

		subscribe("field_clone", params => {
			const index = form.fields.findIndex(w => w.id === params.field.id);
			const copy = fastClone(form.fields[index]);
			copy.name = copy.name + "-" + randomStringSmall();
			copy.label = copy.label + " Copy";
			copy.id = randomString();
			copy.selected = true;
			const temp = fastClone(form.fields);
			temp.splice(index + 1, 0, copy);
			$$invalidate(2, form.fields = temp, form);
			formStore.set(copy);
		});

		subscribe("save_form", params => __awaiter(void 0, void 0, void 0, function* () {
			yield saveForm();
		}));

		subscribe("get_form_fields", () => {
			return form.fields;
		});

		subscribe("drag_over", () => {
			removePlaceHolder();
		});

		subscribe("drag_finished", elements => __awaiter(void 0, void 0, void 0, function* () {
			removePlaceHolder();
			console.log(elements);

			let fields = elements.filter(w => w).map(e => {
				if (e.id === "form-field-placeholder") {
					return undefined;
				}

				if (e.id.startsWith("form-field-")) {
					const field = form.fields.find(w => w.id === e.id.replace("form-field-", ""));

					if (field) {
						field.selected = false;
					}

					return field;
				}

				if (e.id.startsWith("sidebar-block-")) {
					const type = e.id.replace("sidebar-block-", "");

					let field = {
						id: randomString(),
						type,
						name: "new-field-" + randomStringSmall(),
						label: "New Field " + randomStringSmall(),
						selected: true,
						value: undefined
					};

					field = setFieldDefaults(field);
					return field;
				}
			});

			fields = fields.filter(w => w != null);
			$$invalidate(2, form.fields = fastClone(fields), form);
			$$invalidate(1, dragForm = fastClone(form));
			yield tick();
			$$invalidate(1, dragForm = undefined);

			if (form.fields.length === 0) {
				addPlaceHolder();
			}

			formStore.setForm(form);
		}));

		subscribeFieldChange(newField => {
			if (!newField.selected) {
				return;
			}

			$$invalidate(
				2,
				form.fields = form.fields.map(f => {
					if (f.id !== newField.id && f.selected) {
						f.selected = false;
						formStore.set(f);
					}

					return f;
				}),
				form
			);
		});

		subscribe("form_updated", params => {
			$$invalidate(2, form = params);
		});

		subscribe("document_click", () => {
			$$invalidate(
				2,
				form.fields = form.fields.map(f => {
					if (f.selected) {
						f.selected = false;
						formStore.set(f);
					}

					return f;
				}),
				form
			);
		});

		subscribeFieldChange(field => __awaiter(void 0, void 0, void 0, function* () {
			if (!form || !form.fields) {
				return;
			}

			const index = form.fields.findIndex(w => w.id === field.id);

			if (index !== -1) {
				$$invalidate(2, form.fields[index] = field, form);
			}
		}));

		loadForm();
	}));

	return [loadingActive, dragForm, form];
}

class FormBuilder extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$3, create_fragment$3, safe_not_equal, {});
	}
}

/* src\components\Repeater.svelte generated by Svelte v3.24.1 */

function get_each_context$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[15] = list[i];
	child_ctx[16] = list;
	child_ctx[17] = i;
	return child_ctx;
}

// (57:6) {:else}
function create_else_block$4(ctx) {
	let div0;
	let input0;
	let input0_placeholder_value;
	let t;
	let div1;
	let input1;
	let input1_placeholder_value;
	let mounted;
	let dispose;

	function input0_input_handler() {
		/*input0_input_handler*/ ctx[11].call(input0, /*each_value*/ ctx[16], /*i*/ ctx[17]);
	}

	function input1_input_handler() {
		/*input1_input_handler*/ ctx[13].call(input1, /*each_value*/ ctx[16], /*i*/ ctx[17]);
	}

	return {
		c() {
			div0 = element("div");
			input0 = element("input");
			t = space();
			div1 = element("div");
			input1 = element("input");
			this.h();
		},
		l(nodes) {
			div0 = claim_element(nodes, "DIV", { class: true, style: true });
			var div0_nodes = children(div0);

			input0 = claim_element(div0_nodes, "INPUT", {
				class: true,
				name: true,
				type: true,
				placeholder: true
			});

			div0_nodes.forEach(detach);
			t = claim_space(nodes);
			div1 = claim_element(nodes, "DIV", { class: true, style: true });
			var div1_nodes = children(div1);

			input1 = claim_element(div1_nodes, "INPUT", {
				class: true,
				name: true,
				type: true,
				placeholder: true
			});

			div1_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(input0, "class", "form-control");
			attr(input0, "name", "display");
			attr(input0, "type", "text");
			attr(input0, "placeholder", input0_placeholder_value = "Display");
			attr(div0, "class", "p-1 bd-highlight");
			set_style(div0, "width", "100%");
			attr(input1, "class", "form-control");
			attr(input1, "name", "value");
			attr(input1, "type", "text");
			attr(input1, "placeholder", input1_placeholder_value = "Value");
			attr(div1, "class", "p-1 bd-highlight");
			set_style(div1, "width", "100%");
		},
		m(target, anchor) {
			insert(target, div0, anchor);
			append(div0, input0);
			set_input_value(input0, /*option*/ ctx[15].label);
			insert(target, t, anchor);
			insert(target, div1, anchor);
			append(div1, input1);
			set_input_value(input1, /*option*/ ctx[15].value);

			if (!mounted) {
				dispose = [
					listen(input0, "blur", /*blur_handler_1*/ ctx[10]),
					listen(input0, "input", input0_input_handler),
					listen(input1, "blur", /*blur_handler_2*/ ctx[12]),
					listen(input1, "input", input1_input_handler)
				];

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty & /*options*/ 1 && input0.value !== /*option*/ ctx[15].label) {
				set_input_value(input0, /*option*/ ctx[15].label);
			}

			if (dirty & /*options*/ 1 && input1.value !== /*option*/ ctx[15].value) {
				set_input_value(input1, /*option*/ ctx[15].value);
			}
		},
		d(detaching) {
			if (detaching) detach(div0);
			if (detaching) detach(t);
			if (detaching) detach(div1);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (53:6) {#if onlyLabel}
function create_if_block_1$2(ctx) {
	let div;
	let input;
	let input_placeholder_value;
	let mounted;
	let dispose;

	function input_input_handler() {
		/*input_input_handler*/ ctx[9].call(input, /*each_value*/ ctx[16], /*i*/ ctx[17]);
	}

	return {
		c() {
			div = element("div");
			input = element("input");
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true, style: true });
			var div_nodes = children(div);

			input = claim_element(div_nodes, "INPUT", {
				class: true,
				name: true,
				type: true,
				placeholder: true
			});

			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(input, "class", "form-control");
			attr(input, "name", "display");
			attr(input, "type", "text");
			attr(input, "placeholder", input_placeholder_value = "Option");
			attr(div, "class", "p-1 bd-highlight");
			set_style(div, "width", "100%");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, input);
			set_input_value(input, /*option*/ ctx[15].label);

			if (!mounted) {
				dispose = [
					listen(input, "blur", /*blur_handler*/ ctx[8]),
					listen(input, "input", input_input_handler)
				];

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty & /*options*/ 1 && input.value !== /*option*/ ctx[15].label) {
				set_input_value(input, /*option*/ ctx[15].label);
			}
		},
		d(detaching) {
			if (detaching) detach(div);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (51:2) {#each options as option, i}
function create_each_block$1(ctx) {
	let div2;
	let t0;
	let div0;
	let span1;
	let span0;
	let t1;
	let div1;
	let span3;
	let span2;
	let mounted;
	let dispose;

	function select_block_type(ctx, dirty) {
		if (/*onlyLabel*/ ctx[2]) return create_if_block_1$2;
		return create_else_block$4;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type(ctx);

	function click_handler(...args) {
		return /*click_handler*/ ctx[14](/*i*/ ctx[17], ...args);
	}

	return {
		c() {
			div2 = element("div");
			if_block.c();
			t0 = space();
			div0 = element("div");
			span1 = element("span");
			span0 = element("span");
			t1 = space();
			div1 = element("div");
			span3 = element("span");
			span2 = element("span");
			this.h();
		},
		l(nodes) {
			div2 = claim_element(nodes, "DIV", { class: true });
			var div2_nodes = children(div2);
			if_block.l(div2_nodes);
			t0 = claim_space(div2_nodes);
			div0 = claim_element(div2_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			span1 = claim_element(div0_nodes, "SPAN", { class: true });
			var span1_nodes = children(span1);
			span0 = claim_element(span1_nodes, "SPAN", { class: true });
			children(span0).forEach(detach);
			span1_nodes.forEach(detach);
			div0_nodes.forEach(detach);
			t1 = claim_space(div2_nodes);
			div1 = claim_element(div2_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			span3 = claim_element(div1_nodes, "SPAN", { class: true });
			var span3_nodes = children(span3);
			span2 = claim_element(span3_nodes, "SPAN", { class: true });
			children(span2).forEach(detach);
			span3_nodes.forEach(detach);
			div1_nodes.forEach(detach);
			div2_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(span0, "class", "fas fa-plus svelte-105i2dl");
			attr(span1, "class", "icon baseline");
			attr(div0, "class", "bd-highlight");
			attr(span2, "class", "fas fa-trash svelte-105i2dl");
			attr(span3, "class", "icon baseline");
			attr(div1, "class", "bd-highlight");
			attr(div2, "class", "d-flex flex-row bd-highlight justify-end");
		},
		m(target, anchor) {
			insert(target, div2, anchor);
			if_block.m(div2, null);
			append(div2, t0);
			append(div2, div0);
			append(div0, span1);
			append(span1, span0);
			append(div2, t1);
			append(div2, div1);
			append(div1, span3);
			append(span3, span2);

			if (!mounted) {
				dispose = [
					listen(span1, "click", /*addNew*/ ctx[6]),
					listen(span3, "click", click_handler)
				];

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(div2, t0);
				}
			}
		},
		d(detaching) {
			if (detaching) detach(div2);
			if_block.d();
			mounted = false;
			run_all(dispose);
		}
	};
}

// (69:2) {#if helperText}
function create_if_block$4(ctx) {
	let div;
	let raw_value = (/*helperText*/ ctx[1] ?? "") + "";

	return {
		c() {
			div = element("div");
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "helper-text");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			div.innerHTML = raw_value;
		},
		p(ctx, dirty) {
			if (dirty & /*helperText*/ 2 && raw_value !== (raw_value = (/*helperText*/ ctx[1] ?? "") + "")) div.innerHTML = raw_value;		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

function create_fragment$4(ctx) {
	let div;
	let label_1;
	let t0;
	let t1;
	let t2;
	let each_value = /*options*/ ctx[0];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
	}

	let if_block = /*helperText*/ ctx[1] && create_if_block$4(ctx);

	return {
		c() {
			div = element("div");
			label_1 = element("label");
			t0 = text(/*label*/ ctx[3]);
			t1 = space();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t2 = space();
			if (if_block) if_block.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", {});
			var div_nodes = children(div);
			label_1 = claim_element(div_nodes, "LABEL", { style: true });
			var label_1_nodes = children(label_1);
			t0 = claim_text(label_1_nodes, /*label*/ ctx[3]);
			label_1_nodes.forEach(detach);
			t1 = claim_space(div_nodes);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(div_nodes);
			}

			t2 = claim_space(div_nodes);
			if (if_block) if_block.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			set_style(label_1, "margin-left", ".5em");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, label_1);
			append(label_1, t0);
			append(div, t1);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}

			append(div, t2);
			if (if_block) if_block.m(div, null);
		},
		p(ctx, [dirty]) {
			if (dirty & /*label*/ 8) set_data(t0, /*label*/ ctx[3]);

			if (dirty & /*remove, addNew, options, onRepeaterChange, onlyLabel*/ 117) {
				each_value = /*options*/ ctx[0];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$1(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div, t2);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}

			if (/*helperText*/ ctx[1]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$4(ctx);
					if_block.c();
					if_block.m(div, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div);
			destroy_each(each_blocks, detaching);
			if (if_block) if_block.d();
		}
	};
}

function instance$4($$self, $$props, $$invalidate) {
	
	let { onChange } = $$props;
	let { helperText = "" } = $$props;
	let { onlyLabel = false } = $$props;
	let { label = "Options" } = $$props;
	let { options = [{ label: "", value: "" }] } = $$props;
	onMount(() => [onRepeaterChange(false)]);

	function onRepeaterChange(user = true) {
		if (onlyLabel) {
			const labels = options.map(m => m.label);
			user && dispatch("user_change", labels);

			onChange === null || onChange === void 0
			? void 0
			: onChange(labels);
		} else {
			user && dispatch("user_change", options);

			onChange === null || onChange === void 0
			? void 0
			: onChange(options);
		}
	}

	function remove(option) {
		options.splice(option, 1);
		$$invalidate(0, options = [...options]);
		onRepeaterChange();

		if (options.length === 0) {
			$$invalidate(0, options = [{ label: "", value: "" }]);
		}
	}

	function addNew() {
		$$invalidate(0, options = options.concat([{ label: "", value: "" }]));
	}

	const blur_handler = () => onRepeaterChange(true);

	function input_input_handler(each_value, i) {
		each_value[i].label = this.value;
		$$invalidate(0, options);
	}

	const blur_handler_1 = () => onRepeaterChange(true);

	function input0_input_handler(each_value, i) {
		each_value[i].label = this.value;
		$$invalidate(0, options);
	}

	const blur_handler_2 = () => onRepeaterChange(true);

	function input1_input_handler(each_value, i) {
		each_value[i].value = this.value;
		$$invalidate(0, options);
	}

	const click_handler = i => remove(i);

	$$self.$$set = $$props => {
		if ("onChange" in $$props) $$invalidate(7, onChange = $$props.onChange);
		if ("helperText" in $$props) $$invalidate(1, helperText = $$props.helperText);
		if ("onlyLabel" in $$props) $$invalidate(2, onlyLabel = $$props.onlyLabel);
		if ("label" in $$props) $$invalidate(3, label = $$props.label);
		if ("options" in $$props) $$invalidate(0, options = $$props.options);
	};

	return [
		options,
		helperText,
		onlyLabel,
		label,
		onRepeaterChange,
		remove,
		addNew,
		onChange,
		blur_handler,
		input_input_handler,
		blur_handler_1,
		input0_input_handler,
		blur_handler_2,
		input1_input_handler,
		click_handler
	];
}

class Repeater extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$4, create_fragment$4, safe_not_equal, {
			onChange: 7,
			helperText: 1,
			onlyLabel: 2,
			label: 3,
			options: 0
		});
	}
}

/* src\components\DropdownButton.svelte generated by Svelte v3.24.1 */

function get_each_context$2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[11] = list[i];
	child_ctx[13] = i;
	return child_ctx;
}

// (45:6) {:else}
function create_else_block$5(ctx) {
	let a;
	let t_value = /*action*/ ctx[11].label + "";
	let t;
	let mounted;
	let dispose;

	function click_handler(...args) {
		return /*click_handler*/ ctx[6](/*action*/ ctx[11], ...args);
	}

	return {
		c() {
			a = element("a");
			t = text(t_value);
			this.h();
		},
		l(nodes) {
			a = claim_element(nodes, "A", { class: true, href: true });
			var a_nodes = children(a);
			t = claim_text(a_nodes, t_value);
			a_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(a, "class", "dropdown-item");
			attr(a, "href", "#");
		},
		m(target, anchor) {
			insert(target, a, anchor);
			append(a, t);

			if (!mounted) {
				dispose = listen(a, "click", click_handler);
				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*actions*/ 2 && t_value !== (t_value = /*action*/ ctx[11].label + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(a);
			mounted = false;
			dispose();
		}
	};
}

// (43:6) {#if i === 0}
function create_if_block$5(ctx) {
	let span;

	return {
		c() {
			span = element("span");
		},
		l(nodes) {
			span = claim_element(nodes, "SPAN", {});
			children(span).forEach(detach);
		},
		m(target, anchor) {
			insert(target, span, anchor);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (42:4) {#each actions as action, i}
function create_each_block$2(ctx) {
	let if_block_anchor;

	function select_block_type(ctx, dirty) {
		if (/*i*/ ctx[13] === 0) return create_if_block$5;
		return create_else_block$5;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type(ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		l(nodes) {
			if_block.l(nodes);
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},
		p(ctx, dirty) {
			if_block.p(ctx, dirty);
		},
		d(detaching) {
			if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function create_fragment$5(ctx) {
	let div1;
	let button0;

	let t0_value = (/*processing*/ ctx[0]
	? `${/*processingLabel*/ ctx[2]}`
	: /*actions*/ ctx[1][0].label) + "";

	let t0;
	let button0_class_value;
	let button0_onclick_value;
	let t1;
	let button1;
	let span0;
	let t2;
	let span1;
	let t3;
	let t4;
	let div0;
	let each_value = /*actions*/ ctx[1];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
	}

	return {
		c() {
			div1 = element("div");
			button0 = element("button");
			t0 = text(t0_value);
			t1 = space();
			button1 = element("button");
			span0 = element("span");
			t2 = space();
			span1 = element("span");
			t3 = text("Toggle Dropdown");
			t4 = space();
			div0 = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			this.h();
		},
		l(nodes) {
			div1 = claim_element(nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			button0 = claim_element(div1_nodes, "BUTTON", { type: true, class: true, onclick: true });
			var button0_nodes = children(button0);
			t0 = claim_text(button0_nodes, t0_value);
			button0_nodes.forEach(detach);
			t1 = claim_space(div1_nodes);

			button1 = claim_element(div1_nodes, "BUTTON", {
				type: true,
				class: true,
				"data-toggle": true,
				"aria-haspopup": true,
				"aria-expanded": true
			});

			var button1_nodes = children(button1);
			span0 = claim_element(button1_nodes, "SPAN", { class: true });
			children(span0).forEach(detach);
			t2 = claim_space(button1_nodes);
			span1 = claim_element(button1_nodes, "SPAN", { class: true });
			var span1_nodes = children(span1);
			t3 = claim_text(span1_nodes, "Toggle Dropdown");
			span1_nodes.forEach(detach);
			button1_nodes.forEach(detach);
			t4 = claim_space(div1_nodes);
			div0 = claim_element(div1_nodes, "DIV", { class: true, style: true });
			var div0_nodes = children(div0);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(div0_nodes);
			}

			div0_nodes.forEach(detach);
			div1_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(button0, "type", "button");
			attr(button0, "class", button0_class_value = `btn btn-primary`);
			attr(button0, "onclick", button0_onclick_value = /*func*/ ctx[5]);
			attr(span0, "class", "fas fa-angle-down dropdown-arrow");
			attr(span1, "class", "sr-only");
			attr(button1, "type", "button");
			attr(button1, "class", "btn btn-primary dropdown-toggle dropdown-toggle-split");
			attr(button1, "data-toggle", "dropdown");
			attr(button1, "aria-haspopup", "true");
			attr(button1, "aria-expanded", "false");
			attr(div0, "class", "dropdown-menu");
			attr(div1, "class", "btn-group mr-2 mb-2");
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			append(div1, button0);
			append(button0, t0);
			append(div1, t1);
			append(div1, button1);
			append(button1, span0);
			append(button1, t2);
			append(button1, span1);
			append(span1, t3);
			append(div1, t4);
			append(div1, div0);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div0, null);
			}
		},
		p(ctx, [dirty]) {
			if (dirty & /*processing, processingLabel, actions*/ 7 && t0_value !== (t0_value = (/*processing*/ ctx[0]
			? `${/*processingLabel*/ ctx[2]}`
			: /*actions*/ ctx[1][0].label) + "")) set_data(t0, t0_value);

			if (dirty & /*actions*/ 2 && button0_onclick_value !== (button0_onclick_value = /*func*/ ctx[5])) {
				attr(button0, "onclick", button0_onclick_value);
			}

			if (dirty & /*executeAction, actions*/ 10) {
				each_value = /*actions*/ ctx[1];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$2(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$2(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div0, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div1);
			destroy_each(each_blocks, detaching);
		}
	};
}

function instance$5($$self, $$props, $$invalidate) {
	var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
		function adopt(value) {
			return value instanceof P
			? value
			: new P(function (resolve) {
						resolve(value);
					});
		}

		return new (P || (P = Promise))(function (resolve, reject) {
				function fulfilled(value) {
					try {
						step(generator.next(value));
					} catch(e) {
						reject(e);
					}
				}

				function rejected(value) {
					try {
						step(generator["throw"](value));
					} catch(e) {
						reject(e);
					}
				}

				function step(result) {
					result.done
					? resolve(result.value)
					: adopt(result.value).then(fulfilled, rejected);
				}

				step((generator = generator.apply(thisArg, _arguments || [])).next());
			});
	};

	
	let { label } = $$props;
	let { actions = [] } = $$props;
	let { processing = false } = $$props;
	let { processingLabel = "Processing..." } = $$props;

	function executeAction(action) {
		return __awaiter(this, void 0, void 0, function* () {
			try {
				$$invalidate(0, processing = true);
				yield action.onClick();
			} finally {
				$$invalidate(0, processing = false);
			}
		});
	}

	const func = () => executeAction(actions[0]);
	const click_handler = action => executeAction(action);

	$$self.$$set = $$props => {
		if ("label" in $$props) $$invalidate(4, label = $$props.label);
		if ("actions" in $$props) $$invalidate(1, actions = $$props.actions);
		if ("processing" in $$props) $$invalidate(0, processing = $$props.processing);
		if ("processingLabel" in $$props) $$invalidate(2, processingLabel = $$props.processingLabel);
	};

	return [
		processing,
		actions,
		processingLabel,
		executeAction,
		label,
		func,
		click_handler
	];
}

class DropdownButton extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$5, create_fragment$5, safe_not_equal, {
			label: 4,
			actions: 1,
			processing: 0,
			processingLabel: 2
		});
	}
}

/* src\features\form\edit\ManageOptionSets.svelte generated by Svelte v3.24.1 */

function get_each_context$3(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[16] = list[i];
	child_ctx[17] = list;
	child_ctx[18] = i;
	return child_ctx;
}

// (136:2) {:else}
function create_else_block_1$1(ctx) {
	let div1;
	let div0;
	let span;
	let t;

	return {
		c() {
			div1 = element("div");
			div0 = element("div");
			span = element("span");
			t = text("Loading...");
			this.h();
		},
		l(nodes) {
			div1 = claim_element(nodes, "DIV", { style: true });
			var div1_nodes = children(div1);
			div0 = claim_element(div1_nodes, "DIV", { class: true, role: true });
			var div0_nodes = children(div0);
			span = claim_element(div0_nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t = claim_text(span_nodes, "Loading...");
			span_nodes.forEach(detach);
			div0_nodes.forEach(detach);
			div1_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(span, "class", "sr-only");
			attr(div0, "class", "spinner-border text-secondary");
			attr(div0, "role", "status");
			set_style(div1, "text-align", "center");
			set_style(div1, "padding-top", "1em");
			set_style(div1, "padding-bottom", "1em");
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			append(div1, div0);
			append(div0, span);
			append(span, t);
		},
		d(detaching) {
			if (detaching) detach(div1);
		}
	};
}

// (134:2) {#if sets.length > 0}
function create_if_block_3(ctx) {
	return { c: noop, l: noop, m: noop, d: noop };
}

// (175:8) {:else}
function create_else_block$6(ctx) {
	let repeater;
	let current;

	function func_3(...args) {
		return /*func_3*/ ctx[11](/*index*/ ctx[18], ...args);
	}

	repeater = new Repeater({
			props: {
				options: isString(/*set*/ ctx[16].value)
				? []
				: /*set*/ ctx[16].value,
				onChange: func_3
			}
		});

	return {
		c() {
			create_component(repeater.$$.fragment);
		},
		l(nodes) {
			claim_component(repeater.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(repeater, target, anchor);
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			const repeater_changes = {};

			if (dirty & /*sets*/ 2) repeater_changes.options = isString(/*set*/ ctx[16].value)
			? []
			: /*set*/ ctx[16].value;

			repeater.$set(repeater_changes);
		},
		i(local) {
			if (current) return;
			transition_in(repeater.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(repeater.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(repeater, detaching);
		}
	};
}

// (173:26) 
function create_if_block_2(ctx) {
	let t;

	return {
		c() {
			t = text("Failed to load, please try re-opening this dialog.");
		},
		l(nodes) {
			t = claim_text(nodes, "Failed to load, please try re-opening this dialog.");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (171:26) 
function create_if_block_1$3(ctx) {
	let div;

	return {
		c() {
			div = element("div");
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			children(div).forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "loader");
		},
		m(target, anchor) {
			insert(target, div, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

// (166:8) {#if set.type === 'remote'}
function create_if_block$6(ctx) {
	let field;
	let current;

	function func_2(...args) {
		return /*func_2*/ ctx[10](/*set*/ ctx[16], /*each_value*/ ctx[17], /*index*/ ctx[18], ...args);
	}

	field = new Field({
			props: {
				field: {
					helperText: "See <a href=\"test\" target=\"_blank\">Remote Option Set Guide</a> for information on how to structure your endpoint response.",
					onChange: func_2,
					id: `${/*set*/ ctx[16].name}-url`,
					type: "string",
					value: /*set*/ ctx[16].value,
					name: "url",
					label: "Url",
					required: true
				}
			}
		});

	return {
		c() {
			create_component(field.$$.fragment);
		},
		l(nodes) {
			claim_component(field.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(field, target, anchor);
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			const field_changes = {};

			if (dirty & /*sets*/ 2) field_changes.field = {
				helperText: "See <a href=\"test\" target=\"_blank\">Remote Option Set Guide</a> for information on how to structure your endpoint response.",
				onChange: func_2,
				id: `${/*set*/ ctx[16].name}-url`,
				type: "string",
				value: /*set*/ ctx[16].value,
				name: "url",
				label: "Url",
				required: true
			};

			field.$set(field_changes);
		},
		i(local) {
			if (current) return;
			transition_in(field.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(field.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(field, detaching);
		}
	};
}

// (141:2) {#each sets as set, index}
function create_each_block$3(ctx) {
	let div1;
	let h2;
	let t0_value = (/*set*/ ctx[16].name ?? "") + "";
	let t0;
	let t1;
	let div0;
	let field0;
	let t2;
	let field1;
	let t3;
	let current_block_type_index;
	let if_block;
	let div0_id_value;
	let current;

	function func(...args) {
		return /*func*/ ctx[8](/*set*/ ctx[16], /*each_value*/ ctx[17], /*index*/ ctx[18], ...args);
	}

	field0 = new Field({
			props: {
				field: {
					id: `${/*set*/ ctx[16].id}-name`,
					type: "string",
					required: true,
					name: "name",
					label: "Name",
					placeholder: "Name",
					value: /*set*/ ctx[16].name,
					onChange: func
				}
			}
		});

	function func_1(...args) {
		return /*func_1*/ ctx[9](/*set*/ ctx[16], /*each_value*/ ctx[17], /*index*/ ctx[18], ...args);
	}

	field1 = new Field({
			props: {
				field: {
					onChange: func_1,
					id: `${/*set*/ ctx[16].id}-type`,
					type: "combobox",
					value: /*set*/ ctx[16].type,
					options: {
						type: "local",
						value: [
							{ label: "Inline", value: "local" },
							{ label: "Remote", value: "remote" }
						]
					},
					name: "type",
					label: "Type",
					helperText: "Choose whether you want to automatically load options in from a remote url or manually specify them here."
				}
			}
		});

	const if_block_creators = [create_if_block$6, create_if_block_1$3, create_if_block_2, create_else_block$6];
	const if_blocks = [];

	function select_block_type_1(ctx, dirty) {
		if (/*set*/ ctx[16].type === "remote") return 0;
		if (/*loading*/ ctx[2]) return 1;
		if (/*errored*/ ctx[3]) return 2;
		return 3;
	}

	current_block_type_index = select_block_type_1(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			div1 = element("div");
			h2 = element("h2");
			t0 = text(t0_value);
			t1 = space();
			div0 = element("div");
			create_component(field0.$$.fragment);
			t2 = space();
			create_component(field1.$$.fragment);
			t3 = space();
			if_block.c();
			this.h();
		},
		l(nodes) {
			div1 = claim_element(nodes, "DIV", { style: true });
			var div1_nodes = children(div1);
			h2 = claim_element(div1_nodes, "H2", {});
			var h2_nodes = children(h2);
			t0 = claim_text(h2_nodes, t0_value);
			h2_nodes.forEach(detach);
			t1 = claim_space(div1_nodes);
			div0 = claim_element(div1_nodes, "DIV", { id: true });
			var div0_nodes = children(div0);
			claim_component(field0.$$.fragment, div0_nodes);
			t2 = claim_space(div0_nodes);
			claim_component(field1.$$.fragment, div0_nodes);
			t3 = claim_space(div0_nodes);
			if_block.l(div0_nodes);
			div0_nodes.forEach(detach);
			div1_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div0, "id", div0_id_value = /*set*/ ctx[16].name ?? "");
			set_style(div1, "margin-top", "1em");
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			append(div1, h2);
			append(h2, t0);
			append(div1, t1);
			append(div1, div0);
			mount_component(field0, div0, null);
			append(div0, t2);
			mount_component(field1, div0, null);
			append(div0, t3);
			if_blocks[current_block_type_index].m(div0, null);
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			if ((!current || dirty & /*sets*/ 2) && t0_value !== (t0_value = (/*set*/ ctx[16].name ?? "") + "")) set_data(t0, t0_value);
			const field0_changes = {};

			if (dirty & /*sets*/ 2) field0_changes.field = {
				id: `${/*set*/ ctx[16].id}-name`,
				type: "string",
				required: true,
				name: "name",
				label: "Name",
				placeholder: "Name",
				value: /*set*/ ctx[16].name,
				onChange: func
			};

			field0.$set(field0_changes);
			const field1_changes = {};

			if (dirty & /*sets, isNew*/ 3) field1_changes.field = {
				onChange: func_1,
				id: `${/*set*/ ctx[16].id}-type`,
				type: "combobox",
				value: /*set*/ ctx[16].type,
				options: {
					type: "local",
					value: [
						{ label: "Inline", value: "local" },
						{ label: "Remote", value: "remote" }
					]
				},
				name: "type",
				label: "Type",
				helperText: "Choose whether you want to automatically load options in from a remote url or manually specify them here."
			};

			field1.$set(field1_changes);
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_1(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(div0, null);
			}

			if (!current || dirty & /*sets*/ 2 && div0_id_value !== (div0_id_value = /*set*/ ctx[16].name ?? "")) {
				attr(div0, "id", div0_id_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in(field0.$$.fragment, local);
			transition_in(field1.$$.fragment, local);
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(field0.$$.fragment, local);
			transition_out(field1.$$.fragment, local);
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div1);
			destroy_component(field0);
			destroy_component(field1);
			if_blocks[current_block_type_index].d();
		}
	};
}

function create_fragment$6(ctx) {
	let div1;
	let t0;
	let t1;
	let div0;
	let dropdownbutton;
	let current;

	function select_block_type(ctx, dirty) {
		if (/*sets*/ ctx[1].length > 0) return create_if_block_3;
		return create_else_block_1$1;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type(ctx);
	let each_value = /*sets*/ ctx[1];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$3(get_each_context$3(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	dropdownbutton = new DropdownButton({
			props: {
				label: "Save",
				processingLabel: "Saving...",
				actions: [
					{
						label: "Save as Draft",
						onClick: /*save*/ ctx[6]
					},
					{
						label: "Save and Publish",
						onClick: /*save*/ ctx[6]
					}
				]
			}
		});

	return {
		c() {
			div1 = element("div");
			if_block.c();
			t0 = space();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t1 = space();
			div0 = element("div");
			create_component(dropdownbutton.$$.fragment);
			this.h();
		},
		l(nodes) {
			div1 = claim_element(nodes, "DIV", {});
			var div1_nodes = children(div1);
			if_block.l(div1_nodes);
			t0 = claim_space(div1_nodes);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(div1_nodes);
			}

			t1 = claim_space(div1_nodes);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			claim_component(dropdownbutton.$$.fragment, div0_nodes);
			div0_nodes.forEach(detach);
			div1_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div0, "class", "float-right");
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			if_block.m(div1, null);
			append(div1, t0);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div1, null);
			}

			append(div1, t1);
			append(div1, div0);
			mount_component(dropdownbutton, div0, null);
			current = true;
		},
		p(ctx, [dirty]) {
			if (current_block_type !== (current_block_type = select_block_type(ctx))) {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(div1, t0);
				}
			}

			if (dirty & /*sets, loading, errored, isString, onRepeaterChange, isNew, undefined, loadLocalOptions*/ 63) {
				each_value = /*sets*/ ctx[1];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$3(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block$3(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(div1, t1);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			transition_in(dropdownbutton.$$.fragment, local);
			current = true;
		},
		o(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			transition_out(dropdownbutton.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div1);
			if_block.d();
			destroy_each(each_blocks, detaching);
			destroy_component(dropdownbutton);
		}
	};
}

function instance$6($$self, $$props, $$invalidate) {
	var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
		function adopt(value) {
			return value instanceof P
			? value
			: new P(function (resolve) {
						resolve(value);
					});
		}

		return new (P || (P = Promise))(function (resolve, reject) {
				function fulfilled(value) {
					try {
						step(generator.next(value));
					} catch(e) {
						reject(e);
					}
				}

				function rejected(value) {
					try {
						step(generator["throw"](value));
					} catch(e) {
						reject(e);
					}
				}

				function step(result) {
					result.done
					? resolve(result.value)
					: adopt(result.value).then(fulfilled, rejected);
				}

				step((generator = generator.apply(thisArg, _arguments || [])).next());
			});
	};

	
	
	let sets = [];
	let loading = false;
	let errored = false;
	let { name } = $$props;
	let { isNew } = $$props;

	onMount(() => __awaiter(void 0, void 0, void 0, function* () {
		if (isNew) {
			$$invalidate(1, sets = sets.concat([
				{
					value: [{ label: "", value: "" }],
					type: "local"
				}
			]));
		} else {
			yield load();
		}
	}));

	function load() {
		return __awaiter(this, void 0, void 0, function* () {
			$$invalidate(2, loading = true);
			const data = yield getApi("option-set");
			const result = data.find(w => w.name === name);

			if (!result) {
				return;
			}

			if (result.type === "local") {
				result.localSaveId = result.value;
				result.value = yield convertUrlToLocal(result);
			}

			$$invalidate(1, sets = [result]);
			$$invalidate(2, loading = false);
		});
	}

	function loadLocalOptions(index) {
		return __awaiter(this, void 0, void 0, function* () {
			$$invalidate(1, sets[index].value = yield convertUrlToLocal(sets[index]), sets);
		});
	}

	function convertUrlToLocal(set) {
		var _a;

		return __awaiter(this, void 0, void 0, function* () {
			$$invalidate(2, loading = true);

			try {
				const url = (_a = set.value) !== null && _a !== void 0
				? _a
				: set.localSaveId;

				if (!url) {
					return [{ label: "", value: "" }];
				}

				const response = yield fetch(url);
				const data = yield response.json();
				const results = [];

				Object.keys(data).forEach(key => {
					results.push({ label: key, value: data[key] });
				});

				return results;
			} catch(ex) {
				$$invalidate(3, errored = true);
				return [];
			} finally {
				$$invalidate(2, loading = false);
			}
		});
	}

	function onRepeaterChange(data, index) {
		$$invalidate(1, sets[index].value = data, sets);
	}

	function save() {
		return __awaiter(this, void 0, void 0, function* () {
			const promises = sets.map(s => __awaiter(this, void 0, void 0, function* () {
				if (s.type === "local") {
					s.value = yield generateInlineUrl(s);
				}

				return s;
			}));

			const toSave = yield Promise.all(promises);
			yield postApi("option-set", toSave[0]);
			dispatch("option_set_modified", toSave[0]);

			dispatch("dialog_show", {
				child: OptionSetsList,
				closeOnOutsideClick: false,
				confirmCloseOnDirty: true,
				title: "Manage Option Sets"
			});
		});
	}

	function generateInlineUrl(set) {
		return __awaiter(this, void 0, void 0, function* () {
			const body = {};
			const v = set.value;

			v.forEach(s => {
				body[s.label] = s.value;
			});

			const saveId = getUrlParameter("id", set.localSaveId);
			const qs = saveId ? `?id=${saveId}` : "";

			const { message } = qs
			? yield putApi(`s3/json?${qs}`, body)
			: yield postApi(`s3/json?${qs}`, body);

			return message;
		});
	}

	const func = (set, each_value, index, value) => {
		$$invalidate(1, each_value[index].name = value, sets);
	};

	const func_1 = (set, each_value, index, value) => {
		if (value === "local") {
			$$invalidate(1, each_value[index].remoteUrl = set.value, sets);
			$$invalidate(1, each_value[index].value = set.localOptions, sets);

			if (!isNew && set.localOptions?.length === 0) {
				$$invalidate(1, each_value[index].value = undefined, sets);
				loadLocalOptions(index);
			}
		}

		if (value === "remote") {
			$$invalidate(1, each_value[index].localOptions = set.value ?? [], sets);
			$$invalidate(1, each_value[index].value = set.remoteUrl, sets);
		}

		$$invalidate(1, each_value[index].type = value, sets);
	};

	const func_2 = (set, each_value, index, value) => {
		$$invalidate(1, each_value[index].value = value, sets);
	};

	const func_3 = (index, data) => {
		onRepeaterChange(data, index);
	};

	$$self.$$set = $$props => {
		if ("name" in $$props) $$invalidate(7, name = $$props.name);
		if ("isNew" in $$props) $$invalidate(0, isNew = $$props.isNew);
	};

	return [
		isNew,
		sets,
		loading,
		errored,
		loadLocalOptions,
		onRepeaterChange,
		save,
		name,
		func,
		func_1,
		func_2,
		func_3
	];
}

class ManageOptionSets extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$6, create_fragment$6, safe_not_equal, { name: 7, isNew: 0 });
	}
}

/* src\features\form\edit\OptionSetsList.svelte generated by Svelte v3.24.1 */

function create_fragment$7(ctx) {
	let remotetable;
	let current;

	remotetable = new RemoteTable({
			props: {
				headerActions: [
					{
						label: "+ New Option Set",
						onClick: /*createNew*/ ctx[0]
					}
				],
				getRows: /*getRows*/ ctx[1],
				hidden: /*hidden*/ ctx[2],
				onEdit: /*func*/ ctx[4],
				onDelete: /*func_1*/ ctx[5]
			}
		});

	return {
		c() {
			create_component(remotetable.$$.fragment);
		},
		l(nodes) {
			claim_component(remotetable.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(remotetable, target, anchor);
			current = true;
		},
		p: noop,
		i(local) {
			if (current) return;
			transition_in(remotetable.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(remotetable.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(remotetable, detaching);
		}
	};
}

function instance$7($$self, $$props, $$invalidate) {
	var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
		function adopt(value) {
			return value instanceof P
			? value
			: new P(function (resolve) {
						resolve(value);
					});
		}

		return new (P || (P = Promise))(function (resolve, reject) {
				function fulfilled(value) {
					try {
						step(generator.next(value));
					} catch(e) {
						reject(e);
					}
				}

				function rejected(value) {
					try {
						step(generator["throw"](value));
					} catch(e) {
						reject(e);
					}
				}

				function step(result) {
					result.done
					? resolve(result.value)
					: adopt(result.value).then(fulfilled, rejected);
				}

				step((generator = generator.apply(thisArg, _arguments || [])).next());
			});
	};

	
	
	let { type = "Selector" } = $$props;

	function createNew() {
		dispatch("dialog_show", {
			child: ManageOptionSets,
			title: "Create Option Set",
			save: false,
			props: { isNew: true }
		});
	}

	function getRows() {
		return __awaiter(this, void 0, void 0, function* () {
			const data = yield getApi("option-set");

			return data.map(d => {
				return {
					id: d.id,
					Name: d.name,
					Value: d.value,
					Type: d.type === "local" ? "Inline" : "Remote",
					"Last Updated": new Date(d.changeTime).toLocaleString(),
					"Modified By": d.changeBy,
					"Forms Using": 3,
					Status: "Published"
				};
			});
		});
	}

	const hidden = new Set(["Value", "id"]);

	const func = async row => {
		dispatch("dialog_show", {
			child: ManageOptionSets,
			title: "Modifying Option Set",
			save: false,
			props: { name: row.Name }
		});
	};

	const func_1 = () => {
		alert("delete");
	};

	$$self.$$set = $$props => {
		if ("type" in $$props) $$invalidate(3, type = $$props.type);
	};

	return [createNew, getRows, hidden, type, func, func_1];
}

class OptionSetsList extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$7, create_fragment$7, safe_not_equal, { type: 3 });
	}
}

/* src\features\form\edit\ComboBoxOptionsEditor.svelte generated by Svelte v3.24.1 */

function create_fragment$8(ctx) {
	let div;
	let field_1;
	let t0;
	let button;
	let t1;
	let current;
	let mounted;
	let dispose;

	field_1 = new Field({
			props: {
				field: {
					id: randomString(),
					loadTransformer,
					required: true,
					label: "Option Set",
					value: /*field*/ ctx[0].options,
					name: `${/*field*/ ctx[0].id}-builder-config-field-field_editor-options`,
					type: "combobox",
					options: {
						type: "remote",
						value: `${apiEndpoint()}option-set`
					},
					configFieldTarget: "options",
					configTarget: /*field*/ ctx[0].id
				}
			}
		});

	return {
		c() {
			div = element("div");
			create_component(field_1.$$.fragment);
			t0 = space();
			button = element("button");
			t1 = text("Manage Option Sets");
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", {});
			var div_nodes = children(div);
			claim_component(field_1.$$.fragment, div_nodes);
			t0 = claim_space(div_nodes);
			button = claim_element(div_nodes, "BUTTON", { class: true, type: true });
			var button_nodes = children(button);
			t1 = claim_text(button_nodes, "Manage Option Sets");
			button_nodes.forEach(detach);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(button, "class", "manage-button btn btn-light svelte-bh6pw2");
			attr(button, "type", "button");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(field_1, div, null);
			append(div, t0);
			append(div, button);
			append(button, t1);
			current = true;

			if (!mounted) {
				dispose = listen(button, "click", /*manageSets*/ ctx[1]);
				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			const field_1_changes = {};

			if (dirty & /*field*/ 1) field_1_changes.field = {
				id: randomString(),
				loadTransformer,
				required: true,
				label: "Option Set",
				value: /*field*/ ctx[0].options,
				name: `${/*field*/ ctx[0].id}-builder-config-field-field_editor-options`,
				type: "combobox",
				options: {
					type: "remote",
					value: `${apiEndpoint()}option-set`
				},
				configFieldTarget: "options",
				configTarget: /*field*/ ctx[0].id
			};

			field_1.$set(field_1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(field_1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(field_1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(field_1);
			mounted = false;
			dispose();
		}
	};
}

function loadTransformer(value) {
	return value.map(v => {
		return { label: v.name, value: v.value };
	});
}

function instance$8($$self, $$props, $$invalidate) {
	
	let { field } = $$props;

	function manageSets() {
		dispatch("dialog_show", {
			child: OptionSetsList,
			closeOnOutsideClick: false,
			confirmCloseOnDirty: true,
			title: "Manage Option Sets",
			save: false
		});
	}

	$$self.$$set = $$props => {
		if ("field" in $$props) $$invalidate(0, field = $$props.field);
	};

	return [field, manageSets];
}

class ComboBoxOptionsEditor extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$8, create_fragment$8, safe_not_equal, { field: 0 });
	}
}

/* src\features\form\edit\AddressEditor.svelte generated by Svelte v3.24.1 */

function create_fragment$9(ctx) {
	let div1;
	let div0;
	let h5;
	let t0;
	let t1;
	let hr;

	return {
		c() {
			div1 = element("div");
			div0 = element("div");
			h5 = element("h5");
			t0 = text("Address Settings");
			t1 = space();
			hr = element("hr");
			this.h();
		},
		l(nodes) {
			div1 = claim_element(nodes, "DIV", {});
			var div1_nodes = children(div1);
			div0 = claim_element(div1_nodes, "DIV", { style: true });
			var div0_nodes = children(div0);
			h5 = claim_element(div0_nodes, "H5", { style: true });
			var h5_nodes = children(h5);
			t0 = claim_text(h5_nodes, "Address Settings");
			h5_nodes.forEach(detach);
			t1 = claim_space(div0_nodes);
			hr = claim_element(div0_nodes, "HR", {});
			div0_nodes.forEach(detach);
			div1_nodes.forEach(detach);
			this.h();
		},
		h() {
			set_style(h5, "padding-bottom", "0.2em");
			set_style(div0, "padding-left", "0.5em");
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			append(div1, div0);
			append(div0, h5);
			append(h5, t0);
			append(div0, t1);
			append(div0, hr);
		},
		p: noop,
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div1);
		}
	};
}

function instance$9($$self, $$props, $$invalidate) {
	
	
	let { field } = $$props;
	let { expanded } = $$props;

	$$self.$$set = $$props => {
		if ("field" in $$props) $$invalidate(0, field = $$props.field);
		if ("expanded" in $$props) $$invalidate(1, expanded = $$props.expanded);
	};

	return [field, expanded];
}

class AddressEditor extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$9, create_fragment$9, safe_not_equal, { field: 0, expanded: 1 });
	}
}

/* src\features\form\edit\CheckboxGroupEditor.svelte generated by Svelte v3.24.1 */

function create_fragment$a(ctx) {
	let div;
	let repeater;
	let t;
	let field_1;
	let current;

	repeater = new Repeater({
			props: {
				options: /*options*/ ctx[2](),
				onlyLabel: true,
				label: "Checkbox Options",
				onChange: /*onOptionsChange*/ ctx[1]
			}
		});

	field_1 = new Field({
			props: {
				field: {
					id: randomString(),
					type: "switch",
					label: "Include 'Other' Option",
					value: {
						type: "local",
						value: /*field*/ ctx[0].includeOther || false
					},
					configFieldTarget: "includeOther",
					configTarget: /*field*/ ctx[0].id
				}
			}
		});

	return {
		c() {
			div = element("div");
			create_component(repeater.$$.fragment);
			t = space();
			create_component(field_1.$$.fragment);
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", {});
			var div_nodes = children(div);
			claim_component(repeater.$$.fragment, div_nodes);
			t = claim_space(div_nodes);
			claim_component(field_1.$$.fragment, div_nodes);
			div_nodes.forEach(detach);
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(repeater, div, null);
			append(div, t);
			mount_component(field_1, div, null);
			current = true;
		},
		p(ctx, [dirty]) {
			const field_1_changes = {};

			if (dirty & /*field*/ 1) field_1_changes.field = {
				id: randomString(),
				type: "switch",
				label: "Include 'Other' Option",
				value: {
					type: "local",
					value: /*field*/ ctx[0].includeOther || false
				},
				configFieldTarget: "includeOther",
				configTarget: /*field*/ ctx[0].id
			};

			field_1.$set(field_1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(repeater.$$.fragment, local);
			transition_in(field_1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(repeater.$$.fragment, local);
			transition_out(field_1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(repeater);
			destroy_component(field_1);
		}
	};
}

function instance$a($$self, $$props, $$invalidate) {
	
	
	let { field } = $$props;
	let { expanded } = $$props;

	function onOptionsChange(options) {
		if (options.length === 0) {
			options = ["Checkbox Item 1"];
		}

		$$invalidate(0, field.options = options, field);

		formStore.set(field, {
			fromUser: true,
			field: "options",
			value: options
		});
	}

	function options() {
		var _a;

		if (isEmptyOrNull(field.options)) {
			return [
				{
					label: "Checkbox Item 1",
					value: "Checkbox Item 1"
				}
			];
		}

		return (_a = field.options) === null || _a === void 0
		? void 0
		: _a.map(w => {
				return { label: w, value: w };
			});
	}

	$$self.$$set = $$props => {
		if ("field" in $$props) $$invalidate(0, field = $$props.field);
		if ("expanded" in $$props) $$invalidate(3, expanded = $$props.expanded);
	};

	return [field, onOptionsChange, options, expanded];
}

class CheckboxGroupEditor extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$a, create_fragment$a, safe_not_equal, { field: 0, expanded: 3 });
	}
}

/* src\features\form\edit\RadioGroupEditor.svelte generated by Svelte v3.24.1 */

function create_fragment$b(ctx) {
	let div;
	let repeater;
	let t;
	let field_1;
	let current;

	repeater = new Repeater({
			props: {
				options: /*options*/ ctx[2](),
				onlyLabel: true,
				label: "Radio Options",
				onChange: /*onOptionsChange*/ ctx[1]
			}
		});

	field_1 = new Field({
			props: {
				field: {
					id: randomString(),
					type: "switch",
					label: "Include 'Other' Option",
					value: {
						type: "local",
						value: /*field*/ ctx[0].includeOther || false
					},
					configFieldTarget: "includeOther",
					configTarget: /*field*/ ctx[0].id
				}
			}
		});

	return {
		c() {
			div = element("div");
			create_component(repeater.$$.fragment);
			t = space();
			create_component(field_1.$$.fragment);
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", {});
			var div_nodes = children(div);
			claim_component(repeater.$$.fragment, div_nodes);
			t = claim_space(div_nodes);
			claim_component(field_1.$$.fragment, div_nodes);
			div_nodes.forEach(detach);
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(repeater, div, null);
			append(div, t);
			mount_component(field_1, div, null);
			current = true;
		},
		p(ctx, [dirty]) {
			const field_1_changes = {};

			if (dirty & /*field*/ 1) field_1_changes.field = {
				id: randomString(),
				type: "switch",
				label: "Include 'Other' Option",
				value: {
					type: "local",
					value: /*field*/ ctx[0].includeOther || false
				},
				configFieldTarget: "includeOther",
				configTarget: /*field*/ ctx[0].id
			};

			field_1.$set(field_1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(repeater.$$.fragment, local);
			transition_in(field_1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(repeater.$$.fragment, local);
			transition_out(field_1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(repeater);
			destroy_component(field_1);
		}
	};
}

function instance$b($$self, $$props, $$invalidate) {
	
	
	let { field } = $$props;
	let { expanded } = $$props;

	function onOptionsChange(options) {
		if (options.length === 0) {
			options = ["Radio Item 1"];
		}

		$$invalidate(0, field.options = options, field);

		formStore.set(field, {
			fromUser: true,
			field: "options",
			value: options
		});
	}

	function options() {
		var _a;

		if (isEmptyOrNull(field.options)) {
			return [
				{
					label: "Radio Item 1",
					value: "Radio Item 1"
				}
			];
		}

		return (_a = field.options) === null || _a === void 0
		? void 0
		: _a.map(w => {
				return { label: w, value: w };
			});
	}

	$$self.$$set = $$props => {
		if ("field" in $$props) $$invalidate(0, field = $$props.field);
		if ("expanded" in $$props) $$invalidate(3, expanded = $$props.expanded);
	};

	return [field, onOptionsChange, options, expanded];
}

class RadioGroupEditor extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$b, create_fragment$b, safe_not_equal, { field: 0, expanded: 3 });
	}
}

/* src\features\form\edit\FieldTypeEditor.svelte generated by Svelte v3.24.1 */

function create_if_block_5(ctx) {
	let field_1;
	let current;

	field_1 = new Field({
			props: {
				field: {
					id: randomString(),
					type: "switch",
					label: "Default Value",
					value: {
						type: "local",
						value: /*field*/ ctx[0].defaultValue || false
					},
					configFieldTarget: "defaultValue",
					configTarget: /*field*/ ctx[0].id
				}
			}
		});

	return {
		c() {
			create_component(field_1.$$.fragment);
		},
		l(nodes) {
			claim_component(field_1.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(field_1, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const field_1_changes = {};

			if (dirty & /*field*/ 1) field_1_changes.field = {
				id: randomString(),
				type: "switch",
				label: "Default Value",
				value: {
					type: "local",
					value: /*field*/ ctx[0].defaultValue || false
				},
				configFieldTarget: "defaultValue",
				configTarget: /*field*/ ctx[0].id
			};

			field_1.$set(field_1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(field_1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(field_1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(field_1, detaching);
		}
	};
}

// (20:41) 
function create_if_block_4(ctx) {
	let radiogroupeditor;
	let current;

	radiogroupeditor = new RadioGroupEditor({
			props: {
				field: /*field*/ ctx[0],
				expanded: /*field*/ ctx[0].expanded
			}
		});

	return {
		c() {
			create_component(radiogroupeditor.$$.fragment);
		},
		l(nodes) {
			claim_component(radiogroupeditor.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(radiogroupeditor, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const radiogroupeditor_changes = {};
			if (dirty & /*field*/ 1) radiogroupeditor_changes.field = /*field*/ ctx[0];
			if (dirty & /*field*/ 1) radiogroupeditor_changes.expanded = /*field*/ ctx[0].expanded;
			radiogroupeditor.$set(radiogroupeditor_changes);
		},
		i(local) {
			if (current) return;
			transition_in(radiogroupeditor.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(radiogroupeditor.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(radiogroupeditor, detaching);
		}
	};
}

// (18:44) 
function create_if_block_3$1(ctx) {
	let checkboxgroupeditor;
	let current;

	checkboxgroupeditor = new CheckboxGroupEditor({
			props: {
				field: /*field*/ ctx[0],
				expanded: /*field*/ ctx[0].expanded
			}
		});

	return {
		c() {
			create_component(checkboxgroupeditor.$$.fragment);
		},
		l(nodes) {
			claim_component(checkboxgroupeditor.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(checkboxgroupeditor, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const checkboxgroupeditor_changes = {};
			if (dirty & /*field*/ 1) checkboxgroupeditor_changes.field = /*field*/ ctx[0];
			if (dirty & /*field*/ 1) checkboxgroupeditor_changes.expanded = /*field*/ ctx[0].expanded;
			checkboxgroupeditor.$set(checkboxgroupeditor_changes);
		},
		i(local) {
			if (current) return;
			transition_in(checkboxgroupeditor.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(checkboxgroupeditor.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(checkboxgroupeditor, detaching);
		}
	};
}

// (16:37) 
function create_if_block_2$1(ctx) {
	let addresseditor;
	let current;

	addresseditor = new AddressEditor({
			props: {
				field: /*field*/ ctx[0],
				expanded: /*field*/ ctx[0].expanded
			}
		});

	return {
		c() {
			create_component(addresseditor.$$.fragment);
		},
		l(nodes) {
			claim_component(addresseditor.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(addresseditor, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const addresseditor_changes = {};
			if (dirty & /*field*/ 1) addresseditor_changes.field = /*field*/ ctx[0];
			if (dirty & /*field*/ 1) addresseditor_changes.expanded = /*field*/ ctx[0].expanded;
			addresseditor.$set(addresseditor_changes);
		},
		i(local) {
			if (current) return;
			transition_in(addresseditor.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(addresseditor.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(addresseditor, detaching);
		}
	};
}

// (14:38) 
function create_if_block_1$4(ctx) {
	let comboboxoptionseditor;
	let current;
	comboboxoptionseditor = new ComboBoxOptionsEditor({ props: { field: /*field*/ ctx[0] } });

	return {
		c() {
			create_component(comboboxoptionseditor.$$.fragment);
		},
		l(nodes) {
			claim_component(comboboxoptionseditor.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(comboboxoptionseditor, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const comboboxoptionseditor_changes = {};
			if (dirty & /*field*/ 1) comboboxoptionseditor_changes.field = /*field*/ ctx[0];
			comboboxoptionseditor.$set(comboboxoptionseditor_changes);
		},
		i(local) {
			if (current) return;
			transition_in(comboboxoptionseditor.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(comboboxoptionseditor.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(comboboxoptionseditor, detaching);
		}
	};
}

// (12:2) {#if field.type === 'string'}
function create_if_block$7(ctx) {
	let field_1;
	let current;

	field_1 = new Field({
			props: {
				field: {
					id: randomString(),
					type: "number",
					label: "Rows",
					value: {
						type: "local",
						value: /*field*/ ctx[0].rows || 1
					},
					configFieldTarget: "rows",
					configTarget: /*field*/ ctx[0].id
				}
			}
		});

	return {
		c() {
			create_component(field_1.$$.fragment);
		},
		l(nodes) {
			claim_component(field_1.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(field_1, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const field_1_changes = {};

			if (dirty & /*field*/ 1) field_1_changes.field = {
				id: randomString(),
				type: "number",
				label: "Rows",
				value: {
					type: "local",
					value: /*field*/ ctx[0].rows || 1
				},
				configFieldTarget: "rows",
				configTarget: /*field*/ ctx[0].id
			};

			field_1.$set(field_1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(field_1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(field_1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(field_1, detaching);
		}
	};
}

function create_fragment$c(ctx) {
	let div;
	let current_block_type_index;
	let if_block;
	let current;

	const if_block_creators = [
		create_if_block$7,
		create_if_block_1$4,
		create_if_block_2$1,
		create_if_block_3$1,
		create_if_block_4,
		create_if_block_5
	];

	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*field*/ ctx[0].type === "string") return 0;
		if (/*field*/ ctx[0].type === "combobox") return 1;
		if (/*field*/ ctx[0].type === "address") return 2;
		if (/*field*/ ctx[0].type === "checkbox-group") return 3;
		if (/*field*/ ctx[0].type === "radio-group") return 4;
		if (/*field*/ ctx[0].type === "switch") return 5;
		return -1;
	}

	if (~(current_block_type_index = select_block_type(ctx))) {
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	}

	return {
		c() {
			div = element("div");
			if (if_block) if_block.c();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", {});
			var div_nodes = children(div);
			if (if_block) if_block.l(div_nodes);
			div_nodes.forEach(detach);
		},
		m(target, anchor) {
			insert(target, div, anchor);

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].m(div, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if (~current_block_type_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				}
			} else {
				if (if_block) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
				}

				if (~current_block_type_index) {
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					}

					transition_in(if_block, 1);
					if_block.m(div, null);
				} else {
					if_block = null;
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].d();
			}
		}
	};
}

function instance$c($$self, $$props, $$invalidate) {
	
	let { field } = $$props;

	$$self.$$set = $$props => {
		if ("field" in $$props) $$invalidate(0, field = $$props.field);
	};

	return [field];
}

class FieldTypeEditor extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$c, create_fragment$c, safe_not_equal, { field: 0 });
	}
}

/* src\components\LogicRule.svelte generated by Svelte v3.24.1 */

function get_each_context$4(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[13] = list[i];
	child_ctx[15] = i;
	return child_ctx;
}

// (263:8) {#if field.logic?.rules?.[i]?.field}
function create_if_block_4$1(ctx) {
	let field_1;
	let current;

	field_1 = new Field({
			props: {
				config: { search: true },
				field: {
					id: randomString(),
					customCss: customCss(),
					label: "Select Your Condition",
					value: {
						type: "local",
						value: /*field*/ ctx[0].logic?.rules?.[/*i*/ ctx[15]]?.condition
					},
					type: "combobox",
					required: true,
					configFieldTarget: `logic.rules[${/*i*/ ctx[15]}].condition`,
					configTarget: /*field*/ ctx[0].id,
					options: {
						type: "local",
						value: /*conditions*/ ctx[6](/*i*/ ctx[15])
					}
				}
			}
		});

	return {
		c() {
			create_component(field_1.$$.fragment);
		},
		l(nodes) {
			claim_component(field_1.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(field_1, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const field_1_changes = {};

			if (dirty & /*field*/ 1) field_1_changes.field = {
				id: randomString(),
				customCss: customCss(),
				label: "Select Your Condition",
				value: {
					type: "local",
					value: /*field*/ ctx[0].logic?.rules?.[/*i*/ ctx[15]]?.condition
				},
				type: "combobox",
				required: true,
				configFieldTarget: `logic.rules[${/*i*/ ctx[15]}].condition`,
				configTarget: /*field*/ ctx[0].id,
				options: {
					type: "local",
					value: /*conditions*/ ctx[6](/*i*/ ctx[15])
				}
			};

			field_1.$set(field_1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(field_1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(field_1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(field_1, detaching);
		}
	};
}

// (270:8) {#if field.logic?.rules?.[i]?.condition && options[i]?.showValue}
function create_if_block_1$5(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block_2$2, create_if_block_3$2];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*options*/ ctx[2][/*i*/ ctx[15]].valueType === "text") return 0;
		if (/*options*/ ctx[2][/*i*/ ctx[15]].valueType === "combobox") return 1;
		return -1;
	}

	if (~(current_block_type_index = select_block_type(ctx))) {
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	}

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		l(nodes) {
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (~current_block_type_index) {
				if_blocks[current_block_type_index].m(target, anchor);
			}

			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if (~current_block_type_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				}
			} else {
				if (if_block) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
				}

				if (~current_block_type_index) {
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					}

					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				} else {
					if_block = null;
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (~current_block_type_index) {
				if_blocks[current_block_type_index].d(detaching);
			}

			if (detaching) detach(if_block_anchor);
		}
	};
}

// (274:56) 
function create_if_block_3$2(ctx) {
	let field_1;
	let current;

	field_1 = new Field({
			props: {
				field: {
					id: randomString(),
					customCss: customCss(),
					helperText: /*options*/ ctx[2][/*i*/ ctx[15]].helperText,
					placeholder: /*options*/ ctx[2][/*i*/ ctx[15]].placeholder,
					label: "Provide Value For Conditional",
					value: {
						type: "local",
						value: /*field*/ ctx[0].logic?.rules?.[/*i*/ ctx[15]]?.value
					},
					type: "combobox",
					required: true,
					configFieldTarget: `logic.rules[${/*i*/ ctx[15]}].value`,
					configTarget: /*field*/ ctx[0].id,
					options: {
						type: "local",
						value: /*options*/ ctx[2][/*i*/ ctx[15]].options
					}
				}
			}
		});

	return {
		c() {
			create_component(field_1.$$.fragment);
		},
		l(nodes) {
			claim_component(field_1.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(field_1, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const field_1_changes = {};

			if (dirty & /*options, field*/ 5) field_1_changes.field = {
				id: randomString(),
				customCss: customCss(),
				helperText: /*options*/ ctx[2][/*i*/ ctx[15]].helperText,
				placeholder: /*options*/ ctx[2][/*i*/ ctx[15]].placeholder,
				label: "Provide Value For Conditional",
				value: {
					type: "local",
					value: /*field*/ ctx[0].logic?.rules?.[/*i*/ ctx[15]]?.value
				},
				type: "combobox",
				required: true,
				configFieldTarget: `logic.rules[${/*i*/ ctx[15]}].value`,
				configTarget: /*field*/ ctx[0].id,
				options: {
					type: "local",
					value: /*options*/ ctx[2][/*i*/ ctx[15]].options
				}
			};

			field_1.$set(field_1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(field_1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(field_1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(field_1, detaching);
		}
	};
}

// (271:10) {#if options[i].valueType === 'text'}
function create_if_block_2$2(ctx) {
	let field_1;
	let current;

	field_1 = new Field({
			props: {
				field: {
					id: randomString(),
					customCss: customCss(),
					helperText: /*options*/ ctx[2][/*i*/ ctx[15]].helperText,
					placeholder: /*options*/ ctx[2][/*i*/ ctx[15]].placeholder,
					label: "Provide Value For Conditional",
					value: {
						type: "local",
						value: /*field*/ ctx[0].logic?.rules?.[/*i*/ ctx[15]]?.value
					},
					type: "string",
					required: true,
					configFieldTarget: `logic.rules[${/*i*/ ctx[15]}].value`,
					configTarget: /*field*/ ctx[0].id
				}
			}
		});

	return {
		c() {
			create_component(field_1.$$.fragment);
		},
		l(nodes) {
			claim_component(field_1.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(field_1, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const field_1_changes = {};

			if (dirty & /*options, field*/ 5) field_1_changes.field = {
				id: randomString(),
				customCss: customCss(),
				helperText: /*options*/ ctx[2][/*i*/ ctx[15]].helperText,
				placeholder: /*options*/ ctx[2][/*i*/ ctx[15]].placeholder,
				label: "Provide Value For Conditional",
				value: {
					type: "local",
					value: /*field*/ ctx[0].logic?.rules?.[/*i*/ ctx[15]]?.value
				},
				type: "string",
				required: true,
				configFieldTarget: `logic.rules[${/*i*/ ctx[15]}].value`,
				configTarget: /*field*/ ctx[0].id
			};

			field_1.$set(field_1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(field_1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(field_1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(field_1, detaching);
		}
	};
}

// (248:2) {#each field.logic?.rules ?? [] as option, i}
function create_each_block$4(ctx) {
	let div5;
	let div2;
	let div1;
	let div0;
	let button;
	let span1;
	let span0;
	let t0;
	let field_1;
	let t1;
	let div3;
	let t2;
	let div4;
	let t3;
	let br;
	let current;
	let mounted;
	let dispose;

	function click_handler(...args) {
		return /*click_handler*/ ctx[8](/*i*/ ctx[15], ...args);
	}

	field_1 = new Field({
			props: {
				config: { search: true },
				field: {
					id: randomString(),
					loadTransformer: /*fieldsTransformer*/ ctx[7],
					helperText: "Select which field the conditional should be ran against.",
					label: "Select Field",
					value: {
						type: "local",
						value: /*field*/ ctx[0].logic?.rules?.[/*i*/ ctx[15]]?.field
					},
					type: "combobox",
					required: true,
					configFieldTarget: `logic.rules[${/*i*/ ctx[15]}].field`,
					configTarget: /*field*/ ctx[0].id,
					options: {
						type: "local",
						value: /*getFields*/ ctx[3]
					}
				}
			}
		});

	let if_block0 = /*field*/ ctx[0].logic?.rules?.[/*i*/ ctx[15]]?.field && create_if_block_4$1(ctx);
	let if_block1 = /*field*/ ctx[0].logic?.rules?.[/*i*/ ctx[15]]?.condition && /*options*/ ctx[2][/*i*/ ctx[15]]?.showValue && create_if_block_1$5(ctx);

	return {
		c() {
			div5 = element("div");
			div2 = element("div");
			div1 = element("div");
			div0 = element("div");
			button = element("button");
			span1 = element("span");
			span0 = element("span");
			t0 = space();
			create_component(field_1.$$.fragment);
			t1 = space();
			div3 = element("div");
			if (if_block0) if_block0.c();
			t2 = space();
			div4 = element("div");
			if (if_block1) if_block1.c();
			t3 = space();
			br = element("br");
			this.h();
		},
		l(nodes) {
			div5 = claim_element(nodes, "DIV", { class: true, style: true });
			var div5_nodes = children(div5);
			div2 = claim_element(div5_nodes, "DIV", { class: true });
			var div2_nodes = children(div2);
			div1 = claim_element(div2_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			div0 = claim_element(div1_nodes, "DIV", { class: true, style: true });
			var div0_nodes = children(div0);
			button = claim_element(div0_nodes, "BUTTON", { type: true, class: true, style: true });
			var button_nodes = children(button);
			span1 = claim_element(button_nodes, "SPAN", { class: true });
			var span1_nodes = children(span1);
			span0 = claim_element(span1_nodes, "SPAN", { class: true });
			children(span0).forEach(detach);
			span1_nodes.forEach(detach);
			button_nodes.forEach(detach);
			div0_nodes.forEach(detach);
			t0 = claim_space(div1_nodes);
			claim_component(field_1.$$.fragment, div1_nodes);
			div1_nodes.forEach(detach);
			div2_nodes.forEach(detach);
			t1 = claim_space(div5_nodes);
			div3 = claim_element(div5_nodes, "DIV", { class: true });
			var div3_nodes = children(div3);
			if (if_block0) if_block0.l(div3_nodes);
			div3_nodes.forEach(detach);
			t2 = claim_space(div5_nodes);
			div4 = claim_element(div5_nodes, "DIV", { class: true });
			var div4_nodes = children(div4);
			if (if_block1) if_block1.l(div4_nodes);
			div4_nodes.forEach(detach);
			div5_nodes.forEach(detach);
			t3 = claim_space(nodes);
			br = claim_element(nodes, "BR", {});
			this.h();
		},
		h() {
			attr(span0, "class", "fas fa-trash");
			attr(span1, "class", "icon-brand");
			attr(button, "type", "button");
			attr(button, "class", "btn btn-secondary");
			set_style(button, "font-size", "0.5rem");
			set_style(button, "padding", "0.25rem 0.5rem");
			attr(div0, "class", "float-right");
			set_style(div0, "position", "relative");
			set_style(div0, "display", "inline-flex");
			set_style(div0, "vertical-align", "middle");
			set_style(div0, "top", "0.8em");
			set_style(div0, "right", "0.6em");
			attr(div1, "class", "col");
			attr(div2, "class", "row");
			attr(div3, "class", "row");
			attr(div4, "class", "row");
			attr(div5, "class", "container");
			set_style(div5, "background-color", "rgb(245 249 253)");
			set_style(div5, "padding-left", "0.3em");
			set_style(div5, "padding-right", "0.3em");
		},
		m(target, anchor) {
			insert(target, div5, anchor);
			append(div5, div2);
			append(div2, div1);
			append(div1, div0);
			append(div0, button);
			append(button, span1);
			append(span1, span0);
			append(div1, t0);
			mount_component(field_1, div1, null);
			append(div5, t1);
			append(div5, div3);
			if (if_block0) if_block0.m(div3, null);
			append(div5, t2);
			append(div5, div4);
			if (if_block1) if_block1.m(div4, null);
			insert(target, t3, anchor);
			insert(target, br, anchor);
			current = true;

			if (!mounted) {
				dispose = listen(button, "click", click_handler);
				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			const field_1_changes = {};

			if (dirty & /*field*/ 1) field_1_changes.field = {
				id: randomString(),
				loadTransformer: /*fieldsTransformer*/ ctx[7],
				helperText: "Select which field the conditional should be ran against.",
				label: "Select Field",
				value: {
					type: "local",
					value: /*field*/ ctx[0].logic?.rules?.[/*i*/ ctx[15]]?.field
				},
				type: "combobox",
				required: true,
				configFieldTarget: `logic.rules[${/*i*/ ctx[15]}].field`,
				configTarget: /*field*/ ctx[0].id,
				options: {
					type: "local",
					value: /*getFields*/ ctx[3]
				}
			};

			field_1.$set(field_1_changes);

			if (/*field*/ ctx[0].logic?.rules?.[/*i*/ ctx[15]]?.field) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty & /*field*/ 1) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_4$1(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(div3, null);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (/*field*/ ctx[0].logic?.rules?.[/*i*/ ctx[15]]?.condition && /*options*/ ctx[2][/*i*/ ctx[15]]?.showValue) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty & /*field, options*/ 5) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_1$5(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div4, null);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(field_1.$$.fragment, local);
			transition_in(if_block0);
			transition_in(if_block1);
			current = true;
		},
		o(local) {
			transition_out(field_1.$$.fragment, local);
			transition_out(if_block0);
			transition_out(if_block1);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div5);
			destroy_component(field_1);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (detaching) detach(t3);
			if (detaching) detach(br);
			mounted = false;
			dispose();
		}
	};
}

// (283:2) {#if helperText}
function create_if_block$8(ctx) {
	let div;
	let raw_value = (/*helperText*/ ctx[1] ?? "") + "";

	return {
		c() {
			div = element("div");
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "helper-text");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			div.innerHTML = raw_value;
		},
		p(ctx, dirty) {
			if (dirty & /*helperText*/ 2 && raw_value !== (raw_value = (/*helperText*/ ctx[1] ?? "") + "")) div.innerHTML = raw_value;		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

function create_fragment$d(ctx) {
	let div;
	let t0;
	let t1;
	let button;
	let t2;
	let current;
	let mounted;
	let dispose;
	let each_value = /*field*/ ctx[0].logic?.rules ?? [];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$4(get_each_context$4(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	let if_block = /*helperText*/ ctx[1] && create_if_block$8(ctx);

	return {
		c() {
			div = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t0 = space();
			if (if_block) if_block.c();
			t1 = space();
			button = element("button");
			t2 = text("Add Rule");
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", {});
			var div_nodes = children(div);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(div_nodes);
			}

			t0 = claim_space(div_nodes);
			if (if_block) if_block.l(div_nodes);
			t1 = claim_space(div_nodes);
			button = claim_element(div_nodes, "BUTTON", { class: true, style: true });
			var button_nodes = children(button);
			t2 = claim_text(button_nodes, "Add Rule");
			button_nodes.forEach(detach);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(button, "class", "btn-primary btn");
		},
		m(target, anchor) {
			insert(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}

			append(div, t0);
			if (if_block) if_block.m(div, null);
			append(div, t1);
			append(div, button);
			append(button, t2);
			current = true;

			if (!mounted) {
				dispose = listen(button, "click", /*addNew*/ ctx[5]);
				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (dirty & /*randomString, customCss, options, field, conditions, fieldsTransformer, getFields, remove*/ 221) {
				each_value = /*field*/ ctx[0].logic?.rules ?? [];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$4(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block$4(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(div, t0);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}

			if (/*helperText*/ ctx[1]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$8(ctx);
					if_block.c();
					if_block.m(div, t1);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_each(each_blocks, detaching);
			if (if_block) if_block.d();
			mounted = false;
			dispose();
		}
	};
}

function customCss() {
	return "padding-top: 0em; padding-left: 0.6em; padding-right: 0.6em; padding-bottom: 0.7em;";
}

function instance$d($$self, $$props, $$invalidate) {
	var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
		function adopt(value) {
			return value instanceof P
			? value
			: new P(function (resolve) {
						resolve(value);
					});
		}

		return new (P || (P = Promise))(function (resolve, reject) {
				function fulfilled(value) {
					try {
						step(generator.next(value));
					} catch(e) {
						reject(e);
					}
				}

				function rejected(value) {
					try {
						step(generator["throw"](value));
					} catch(e) {
						reject(e);
					}
				}

				function step(result) {
					result.done
					? resolve(result.value)
					: adopt(result.value).then(fulfilled, rejected);
				}

				step((generator = generator.apply(thisArg, _arguments || [])).next());
			});
	};

	
	
	
	let { helperText = "" } = $$props;
	let { field } = $$props;
	let options = [];

	onMount(() => __awaiter(void 0, void 0, void 0, function* () {
		subscribeFieldChange((newField, change) => {
			var _a, _b, _c;

			if (change.field === "value") {
				return;
			}

			if (field.id === newField.id) {
				$$invalidate(0, field = newField);

				if (((_a = field.logic) === null || _a === void 0
				? void 0
				: _a.action) && isEmptyOrNull((_b = field.logic) === null || _b === void 0
				? void 0
				: _b.rules)) {
					addNew();
				}

				if ((_c = field.logic) === null || _c === void 0
				? void 0
				: _c.rules) {
					field.logic.rules.forEach((f, i) => {
						$$invalidate(2, options[i] = getOptions(i), options);
					});
				}
			}
		});
	}));

	function getFields() {
		let fields = dispatchSingle("get_form_fields", {});
		fields = fields.filter(w => w.id !== field.id && w.type !== "spacer");
		return fields;
	}

	function remove(option) {
		const temp = fastClone(field.logic.rules);
		temp.splice(option, 1);
		$$invalidate(0, field.logic.rules = temp, field);
		formStore.set(field);
	}

	function addNew() {
		var _a, _b;

		if (!((_a = field.logic) === null || _a === void 0
		? void 0
		: _a.rules)) {
			$$invalidate(
				0,
				field.logic = (_b = field.logic) !== null && _b !== void 0
				? _b
				: { rules: [], action: "" },
				field
			);

			$$invalidate(0, field.logic.rules = [], field);
		}

		$$invalidate(0, field.logic.rules = field.logic.rules.concat([{ field: "", value: "", condition: "" }]), field);
		formStore.set(field);
	}

	function shouldShowValue(index) {
		var _a, _b, _c, _d;

		const condition = (_d = (_c = (_b = (_a = field.logic) === null || _a === void 0
		? void 0
		: _a.rules) === null || _b === void 0
		? void 0
		: _b[index]) === null || _c === void 0
		? void 0
		: _c.condition) !== null && _d !== void 0
		? _d
		: "";

		const toNotShow = ["hasValue", "isTrue", "isFalse", "notHaveValue"];

		if (toNotShow.includes(condition)) {
			return false;
		}

		return true;
	}

	function getOptions(index) {
		var _a, _b, _c, _d, _e, _f;

		const value = (_c = (_b = (_a = field.logic) === null || _a === void 0
		? void 0
		: _a.rules) === null || _b === void 0
		? void 0
		: _b[index]) === null || _c === void 0
		? void 0
		: _c.condition;

		const condition = conditions(index).find(w => w.value === value);

		if (!condition) {
			return {
				valueType: "text",
				showValue: false,
				options: () => Promise.resolve([]),
				helperText: "",
				placeholder: ""
			};
		}

		return {
			valueType: (_d = condition.valueInput) !== null && _d !== void 0
			? _d
			: "text",
			showValue: shouldShowValue(index),
			options: () => loadOptions(index),
			helperText: (_e = condition.helper) !== null && _e !== void 0
			? _e
			: "",
			placeholder: (_f = condition.placeholder) !== null && _f !== void 0
			? _f
			: ""
		};
	}

	function loadOptions(index) {
		var _a, _b, _c;

		const id = (_c = (_b = (_a = field.logic) === null || _a === void 0
		? void 0
		: _a.rules) === null || _b === void 0
		? void 0
		: _b[index]) === null || _c === void 0
		? void 0
		: _c.field;

		if (!id) {
			return Promise.resolve([]);
		}

		return dispatchSingle("combobox_get_options", { id });
	}

	function conditions(index) {
		var _a, _b, _c;

		const targetFieldId = (_c = (_b = (_a = field.logic) === null || _a === void 0
		? void 0
		: _a.rules) === null || _b === void 0
		? void 0
		: _b[index]) === null || _c === void 0
		? void 0
		: _c.field;

		if (!targetFieldId) {
			return [];
		}

		const fields = getFields();
		const targetField = fields.find(w => w.id === targetFieldId);

		if (!targetField) {
			return [];
		}

		if (targetField.type === "string") {
			return [
				{ label: "Contains", value: "contains" },
				{
					label: "Starts With",
					value: "startsWith"
				},
				{ label: "Ends With", value: "endsWith" },
				{ label: "Equals", value: "eq" },
				{ label: "Has Value", value: "hasValue" }
			];
		}

		if (targetField.type === "combobox") {
			return [
				{
					label: "Equals",
					value: "eq",
					valueInput: "combobox",
					options: loadOptions
				},
				{
					label: "Not Equals",
					value: "notEq",
					valueInput: "combobox",
					options: loadOptions
				},
				{
					label: "Has Selected Option",
					value: "hasValue"
				}
			];
		}

		if (targetField.type === "switch") {
			return [
				{ label: "Is Toggled", value: "isTrue" },
				{
					label: "Is Not Toggled",
					value: "isFalse"
				}
			];
		}

		if (targetField.type === "file") {
			return [
				{
					label: "Has Chosen File",
					value: "hasValue"
				},
				{
					label: "Has Not Chosen File",
					value: "notHaveValue"
				},
				{
					label: "Is File Extension",
					value: "isFileExtension",
					helper: "You can include multiple extensions by seperating with a comma.",
					placeholder: "pdf, txt, png"
				},
				{
					label: "Is Not File Extension",
					helper: "You can include multiple extensions by seperating with a comma.",
					value: "isNotFileExtension",
					placeholder: "pdf, txt, png"
				}
			];
		}

		if (targetField.type === "number") {
			return [
				{ label: "Greater Than", value: "gt" },
				{ label: "Less Than", value: "lt" },
				{
					label: "Less Than or Equal To",
					value: "lte"
				},
				{
					label: "Greater Than or Equal To",
					value: "gte"
				},
				{ label: "Equal To", value: "eq" },
				{ label: "Has Value", value: "hasValue" }
			];
		}

		return [];
	}

	function fieldsTransformer(fields) {
		return fields.map(f => {
			return {
				label: `${firstNotEmpty(f.label, f.name)} - ${f.type}`,
				value: f.id
			};
		});
	}

	const click_handler = i => remove(i);

	$$self.$$set = $$props => {
		if ("helperText" in $$props) $$invalidate(1, helperText = $$props.helperText);
		if ("field" in $$props) $$invalidate(0, field = $$props.field);
	};

	return [
		field,
		helperText,
		options,
		getFields,
		remove,
		addNew,
		conditions,
		fieldsTransformer,
		click_handler
	];
}

class LogicRule extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$d, create_fragment$d, safe_not_equal, { helperText: 1, field: 0 });
	}
}

/* src\features\form\edit\LogicBuilder.svelte generated by Svelte v3.24.1 */

function create_fragment$e(ctx) {
	let field_1;
	let t0;
	let hr;
	let t1;
	let logicrule;
	let current;

	field_1 = new Field({
			props: {
				field: {
					id: randomString(),
					label: "Select Action",
					helperText: "What should happen when all or some of your rules are matched.",
					value: {
						type: "local",
						value: /*field*/ ctx[0].logic?.action
					},
					type: "combobox",
					required: true,
					configFieldTarget: "logic.action",
					configTarget: /*field*/ ctx[0].id,
					options: { type: "local", value: /*actions*/ ctx[1] }
				},
				padding: false
			}
		});

	logicrule = new LogicRule({ props: { field: /*field*/ ctx[0] } });

	return {
		c() {
			create_component(field_1.$$.fragment);
			t0 = space();
			hr = element("hr");
			t1 = space();
			create_component(logicrule.$$.fragment);
		},
		l(nodes) {
			claim_component(field_1.$$.fragment, nodes);
			t0 = claim_space(nodes);
			hr = claim_element(nodes, "HR", {});
			t1 = claim_space(nodes);
			claim_component(logicrule.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(field_1, target, anchor);
			insert(target, t0, anchor);
			insert(target, hr, anchor);
			insert(target, t1, anchor);
			mount_component(logicrule, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const field_1_changes = {};

			if (dirty & /*field*/ 1) field_1_changes.field = {
				id: randomString(),
				label: "Select Action",
				helperText: "What should happen when all or some of your rules are matched.",
				value: {
					type: "local",
					value: /*field*/ ctx[0].logic?.action
				},
				type: "combobox",
				required: true,
				configFieldTarget: "logic.action",
				configTarget: /*field*/ ctx[0].id,
				options: { type: "local", value: /*actions*/ ctx[1] }
			};

			field_1.$set(field_1_changes);
			const logicrule_changes = {};
			if (dirty & /*field*/ 1) logicrule_changes.field = /*field*/ ctx[0];
			logicrule.$set(logicrule_changes);
		},
		i(local) {
			if (current) return;
			transition_in(field_1.$$.fragment, local);
			transition_in(logicrule.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(field_1.$$.fragment, local);
			transition_out(logicrule.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(field_1, detaching);
			if (detaching) detach(t0);
			if (detaching) detach(hr);
			if (detaching) detach(t1);
			destroy_component(logicrule, detaching);
		}
	};
}

function instance$e($$self, $$props, $$invalidate) {
	
	let { field } = $$props;

	const actions = [
		{
			label: "Show this field when all rule(s) match",
			value: "show-all-match"
		},
		{
			label: "Show this field when any rule(s) match",
			value: "show-any-match"
		},
		{
			label: "Hide this field when any rule(s) match",
			value: "hide-any-match"
		},
		{
			label: "Hide this field when all rule(s) match",
			value: "hide-all-match"
		}
	];

	$$self.$$set = $$props => {
		if ("field" in $$props) $$invalidate(0, field = $$props.field);
	};

	return [field, actions];
}

class LogicBuilder extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$e, create_fragment$e, safe_not_equal, { field: 0 });
	}
}

/* src\features\form\edit\LogicAccordion.svelte generated by Svelte v3.24.1 */

function create_fragment$f(ctx) {
	let div4;
	let div3;
	let div0;
	let h2;
	let button;
	let span0;
	let t0;
	let t1;
	let span2;
	let span1;
	let t2;
	let div2;
	let div1;
	let p;
	let logicbuilder;
	let current;
	logicbuilder = new LogicBuilder({ props: { field: /*field*/ ctx[0] } });

	return {
		c() {
			div4 = element("div");
			div3 = element("div");
			div0 = element("div");
			h2 = element("h2");
			button = element("button");
			span0 = element("span");
			t0 = text("Logic");
			t1 = space();
			span2 = element("span");
			span1 = element("span");
			t2 = space();
			div2 = element("div");
			div1 = element("div");
			p = element("p");
			create_component(logicbuilder.$$.fragment);
			this.h();
		},
		l(nodes) {
			div4 = claim_element(nodes, "DIV", { class: true, id: true, style: true });
			var div4_nodes = children(div4);
			div3 = claim_element(div4_nodes, "DIV", { class: true });
			var div3_nodes = children(div3);
			div0 = claim_element(div3_nodes, "DIV", { class: true, id: true });
			var div0_nodes = children(div0);
			h2 = claim_element(div0_nodes, "H2", { class: true });
			var h2_nodes = children(h2);

			button = claim_element(h2_nodes, "BUTTON", {
				class: true,
				type: true,
				"data-toggle": true,
				"data-target": true,
				"aria-expanded": true,
				"aria-controls": true
			});

			var button_nodes = children(button);
			span0 = claim_element(button_nodes, "SPAN", { class: true });
			var span0_nodes = children(span0);
			t0 = claim_text(span0_nodes, "Logic");
			span0_nodes.forEach(detach);
			t1 = claim_space(button_nodes);
			span2 = claim_element(button_nodes, "SPAN", { class: true });
			var span2_nodes = children(span2);
			span1 = claim_element(span2_nodes, "SPAN", { class: true, style: true });
			children(span1).forEach(detach);
			span2_nodes.forEach(detach);
			button_nodes.forEach(detach);
			h2_nodes.forEach(detach);
			div0_nodes.forEach(detach);
			t2 = claim_space(div3_nodes);

			div2 = claim_element(div3_nodes, "DIV", {
				id: true,
				class: true,
				"aria-labelledby": true,
				"data-parent": true
			});

			var div2_nodes = children(div2);
			div1 = claim_element(div2_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			p = claim_element(div1_nodes, "P", { class: true });
			var p_nodes = children(p);
			claim_component(logicbuilder.$$.fragment, p_nodes);
			p_nodes.forEach(detach);
			div1_nodes.forEach(detach);
			div2_nodes.forEach(detach);
			div3_nodes.forEach(detach);
			div4_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(span0, "class", "h6 mb-0 font-weight-bold");
			attr(span1, "class", "fas fa-plus");
			set_style(span1, "font-size", "1em");
			attr(span2, "class", "icon");
			attr(button, "class", "btn btn-link btn-block d-flex justify-content-between text-left");
			attr(button, "type", "button");
			attr(button, "data-toggle", "collapse");
			attr(button, "data-target", "#collapseOne");
			attr(button, "aria-expanded", "false");
			attr(button, "aria-controls", "collapseOne");
			attr(h2, "class", "mb-0");
			attr(div0, "class", "card-header accordionHeader svelte-1jod1ik");
			attr(div0, "id", "headingOne");
			attr(p, "class", "mb-0");
			attr(div1, "class", "card-body svelte-1jod1ik");
			attr(div2, "id", "collapseOne");
			attr(div2, "class", "collapse accordionCollapse svelte-1jod1ik");
			attr(div2, "aria-labelledby", "headingOne");
			attr(div2, "data-parent", "#accordionLogic");
			attr(div3, "class", "card border-light mb-0 svelte-1jod1ik");
			attr(div4, "class", "accordion mt-4 svelte-1jod1ik");
			attr(div4, "id", "accordionLogic");
			set_style(div4, "margin-bottom", "1em");
		},
		m(target, anchor) {
			insert(target, div4, anchor);
			append(div4, div3);
			append(div3, div0);
			append(div0, h2);
			append(h2, button);
			append(button, span0);
			append(span0, t0);
			append(button, t1);
			append(button, span2);
			append(span2, span1);
			append(div3, t2);
			append(div3, div2);
			append(div2, div1);
			append(div1, p);
			mount_component(logicbuilder, p, null);
			current = true;
		},
		p(ctx, [dirty]) {
			const logicbuilder_changes = {};
			if (dirty & /*field*/ 1) logicbuilder_changes.field = /*field*/ ctx[0];
			logicbuilder.$set(logicbuilder_changes);
		},
		i(local) {
			if (current) return;
			transition_in(logicbuilder.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(logicbuilder.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div4);
			destroy_component(logicbuilder);
		}
	};
}

function instance$f($$self, $$props, $$invalidate) {
	
	let { field } = $$props;

	$$self.$$set = $$props => {
		if ("field" in $$props) $$invalidate(0, field = $$props.field);
	};

	return [field];
}

class LogicAccordion extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$f, create_fragment$f, safe_not_equal, { field: 0 });
	}
}

/* src\features\form\edit\ContentBlockEditor.svelte generated by Svelte v3.24.1 */

function create_fragment$g(ctx) {
	let div2;
	let div0;
	let h5;
	let t0;
	let t1;
	let hr;
	let t2;
	let field_1;
	let t3;
	let div1;
	let button0;
	let t4;
	let t5;
	let button1;
	let t6;
	let current;

	field_1 = new Field({
			props: {
				editor: true,
				padding: false,
				field: {
					id: randomString(),
					type: "block-editor",
					value: /*field*/ ctx[0].value,
					configTarget: /*field*/ ctx[0].id,
					configFieldTarget: "value"
				}
			}
		});

	return {
		c() {
			div2 = element("div");
			div0 = element("div");
			h5 = element("h5");
			t0 = text("Content Block Settings");
			t1 = space();
			hr = element("hr");
			t2 = space();
			create_component(field_1.$$.fragment);
			t3 = space();
			div1 = element("div");
			button0 = element("button");
			t4 = text("Select Block");
			t5 = space();
			button1 = element("button");
			t6 = text("Save Block");
			this.h();
		},
		l(nodes) {
			div2 = claim_element(nodes, "DIV", {});
			var div2_nodes = children(div2);
			div0 = claim_element(div2_nodes, "DIV", { style: true });
			var div0_nodes = children(div0);
			h5 = claim_element(div0_nodes, "H5", { style: true });
			var h5_nodes = children(h5);
			t0 = claim_text(h5_nodes, "Content Block Settings");
			h5_nodes.forEach(detach);
			t1 = claim_space(div0_nodes);
			hr = claim_element(div0_nodes, "HR", {});
			div0_nodes.forEach(detach);
			t2 = claim_space(div2_nodes);
			claim_component(field_1.$$.fragment, div2_nodes);
			t3 = claim_space(div2_nodes);
			div1 = claim_element(div2_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			button0 = claim_element(div1_nodes, "BUTTON", { class: true, type: true });
			var button0_nodes = children(button0);
			t4 = claim_text(button0_nodes, "Select Block");
			button0_nodes.forEach(detach);
			t5 = claim_space(div1_nodes);
			button1 = claim_element(div1_nodes, "BUTTON", { class: true, type: true });
			var button1_nodes = children(button1);
			t6 = claim_text(button1_nodes, "Save Block");
			button1_nodes.forEach(detach);
			div1_nodes.forEach(detach);
			div2_nodes.forEach(detach);
			this.h();
		},
		h() {
			set_style(h5, "padding-bottom", "0.2em");
			set_style(div0, "padding-left", "0.5em");
			attr(button0, "class", "blocks-button btn btn-light svelte-ps6so1");
			attr(button0, "type", "button");
			attr(button1, "class", "blocks-button btn btn-light svelte-ps6so1");
			attr(button1, "type", "button");
			attr(div1, "class", "flex");
		},
		m(target, anchor) {
			insert(target, div2, anchor);
			append(div2, div0);
			append(div0, h5);
			append(h5, t0);
			append(div0, t1);
			append(div0, hr);
			append(div2, t2);
			mount_component(field_1, div2, null);
			append(div2, t3);
			append(div2, div1);
			append(div1, button0);
			append(button0, t4);
			append(div1, t5);
			append(div1, button1);
			append(button1, t6);
			current = true;
		},
		p(ctx, [dirty]) {
			const field_1_changes = {};

			if (dirty & /*field*/ 1) field_1_changes.field = {
				id: randomString(),
				type: "block-editor",
				value: /*field*/ ctx[0].value,
				configTarget: /*field*/ ctx[0].id,
				configFieldTarget: "value"
			};

			field_1.$set(field_1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(field_1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(field_1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div2);
			destroy_component(field_1);
		}
	};
}

function instance$g($$self, $$props, $$invalidate) {
	
	
	let { field } = $$props;
	let { expanded } = $$props;

	$$self.$$set = $$props => {
		if ("field" in $$props) $$invalidate(0, field = $$props.field);
		if ("expanded" in $$props) $$invalidate(1, expanded = $$props.expanded);
	};

	return [field, expanded];
}

class ContentBlockEditor extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$g, create_fragment$g, safe_not_equal, { field: 0, expanded: 1 });
	}
}

/* src\features\form\edit\GroupDetails.svelte generated by Svelte v3.24.1 */

function create_fragment$h(ctx) {
	let div1;
	let field_1;
	let t0;
	let div0;
	let button;
	let span;
	let t1;
	let current;
	let mounted;
	let dispose;

	field_1 = new Field({
			props: {
				config: { search: true },
				field: {
					id: randomString(),
					label: "Specify Group",
					helperText: "Link fields together via a group",
					value: {
						type: "local",
						value: /*field*/ ctx[0].groupId
					},
					type: "combobox",
					required: true,
					configFieldTarget: `groupId`,
					configTarget: /*field*/ ctx[0].id,
					options: {
						type: "local",
						value: /*getGroups*/ ctx[1]
					}
				}
			}
		});

	return {
		c() {
			div1 = element("div");
			create_component(field_1.$$.fragment);
			t0 = space();
			div0 = element("div");
			button = element("button");
			span = element("span");
			t1 = text("\r\n    Group Settings");
			this.h();
		},
		l(nodes) {
			div1 = claim_element(nodes, "DIV", {});
			var div1_nodes = children(div1);
			claim_component(field_1.$$.fragment, div1_nodes);
			t0 = claim_space(div1_nodes);
			div0 = claim_element(div1_nodes, "DIV", { class: true, style: true });
			var div0_nodes = children(div0);
			button = claim_element(div0_nodes, "BUTTON", { target: true, class: true });
			var button_nodes = children(button);
			span = claim_element(button_nodes, "SPAN", { class: true });
			children(span).forEach(detach);
			t1 = claim_text(button_nodes, "\r\n    Group Settings");
			button_nodes.forEach(detach);
			div0_nodes.forEach(detach);
			div1_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(span, "class", "fas fa-cog");
			attr(button, "target", "_blank");
			attr(button, "class", "btn btn-sm btn-outline-dark");
			attr(div0, "class", "d-flex bd-highlight justify-end");
			set_style(div0, "padding", ".75em 0.6em");
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			mount_component(field_1, div1, null);
			append(div1, t0);
			append(div1, div0);
			append(div0, button);
			append(button, span);
			append(button, t1);
			current = true;

			if (!mounted) {
				dispose = listen(button, "click", /*onGroupSettings*/ ctx[2]);
				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			const field_1_changes = {};

			if (dirty & /*field*/ 1) field_1_changes.field = {
				id: randomString(),
				label: "Specify Group",
				helperText: "Link fields together via a group",
				value: {
					type: "local",
					value: /*field*/ ctx[0].groupId
				},
				type: "combobox",
				required: true,
				configFieldTarget: `groupId`,
				configTarget: /*field*/ ctx[0].id,
				options: {
					type: "local",
					value: /*getGroups*/ ctx[1]
				}
			};

			field_1.$set(field_1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(field_1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(field_1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div1);
			destroy_component(field_1);
			mounted = false;
			dispose();
		}
	};
}

function instance$h($$self, $$props, $$invalidate) {
	
	let { field } = $$props;

	function getGroups() {
		var _a;
		let form = formStore.getForm();
		return (_a = form.groups) !== null && _a !== void 0 ? _a : [];
	}

	function onGroupSettings() {
		dispatch("show_right_sidebar", {
			component: GroupEditSidebar,
			groupId: field.groupId
		});
	}

	onMount(() => {
		
	});

	$$self.$$set = $$props => {
		if ("field" in $$props) $$invalidate(0, field = $$props.field);
	};

	return [field, getGroups, onGroupSettings];
}

class GroupDetails extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$h, create_fragment$h, safe_not_equal, { field: 0 });
	}
}

/* src\features\form\edit\GroupAccordion.svelte generated by Svelte v3.24.1 */

function create_fragment$i(ctx) {
	let div4;
	let div3;
	let div0;
	let h2;
	let button;
	let span0;
	let t0;
	let t1;
	let span2;
	let span1;
	let t2;
	let div2;
	let div1;
	let p;
	let groupdetails;
	let current;
	groupdetails = new GroupDetails({ props: { field: /*field*/ ctx[0] } });

	return {
		c() {
			div4 = element("div");
			div3 = element("div");
			div0 = element("div");
			h2 = element("h2");
			button = element("button");
			span0 = element("span");
			t0 = text("Group");
			t1 = space();
			span2 = element("span");
			span1 = element("span");
			t2 = space();
			div2 = element("div");
			div1 = element("div");
			p = element("p");
			create_component(groupdetails.$$.fragment);
			this.h();
		},
		l(nodes) {
			div4 = claim_element(nodes, "DIV", { class: true, id: true, style: true });
			var div4_nodes = children(div4);
			div3 = claim_element(div4_nodes, "DIV", { class: true });
			var div3_nodes = children(div3);
			div0 = claim_element(div3_nodes, "DIV", { class: true, id: true });
			var div0_nodes = children(div0);
			h2 = claim_element(div0_nodes, "H2", { class: true });
			var h2_nodes = children(h2);

			button = claim_element(h2_nodes, "BUTTON", {
				class: true,
				type: true,
				"data-toggle": true,
				"data-target": true,
				"aria-expanded": true,
				"aria-controls": true
			});

			var button_nodes = children(button);
			span0 = claim_element(button_nodes, "SPAN", { class: true });
			var span0_nodes = children(span0);
			t0 = claim_text(span0_nodes, "Group");
			span0_nodes.forEach(detach);
			t1 = claim_space(button_nodes);
			span2 = claim_element(button_nodes, "SPAN", { class: true });
			var span2_nodes = children(span2);
			span1 = claim_element(span2_nodes, "SPAN", { class: true, style: true });
			children(span1).forEach(detach);
			span2_nodes.forEach(detach);
			button_nodes.forEach(detach);
			h2_nodes.forEach(detach);
			div0_nodes.forEach(detach);
			t2 = claim_space(div3_nodes);

			div2 = claim_element(div3_nodes, "DIV", {
				id: true,
				class: true,
				"aria-labelledby": true,
				"data-parent": true
			});

			var div2_nodes = children(div2);
			div1 = claim_element(div2_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			p = claim_element(div1_nodes, "P", { class: true });
			var p_nodes = children(p);
			claim_component(groupdetails.$$.fragment, p_nodes);
			p_nodes.forEach(detach);
			div1_nodes.forEach(detach);
			div2_nodes.forEach(detach);
			div3_nodes.forEach(detach);
			div4_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(span0, "class", "h6 mb-0 font-weight-bold");
			attr(span1, "class", "fas fa-plus");
			set_style(span1, "font-size", "1em");
			attr(span2, "class", "icon");
			attr(button, "class", "btn btn-link btn-block d-flex justify-content-between text-left");
			attr(button, "type", "button");
			attr(button, "data-toggle", "collapse");
			attr(button, "data-target", "#collapseTwo");
			attr(button, "aria-expanded", "false");
			attr(button, "aria-controls", "collapseTwo");
			attr(h2, "class", "mb-0");
			attr(div0, "class", "card-header accordionHeader svelte-12yv0lm");
			attr(div0, "id", "headingTwo");
			attr(p, "class", "mb-0");
			attr(div1, "class", "card-body svelte-12yv0lm");
			attr(div2, "id", "collapseTwo");
			attr(div2, "class", "collapse accordionCollapse svelte-12yv0lm");
			attr(div2, "aria-labelledby", "headingTwo");
			attr(div2, "data-parent", "#accordionGroup");
			attr(div3, "class", "card border-light mb-0 svelte-12yv0lm");
			attr(div4, "class", "accordion svelte-12yv0lm");
			attr(div4, "id", "accordionGroup");
			set_style(div4, "margin-bottom", "3rem");
		},
		m(target, anchor) {
			insert(target, div4, anchor);
			append(div4, div3);
			append(div3, div0);
			append(div0, h2);
			append(h2, button);
			append(button, span0);
			append(span0, t0);
			append(button, t1);
			append(button, span2);
			append(span2, span1);
			append(div3, t2);
			append(div3, div2);
			append(div2, div1);
			append(div1, p);
			mount_component(groupdetails, p, null);
			current = true;
		},
		p(ctx, [dirty]) {
			const groupdetails_changes = {};
			if (dirty & /*field*/ 1) groupdetails_changes.field = /*field*/ ctx[0];
			groupdetails.$set(groupdetails_changes);
		},
		i(local) {
			if (current) return;
			transition_in(groupdetails.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(groupdetails.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div4);
			destroy_component(groupdetails);
		}
	};
}

function instance$i($$self, $$props, $$invalidate) {
	
	let { field } = $$props;

	$$self.$$set = $$props => {
		if ("field" in $$props) $$invalidate(0, field = $$props.field);
	};

	return [field];
}

class GroupAccordion extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$i, create_fragment$i, safe_not_equal, { field: 0 });
	}
}

/* src\features\form\edit\FieldEdit.svelte generated by Svelte v3.24.1 */

function create_else_block$7(ctx) {
	let div0;
	let h5;
	let t0;
	let t1;
	let hr;
	let t2;
	let div1;
	let show_if = !/*cantBeRequired*/ ctx[1].includes(/*field*/ ctx[0].type);
	let t3;
	let field0;
	let t4;
	let field1;
	let t5;
	let field2;
	let t6;
	let field3;
	let t7;
	let fieldtypeeditor;
	let div1_id_value;
	let current;
	let if_block = show_if && create_if_block_2$3(ctx);

	field0 = new Field({
			props: {
				field: {
					id: randomString(),
					label: "Name",
					required: true,
					value: /*field*/ ctx[0].name,
					type: "string",
					configFieldTarget: "name",
					configTarget: /*field*/ ctx[0].id
				}
			}
		});

	field1 = new Field({
			props: {
				field: {
					id: randomString(),
					label: "Label",
					value: /*field*/ ctx[0].label,
					type: "string",
					configFieldTarget: "label",
					configTarget: /*field*/ ctx[0].id
				}
			}
		});

	field2 = new Field({
			props: {
				field: {
					id: randomString(),
					label: "Helper Text",
					value: /*field*/ ctx[0].helperText,
					type: "string",
					configFieldTarget: "helperText",
					configTarget: /*field*/ ctx[0].id
				}
			}
		});

	field3 = new Field({
			props: {
				field: {
					id: randomString(),
					label: "Field Type",
					value: {
						type: "local",
						value: /*field*/ ctx[0].type
					},
					type: "combobox",
					required: true,
					configFieldTarget: "type",
					configTarget: /*field*/ ctx[0].id,
					options: {
						type: "remote",
						value: "http://localhost:8080/field-types.json"
					}
				}
			}
		});

	fieldtypeeditor = new FieldTypeEditor({ props: { field: /*field*/ ctx[0] } });

	return {
		c() {
			div0 = element("div");
			h5 = element("h5");
			t0 = text("Field Settings");
			t1 = space();
			hr = element("hr");
			t2 = space();
			div1 = element("div");
			if (if_block) if_block.c();
			t3 = space();
			create_component(field0.$$.fragment);
			t4 = space();
			create_component(field1.$$.fragment);
			t5 = space();
			create_component(field2.$$.fragment);
			t6 = space();
			create_component(field3.$$.fragment);
			t7 = space();
			create_component(fieldtypeeditor.$$.fragment);
			this.h();
		},
		l(nodes) {
			div0 = claim_element(nodes, "DIV", { style: true });
			var div0_nodes = children(div0);
			h5 = claim_element(div0_nodes, "H5", { style: true });
			var h5_nodes = children(h5);
			t0 = claim_text(h5_nodes, "Field Settings");
			h5_nodes.forEach(detach);
			t1 = claim_space(div0_nodes);
			hr = claim_element(div0_nodes, "HR", {});
			div0_nodes.forEach(detach);
			t2 = claim_space(nodes);
			div1 = claim_element(nodes, "DIV", { id: true });
			var div1_nodes = children(div1);
			if (if_block) if_block.l(div1_nodes);
			t3 = claim_space(div1_nodes);
			claim_component(field0.$$.fragment, div1_nodes);
			t4 = claim_space(div1_nodes);
			claim_component(field1.$$.fragment, div1_nodes);
			t5 = claim_space(div1_nodes);
			claim_component(field2.$$.fragment, div1_nodes);
			t6 = claim_space(div1_nodes);
			claim_component(field3.$$.fragment, div1_nodes);
			t7 = claim_space(div1_nodes);
			claim_component(fieldtypeeditor.$$.fragment, div1_nodes);
			div1_nodes.forEach(detach);
			this.h();
		},
		h() {
			set_style(h5, "padding-bottom", "0.2em");
			set_style(div0, "padding-left", "0.5em");
			attr(div1, "id", div1_id_value = `field-button-${/*field*/ ctx[0].id}`);
		},
		m(target, anchor) {
			insert(target, div0, anchor);
			append(div0, h5);
			append(h5, t0);
			append(div0, t1);
			append(div0, hr);
			insert(target, t2, anchor);
			insert(target, div1, anchor);
			if (if_block) if_block.m(div1, null);
			append(div1, t3);
			mount_component(field0, div1, null);
			append(div1, t4);
			mount_component(field1, div1, null);
			append(div1, t5);
			mount_component(field2, div1, null);
			append(div1, t6);
			mount_component(field3, div1, null);
			append(div1, t7);
			mount_component(fieldtypeeditor, div1, null);
			current = true;
		},
		p(ctx, dirty) {
			if (dirty & /*field*/ 1) show_if = !/*cantBeRequired*/ ctx[1].includes(/*field*/ ctx[0].type);

			if (show_if) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*field*/ 1) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_2$3(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(div1, t3);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			const field0_changes = {};

			if (dirty & /*field*/ 1) field0_changes.field = {
				id: randomString(),
				label: "Name",
				required: true,
				value: /*field*/ ctx[0].name,
				type: "string",
				configFieldTarget: "name",
				configTarget: /*field*/ ctx[0].id
			};

			field0.$set(field0_changes);
			const field1_changes = {};

			if (dirty & /*field*/ 1) field1_changes.field = {
				id: randomString(),
				label: "Label",
				value: /*field*/ ctx[0].label,
				type: "string",
				configFieldTarget: "label",
				configTarget: /*field*/ ctx[0].id
			};

			field1.$set(field1_changes);
			const field2_changes = {};

			if (dirty & /*field*/ 1) field2_changes.field = {
				id: randomString(),
				label: "Helper Text",
				value: /*field*/ ctx[0].helperText,
				type: "string",
				configFieldTarget: "helperText",
				configTarget: /*field*/ ctx[0].id
			};

			field2.$set(field2_changes);
			const field3_changes = {};

			if (dirty & /*field*/ 1) field3_changes.field = {
				id: randomString(),
				label: "Field Type",
				value: {
					type: "local",
					value: /*field*/ ctx[0].type
				},
				type: "combobox",
				required: true,
				configFieldTarget: "type",
				configTarget: /*field*/ ctx[0].id,
				options: {
					type: "remote",
					value: "http://localhost:8080/field-types.json"
				}
			};

			field3.$set(field3_changes);
			const fieldtypeeditor_changes = {};
			if (dirty & /*field*/ 1) fieldtypeeditor_changes.field = /*field*/ ctx[0];
			fieldtypeeditor.$set(fieldtypeeditor_changes);

			if (!current || dirty & /*field*/ 1 && div1_id_value !== (div1_id_value = `field-button-${/*field*/ ctx[0].id}`)) {
				attr(div1, "id", div1_id_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			transition_in(field0.$$.fragment, local);
			transition_in(field1.$$.fragment, local);
			transition_in(field2.$$.fragment, local);
			transition_in(field3.$$.fragment, local);
			transition_in(fieldtypeeditor.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			transition_out(field0.$$.fragment, local);
			transition_out(field1.$$.fragment, local);
			transition_out(field2.$$.fragment, local);
			transition_out(field3.$$.fragment, local);
			transition_out(fieldtypeeditor.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div0);
			if (detaching) detach(t2);
			if (detaching) detach(div1);
			if (if_block) if_block.d();
			destroy_component(field0);
			destroy_component(field1);
			destroy_component(field2);
			destroy_component(field3);
			destroy_component(fieldtypeeditor);
		}
	};
}

// (25:37) 
function create_if_block_1$6(ctx) {
	let contentblockeditor;
	let current;

	contentblockeditor = new ContentBlockEditor({
			props: {
				field: /*field*/ ctx[0],
				expanded: /*field*/ ctx[0].expanded
			}
		});

	return {
		c() {
			create_component(contentblockeditor.$$.fragment);
		},
		l(nodes) {
			claim_component(contentblockeditor.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(contentblockeditor, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const contentblockeditor_changes = {};
			if (dirty & /*field*/ 1) contentblockeditor_changes.field = /*field*/ ctx[0];
			if (dirty & /*field*/ 1) contentblockeditor_changes.expanded = /*field*/ ctx[0].expanded;
			contentblockeditor.$set(contentblockeditor_changes);
		},
		i(local) {
			if (current) return;
			transition_in(contentblockeditor.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(contentblockeditor.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(contentblockeditor, detaching);
		}
	};
}

// (22:4) {#if field.type === 'spacer'}
function create_if_block$9(ctx) {
	let field_1;
	let current;

	field_1 = new Field({
			props: {
				field: {
					id: randomString(),
					label: "Increase value to add more spacing between the previous and next field.",
					required: true,
					value: /*field*/ ctx[0].value ?? 1,
					type: "number",
					configFieldTarget: "value",
					configTarget: /*field*/ ctx[0].id
				}
			}
		});

	return {
		c() {
			create_component(field_1.$$.fragment);
		},
		l(nodes) {
			claim_component(field_1.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(field_1, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const field_1_changes = {};

			if (dirty & /*field*/ 1) field_1_changes.field = {
				id: randomString(),
				label: "Increase value to add more spacing between the previous and next field.",
				required: true,
				value: /*field*/ ctx[0].value ?? 1,
				type: "number",
				configFieldTarget: "value",
				configTarget: /*field*/ ctx[0].id
			};

			field_1.$set(field_1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(field_1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(field_1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(field_1, detaching);
		}
	};
}

// (33:8) {#if !cantBeRequired.includes(field.type)}
function create_if_block_2$3(ctx) {
	let field_1;
	let current;

	field_1 = new Field({
			props: {
				config: { search: false },
				field: {
					id: randomString(),
					customCss: "padding-bottom: 0em;",
					label: "Required",
					value: {
						type: "local",
						value: /*field*/ ctx[0].required
					},
					type: "switch",
					configFieldTarget: "required",
					configTarget: /*field*/ ctx[0].id,
					options: {
						type: "local",
						value: [{ label: "Yes", value: true }, { label: "No", value: false }]
					}
				}
			}
		});

	return {
		c() {
			create_component(field_1.$$.fragment);
		},
		l(nodes) {
			claim_component(field_1.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(field_1, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const field_1_changes = {};

			if (dirty & /*field*/ 1) field_1_changes.field = {
				id: randomString(),
				customCss: "padding-bottom: 0em;",
				label: "Required",
				value: {
					type: "local",
					value: /*field*/ ctx[0].required
				},
				type: "switch",
				configFieldTarget: "required",
				configTarget: /*field*/ ctx[0].id,
				options: {
					type: "local",
					value: [{ label: "Yes", value: true }, { label: "No", value: false }]
				}
			};

			field_1.$set(field_1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(field_1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(field_1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(field_1, detaching);
		}
	};
}

function create_fragment$j(ctx) {
	let div1;
	let div0;
	let current_block_type_index;
	let if_block;
	let t0;
	let logicaccordion;
	let t1;
	let groupaccordion;
	let current;
	const if_block_creators = [create_if_block$9, create_if_block_1$6, create_else_block$7];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*field*/ ctx[0].type === "spacer") return 0;
		if (/*field*/ ctx[0].type === "block") return 1;
		return 2;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	logicaccordion = new LogicAccordion({ props: { field: /*field*/ ctx[0] } });
	groupaccordion = new GroupAccordion({ props: { field: /*field*/ ctx[0] } });

	return {
		c() {
			div1 = element("div");
			div0 = element("div");
			if_block.c();
			t0 = space();
			create_component(logicaccordion.$$.fragment);
			t1 = space();
			create_component(groupaccordion.$$.fragment);
			this.h();
		},
		l(nodes) {
			div1 = claim_element(nodes, "DIV", {});
			var div1_nodes = children(div1);
			div0 = claim_element(div1_nodes, "DIV", { style: true });
			var div0_nodes = children(div0);
			if_block.l(div0_nodes);
			t0 = claim_space(div0_nodes);
			claim_component(logicaccordion.$$.fragment, div0_nodes);
			t1 = claim_space(div0_nodes);
			claim_component(groupaccordion.$$.fragment, div0_nodes);
			div0_nodes.forEach(detach);
			div1_nodes.forEach(detach);
			this.h();
		},
		h() {
			set_style(div0, "max-height", "95vh");
			set_style(div0, "overflow", "auto");
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			append(div1, div0);
			if_blocks[current_block_type_index].m(div0, null);
			append(div0, t0);
			mount_component(logicaccordion, div0, null);
			append(div0, t1);
			mount_component(groupaccordion, div0, null);
			current = true;
		},
		p(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(div0, t0);
			}

			const logicaccordion_changes = {};
			if (dirty & /*field*/ 1) logicaccordion_changes.field = /*field*/ ctx[0];
			logicaccordion.$set(logicaccordion_changes);
			const groupaccordion_changes = {};
			if (dirty & /*field*/ 1) groupaccordion_changes.field = /*field*/ ctx[0];
			groupaccordion.$set(groupaccordion_changes);
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			transition_in(logicaccordion.$$.fragment, local);
			transition_in(groupaccordion.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			transition_out(logicaccordion.$$.fragment, local);
			transition_out(groupaccordion.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div1);
			if_blocks[current_block_type_index].d();
			destroy_component(logicaccordion);
			destroy_component(groupaccordion);
		}
	};
}

function instance$j($$self, $$props, $$invalidate) {
	
	
	let { field } = $$props;
	let { config = {} } = $$props;
	let cantBeRequired = ["switch"];

	$$self.$$set = $$props => {
		if ("field" in $$props) $$invalidate(0, field = $$props.field);
		if ("config" in $$props) $$invalidate(2, config = $$props.config);
	};

	return [field, cantBeRequired, config];
}

class FieldEdit extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$j, create_fragment$j, safe_not_equal, { field: 0, config: 2 });
	}
}

/* src\features\form\edit\FormSidebar.svelte generated by Svelte v3.24.1 */

function get_each_context$5(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[8] = list[i];
	return child_ctx;
}

// (115:2) {:else}
function create_else_block$8(ctx) {
	let button;
	let t;
	let mounted;
	let dispose;

	return {
		c() {
			button = element("button");
			t = text("Save Form");
			this.h();
		},
		l(nodes) {
			button = claim_element(nodes, "BUTTON", { class: true, type: true });
			var button_nodes = children(button);
			t = claim_text(button_nodes, "Save Form");
			button_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(button, "class", "btn save-button btn-primary svelte-1ture1");
			attr(button, "type", "button");
		},
		m(target, anchor) {
			insert(target, button, anchor);
			append(button, t);

			if (!mounted) {
				dispose = listen(button, "click", /*saveDraft*/ ctx[2]);
				mounted = true;
			}
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(button);
			mounted = false;
			dispose();
		}
	};
}

// (113:2) {#if saving}
function create_if_block_11(ctx) {
	let button;
	let t;

	return {
		c() {
			button = element("button");
			t = text("Saving...");
			this.h();
		},
		l(nodes) {
			button = claim_element(nodes, "BUTTON", { class: true, type: true, disabled: true });
			var button_nodes = children(button);
			t = claim_text(button_nodes, "Saving...");
			button_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(button, "class", "btn save-button btn-primary svelte-1ture1");
			attr(button, "type", "button");
			button.disabled = true;
		},
		m(target, anchor) {
			insert(target, button, anchor);
			append(button, t);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(button);
		}
	};
}

// (212:45) 
function create_if_block_10(ctx) {
	let div3;
	let div1;
	let div0;
	let span;
	let t0;
	let div2;
	let h6;
	let t1;
	let t2;
	let div3_id_value;

	return {
		c() {
			div3 = element("div");
			div1 = element("div");
			div0 = element("div");
			span = element("span");
			t0 = space();
			div2 = element("div");
			h6 = element("h6");
			t1 = text("Radio Buttons");
			t2 = space();
			this.h();
		},
		l(nodes) {
			div3 = claim_element(nodes, "DIV", { class: true, id: true });
			var div3_nodes = children(div3);
			div1 = claim_element(div3_nodes, "DIV", {});
			var div1_nodes = children(div1);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			span = claim_element(div0_nodes, "SPAN", { class: true });
			children(span).forEach(detach);
			div0_nodes.forEach(detach);
			div1_nodes.forEach(detach);
			t0 = claim_space(div3_nodes);
			div2 = claim_element(div3_nodes, "DIV", { class: true });
			var div2_nodes = children(div2);
			h6 = claim_element(div2_nodes, "H6", { class: true });
			var h6_nodes = children(h6);
			t1 = claim_text(h6_nodes, "Radio Buttons");
			h6_nodes.forEach(detach);
			div2_nodes.forEach(detach);
			t2 = claim_space(div3_nodes);
			div3_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(span, "class", "fas fa-dot-circle");
			attr(div0, "class", "icon icon-sm icon-secondary");
			attr(h6, "class", "h6 svelte-1ture1");
			attr(div2, "class", "pl-3 svelte-1ture1");
			attr(div3, "class", "d-flex px-2 block svelte-1ture1");
			attr(div3, "id", div3_id_value = "sidebar-block-" + /*block*/ ctx[8].name);
		},
		m(target, anchor) {
			insert(target, div3, anchor);
			append(div3, div1);
			append(div1, div0);
			append(div0, span);
			append(div3, t0);
			append(div3, div2);
			append(div2, h6);
			append(h6, t1);
			append(div3, t2);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(div3);
		}
	};
}

// (203:48) 
function create_if_block_9(ctx) {
	let div3;
	let div1;
	let div0;
	let span;
	let t0;
	let div2;
	let h6;
	let t1;
	let t2;
	let div3_id_value;

	return {
		c() {
			div3 = element("div");
			div1 = element("div");
			div0 = element("div");
			span = element("span");
			t0 = space();
			div2 = element("div");
			h6 = element("h6");
			t1 = text("Checkboxes");
			t2 = space();
			this.h();
		},
		l(nodes) {
			div3 = claim_element(nodes, "DIV", { class: true, id: true });
			var div3_nodes = children(div3);
			div1 = claim_element(div3_nodes, "DIV", {});
			var div1_nodes = children(div1);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			span = claim_element(div0_nodes, "SPAN", { class: true });
			children(span).forEach(detach);
			div0_nodes.forEach(detach);
			div1_nodes.forEach(detach);
			t0 = claim_space(div3_nodes);
			div2 = claim_element(div3_nodes, "DIV", { class: true });
			var div2_nodes = children(div2);
			h6 = claim_element(div2_nodes, "H6", { class: true });
			var h6_nodes = children(h6);
			t1 = claim_text(h6_nodes, "Checkboxes");
			h6_nodes.forEach(detach);
			div2_nodes.forEach(detach);
			t2 = claim_space(div3_nodes);
			div3_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(span, "class", "far fa-check-square");
			attr(div0, "class", "icon icon-sm icon-secondary");
			attr(h6, "class", "h6 svelte-1ture1");
			attr(div2, "class", "pl-3 svelte-1ture1");
			attr(div3, "class", "d-flex px-2 block svelte-1ture1");
			attr(div3, "id", div3_id_value = "sidebar-block-" + /*block*/ ctx[8].name);
		},
		m(target, anchor) {
			insert(target, div3, anchor);
			append(div3, div1);
			append(div1, div0);
			append(div0, span);
			append(div3, t0);
			append(div3, div2);
			append(div2, h6);
			append(h6, t1);
			append(div3, t2);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(div3);
		}
	};
}

// (194:43) 
function create_if_block_8(ctx) {
	let div3;
	let div1;
	let div0;
	let span;
	let t0;
	let div2;
	let h6;
	let t1;
	let t2;
	let div3_id_value;

	return {
		c() {
			div3 = element("div");
			div1 = element("div");
			div0 = element("div");
			span = element("span");
			t0 = space();
			div2 = element("div");
			h6 = element("h6");
			t1 = text("Full Name");
			t2 = space();
			this.h();
		},
		l(nodes) {
			div3 = claim_element(nodes, "DIV", { class: true, id: true });
			var div3_nodes = children(div3);
			div1 = claim_element(div3_nodes, "DIV", {});
			var div1_nodes = children(div1);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			span = claim_element(div0_nodes, "SPAN", { class: true });
			children(span).forEach(detach);
			div0_nodes.forEach(detach);
			div1_nodes.forEach(detach);
			t0 = claim_space(div3_nodes);
			div2 = claim_element(div3_nodes, "DIV", { class: true });
			var div2_nodes = children(div2);
			h6 = claim_element(div2_nodes, "H6", { class: true });
			var h6_nodes = children(h6);
			t1 = claim_text(h6_nodes, "Full Name");
			h6_nodes.forEach(detach);
			div2_nodes.forEach(detach);
			t2 = claim_space(div3_nodes);
			div3_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(span, "class", "far fa-address-card");
			attr(div0, "class", "icon icon-sm icon-secondary");
			attr(h6, "class", "h6 svelte-1ture1");
			attr(div2, "class", "pl-3 svelte-1ture1");
			attr(div3, "class", "d-flex px-2 block svelte-1ture1");
			attr(div3, "id", div3_id_value = "sidebar-block-" + /*block*/ ctx[8].name);
		},
		m(target, anchor) {
			insert(target, div3, anchor);
			append(div3, div1);
			append(div1, div0);
			append(div0, span);
			append(div3, t0);
			append(div3, div2);
			append(div2, h6);
			append(h6, t1);
			append(div3, t2);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(div3);
		}
	};
}

// (185:41) 
function create_if_block_7(ctx) {
	let div3;
	let div1;
	let div0;
	let span;
	let t0;
	let div2;
	let h6;
	let t1;
	let t2;
	let div3_id_value;

	return {
		c() {
			div3 = element("div");
			div1 = element("div");
			div0 = element("div");
			span = element("span");
			t0 = space();
			div2 = element("div");
			h6 = element("h6");
			t1 = text("Address Block");
			t2 = space();
			this.h();
		},
		l(nodes) {
			div3 = claim_element(nodes, "DIV", { class: true, id: true });
			var div3_nodes = children(div3);
			div1 = claim_element(div3_nodes, "DIV", {});
			var div1_nodes = children(div1);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			span = claim_element(div0_nodes, "SPAN", { class: true });
			children(span).forEach(detach);
			div0_nodes.forEach(detach);
			div1_nodes.forEach(detach);
			t0 = claim_space(div3_nodes);
			div2 = claim_element(div3_nodes, "DIV", { class: true });
			var div2_nodes = children(div2);
			h6 = claim_element(div2_nodes, "H6", { class: true });
			var h6_nodes = children(h6);
			t1 = claim_text(h6_nodes, "Address Block");
			h6_nodes.forEach(detach);
			div2_nodes.forEach(detach);
			t2 = claim_space(div3_nodes);
			div3_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(span, "class", "far fa-address-card");
			attr(div0, "class", "icon icon-sm icon-secondary");
			attr(h6, "class", "h6 svelte-1ture1");
			attr(div2, "class", "pl-3 svelte-1ture1");
			attr(div3, "class", "d-flex px-2 block svelte-1ture1");
			attr(div3, "id", div3_id_value = "sidebar-block-" + /*block*/ ctx[8].name);
		},
		m(target, anchor) {
			insert(target, div3, anchor);
			append(div3, div1);
			append(div1, div0);
			append(div0, span);
			append(div3, t0);
			append(div3, div2);
			append(div2, h6);
			append(h6, t1);
			append(div3, t2);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(div3);
		}
	};
}

// (176:38) 
function create_if_block_6(ctx) {
	let div3;
	let div1;
	let div0;
	let span;
	let t0;
	let div2;
	let h6;
	let t1;
	let t2;
	let div3_id_value;

	return {
		c() {
			div3 = element("div");
			div1 = element("div");
			div0 = element("div");
			span = element("span");
			t0 = space();
			div2 = element("div");
			h6 = element("h6");
			t1 = text("File Upload");
			t2 = space();
			this.h();
		},
		l(nodes) {
			div3 = claim_element(nodes, "DIV", { class: true, id: true });
			var div3_nodes = children(div3);
			div1 = claim_element(div3_nodes, "DIV", {});
			var div1_nodes = children(div1);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			span = claim_element(div0_nodes, "SPAN", { class: true });
			children(span).forEach(detach);
			div0_nodes.forEach(detach);
			div1_nodes.forEach(detach);
			t0 = claim_space(div3_nodes);
			div2 = claim_element(div3_nodes, "DIV", { class: true });
			var div2_nodes = children(div2);
			h6 = claim_element(div2_nodes, "H6", { class: true });
			var h6_nodes = children(h6);
			t1 = claim_text(h6_nodes, "File Upload");
			h6_nodes.forEach(detach);
			div2_nodes.forEach(detach);
			t2 = claim_space(div3_nodes);
			div3_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(span, "class", "fas fa-file-upload");
			attr(div0, "class", "icon icon-sm icon-secondary");
			attr(h6, "class", "h6 svelte-1ture1");
			attr(div2, "class", "pl-3 svelte-1ture1");
			attr(div3, "class", "d-flex px-2 block svelte-1ture1");
			attr(div3, "id", div3_id_value = "sidebar-block-" + /*block*/ ctx[8].name);
		},
		m(target, anchor) {
			insert(target, div3, anchor);
			append(div3, div1);
			append(div1, div0);
			append(div0, span);
			append(div3, t0);
			append(div3, div2);
			append(div2, h6);
			append(h6, t1);
			append(div3, t2);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(div3);
		}
	};
}

// (167:38) 
function create_if_block_5$1(ctx) {
	let div3;
	let div1;
	let div0;
	let span;
	let t0;
	let div2;
	let h6;
	let t1;
	let t2;
	let div3_id_value;

	return {
		c() {
			div3 = element("div");
			div1 = element("div");
			div0 = element("div");
			span = element("span");
			t0 = space();
			div2 = element("div");
			h6 = element("h6");
			t1 = text("Date");
			t2 = space();
			this.h();
		},
		l(nodes) {
			div3 = claim_element(nodes, "DIV", { class: true, id: true });
			var div3_nodes = children(div3);
			div1 = claim_element(div3_nodes, "DIV", {});
			var div1_nodes = children(div1);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			span = claim_element(div0_nodes, "SPAN", { class: true });
			children(span).forEach(detach);
			div0_nodes.forEach(detach);
			div1_nodes.forEach(detach);
			t0 = claim_space(div3_nodes);
			div2 = claim_element(div3_nodes, "DIV", { class: true });
			var div2_nodes = children(div2);
			h6 = claim_element(div2_nodes, "H6", { class: true });
			var h6_nodes = children(h6);
			t1 = claim_text(h6_nodes, "Date");
			h6_nodes.forEach(detach);
			div2_nodes.forEach(detach);
			t2 = claim_space(div3_nodes);
			div3_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(span, "class", "fas fa-calendar-day");
			attr(div0, "class", "icon icon-sm icon-secondary");
			attr(h6, "class", "h6 svelte-1ture1");
			attr(div2, "class", "pl-3 svelte-1ture1");
			attr(div3, "class", "d-flex px-2 block svelte-1ture1");
			attr(div3, "id", div3_id_value = "sidebar-block-" + /*block*/ ctx[8].name);
		},
		m(target, anchor) {
			insert(target, div3, anchor);
			append(div3, div1);
			append(div1, div0);
			append(div0, span);
			append(div3, t0);
			append(div3, div2);
			append(div2, h6);
			append(h6, t1);
			append(div3, t2);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(div3);
		}
	};
}

// (158:39) 
function create_if_block_4$2(ctx) {
	let div3;
	let div1;
	let div0;
	let span;
	let t0;
	let div2;
	let h6;
	let t1;
	let t2;
	let div3_id_value;

	return {
		c() {
			div3 = element("div");
			div1 = element("div");
			div0 = element("div");
			span = element("span");
			t0 = space();
			div2 = element("div");
			h6 = element("h6");
			t1 = text("Content");
			t2 = space();
			this.h();
		},
		l(nodes) {
			div3 = claim_element(nodes, "DIV", { class: true, id: true });
			var div3_nodes = children(div3);
			div1 = claim_element(div3_nodes, "DIV", {});
			var div1_nodes = children(div1);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			span = claim_element(div0_nodes, "SPAN", { class: true });
			children(span).forEach(detach);
			div0_nodes.forEach(detach);
			div1_nodes.forEach(detach);
			t0 = claim_space(div3_nodes);
			div2 = claim_element(div3_nodes, "DIV", { class: true });
			var div2_nodes = children(div2);
			h6 = claim_element(div2_nodes, "H6", { class: true });
			var h6_nodes = children(h6);
			t1 = claim_text(h6_nodes, "Content");
			h6_nodes.forEach(detach);
			div2_nodes.forEach(detach);
			t2 = claim_space(div3_nodes);
			div3_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(span, "class", "fas fa-indent");
			attr(div0, "class", "icon icon-sm icon-secondary");
			attr(h6, "class", "h6 svelte-1ture1");
			attr(div2, "class", "pl-3 svelte-1ture1");
			attr(div3, "class", "d-flex px-2 block svelte-1ture1");
			attr(div3, "id", div3_id_value = "sidebar-block-" + /*block*/ ctx[8].name);
		},
		m(target, anchor) {
			insert(target, div3, anchor);
			append(div3, div1);
			append(div1, div0);
			append(div0, span);
			append(div3, t0);
			append(div3, div2);
			append(div2, h6);
			append(h6, t1);
			append(div3, t2);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(div3);
		}
	};
}

// (149:42) 
function create_if_block_3$3(ctx) {
	let div3;
	let div1;
	let div0;
	let span;
	let t0;
	let div2;
	let h6;
	let t1;
	let t2;
	let div3_id_value;

	return {
		c() {
			div3 = element("div");
			div1 = element("div");
			div0 = element("div");
			span = element("span");
			t0 = space();
			div2 = element("div");
			h6 = element("h6");
			t1 = text("Dropdown");
			t2 = space();
			this.h();
		},
		l(nodes) {
			div3 = claim_element(nodes, "DIV", { class: true, id: true });
			var div3_nodes = children(div3);
			div1 = claim_element(div3_nodes, "DIV", {});
			var div1_nodes = children(div1);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			span = claim_element(div0_nodes, "SPAN", { class: true });
			children(span).forEach(detach);
			div0_nodes.forEach(detach);
			div1_nodes.forEach(detach);
			t0 = claim_space(div3_nodes);
			div2 = claim_element(div3_nodes, "DIV", { class: true });
			var div2_nodes = children(div2);
			h6 = claim_element(div2_nodes, "H6", { class: true });
			var h6_nodes = children(h6);
			t1 = claim_text(h6_nodes, "Dropdown");
			h6_nodes.forEach(detach);
			div2_nodes.forEach(detach);
			t2 = claim_space(div3_nodes);
			div3_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(span, "class", "far fa-caret-square-down");
			attr(div0, "class", "icon icon-sm icon-secondary");
			attr(h6, "class", "h6 svelte-1ture1");
			attr(div2, "class", "pl-3 svelte-1ture1");
			attr(div3, "class", "d-flex px-2 block svelte-1ture1");
			attr(div3, "id", div3_id_value = "sidebar-block-" + /*block*/ ctx[8].name);
		},
		m(target, anchor) {
			insert(target, div3, anchor);
			append(div3, div1);
			append(div1, div0);
			append(div0, span);
			append(div3, t0);
			append(div3, div2);
			append(div2, h6);
			append(h6, t1);
			append(div3, t2);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(div3);
		}
	};
}

// (140:40) 
function create_if_block_2$4(ctx) {
	let div3;
	let div1;
	let div0;
	let span;
	let t0;
	let div2;
	let h6;
	let t1;
	let t2;
	let div3_id_value;

	return {
		c() {
			div3 = element("div");
			div1 = element("div");
			div0 = element("div");
			span = element("span");
			t0 = space();
			div2 = element("div");
			h6 = element("h6");
			t1 = text("Toggle");
			t2 = space();
			this.h();
		},
		l(nodes) {
			div3 = claim_element(nodes, "DIV", { class: true, id: true });
			var div3_nodes = children(div3);
			div1 = claim_element(div3_nodes, "DIV", {});
			var div1_nodes = children(div1);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			span = claim_element(div0_nodes, "SPAN", { class: true });
			children(span).forEach(detach);
			div0_nodes.forEach(detach);
			div1_nodes.forEach(detach);
			t0 = claim_space(div3_nodes);
			div2 = claim_element(div3_nodes, "DIV", { class: true });
			var div2_nodes = children(div2);
			h6 = claim_element(div2_nodes, "H6", { class: true });
			var h6_nodes = children(h6);
			t1 = claim_text(h6_nodes, "Toggle");
			h6_nodes.forEach(detach);
			div2_nodes.forEach(detach);
			t2 = claim_space(div3_nodes);
			div3_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(span, "class", "fas fa-toggle-off");
			attr(div0, "class", "icon icon-sm icon-secondary");
			attr(h6, "class", "h6 svelte-1ture1");
			attr(div2, "class", "pl-3 svelte-1ture1");
			attr(div3, "class", "d-flex px-2 block svelte-1ture1");
			attr(div3, "id", div3_id_value = "sidebar-block-" + /*block*/ ctx[8].name);
		},
		m(target, anchor) {
			insert(target, div3, anchor);
			append(div3, div1);
			append(div1, div0);
			append(div0, span);
			append(div3, t0);
			append(div3, div2);
			append(div2, h6);
			append(h6, t1);
			append(div3, t2);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(div3);
		}
	};
}

// (131:40) 
function create_if_block_1$7(ctx) {
	let div3;
	let div1;
	let div0;
	let span;
	let t0;
	let div2;
	let h6;
	let t1;
	let t2;
	let div3_id_value;

	return {
		c() {
			div3 = element("div");
			div1 = element("div");
			div0 = element("div");
			span = element("span");
			t0 = space();
			div2 = element("div");
			h6 = element("h6");
			t1 = text("Spacer");
			t2 = space();
			this.h();
		},
		l(nodes) {
			div3 = claim_element(nodes, "DIV", { class: true, id: true });
			var div3_nodes = children(div3);
			div1 = claim_element(div3_nodes, "DIV", {});
			var div1_nodes = children(div1);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			span = claim_element(div0_nodes, "SPAN", { class: true });
			children(span).forEach(detach);
			div0_nodes.forEach(detach);
			div1_nodes.forEach(detach);
			t0 = claim_space(div3_nodes);
			div2 = claim_element(div3_nodes, "DIV", { class: true });
			var div2_nodes = children(div2);
			h6 = claim_element(div2_nodes, "H6", { class: true });
			var h6_nodes = children(h6);
			t1 = claim_text(h6_nodes, "Spacer");
			h6_nodes.forEach(detach);
			div2_nodes.forEach(detach);
			t2 = claim_space(div3_nodes);
			div3_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(span, "class", "fas fa-rocket");
			attr(div0, "class", "icon icon-sm icon-secondary");
			attr(h6, "class", "h6 svelte-1ture1");
			attr(div2, "class", "pl-3 svelte-1ture1");
			attr(div3, "class", "d-flex px-2 block svelte-1ture1");
			attr(div3, "id", div3_id_value = "sidebar-block-" + /*block*/ ctx[8].name);
		},
		m(target, anchor) {
			insert(target, div3, anchor);
			append(div3, div1);
			append(div1, div0);
			append(div0, span);
			append(div3, t0);
			append(div3, div2);
			append(div2, h6);
			append(h6, t1);
			append(div3, t2);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(div3);
		}
	};
}

// (122:6) {#if block.name === 'string'}
function create_if_block$a(ctx) {
	let div3;
	let div1;
	let div0;
	let span;
	let t0;
	let div2;
	let h6;
	let t1;
	let t2;
	let div3_id_value;

	return {
		c() {
			div3 = element("div");
			div1 = element("div");
			div0 = element("div");
			span = element("span");
			t0 = space();
			div2 = element("div");
			h6 = element("h6");
			t1 = text("Text Input");
			t2 = space();
			this.h();
		},
		l(nodes) {
			div3 = claim_element(nodes, "DIV", { class: true, id: true });
			var div3_nodes = children(div3);
			div1 = claim_element(div3_nodes, "DIV", {});
			var div1_nodes = children(div1);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			span = claim_element(div0_nodes, "SPAN", { class: true });
			children(span).forEach(detach);
			div0_nodes.forEach(detach);
			div1_nodes.forEach(detach);
			t0 = claim_space(div3_nodes);
			div2 = claim_element(div3_nodes, "DIV", { class: true });
			var div2_nodes = children(div2);
			h6 = claim_element(div2_nodes, "H6", { class: true });
			var h6_nodes = children(h6);
			t1 = claim_text(h6_nodes, "Text Input");
			h6_nodes.forEach(detach);
			div2_nodes.forEach(detach);
			t2 = claim_space(div3_nodes);
			div3_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(span, "class", "fas fas fa-i-cursor");
			attr(div0, "class", "icon icon-sm icon-secondary");
			attr(h6, "class", "h6 svelte-1ture1");
			attr(div2, "class", "pl-3 svelte-1ture1");
			attr(div3, "class", "d-flex px-2 block svelte-1ture1");
			attr(div3, "id", div3_id_value = "sidebar-block-" + /*block*/ ctx[8].name);
		},
		m(target, anchor) {
			insert(target, div3, anchor);
			append(div3, div1);
			append(div1, div0);
			append(div0, span);
			append(div3, t0);
			append(div3, div2);
			append(div2, h6);
			append(h6, t1);
			append(div3, t2);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(div3);
		}
	};
}

// (121:4) {#each blocks as block}
function create_each_block$5(ctx) {
	let if_block_anchor;

	function select_block_type_1(ctx, dirty) {
		if (/*block*/ ctx[8].name === "string") return create_if_block$a;
		if (/*block*/ ctx[8].name === "spacer") return create_if_block_1$7;
		if (/*block*/ ctx[8].name === "switch") return create_if_block_2$4;
		if (/*block*/ ctx[8].name === "combobox") return create_if_block_3$3;
		if (/*block*/ ctx[8].name === "block") return create_if_block_4$2;
		if (/*block*/ ctx[8].name === "date") return create_if_block_5$1;
		if (/*block*/ ctx[8].name === "file") return create_if_block_6;
		if (/*block*/ ctx[8].name === "address") return create_if_block_7;
		if (/*block*/ ctx[8].name === "full-name") return create_if_block_8;
		if (/*block*/ ctx[8].name === "checkbox-group") return create_if_block_9;
		if (/*block*/ ctx[8].name === "radio-group") return create_if_block_10;
	}

	let current_block_type = select_block_type_1(ctx);
	let if_block = current_block_type && current_block_type(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		l(nodes) {
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},
		p(ctx, dirty) {
			if (if_block) if_block.p(ctx, dirty);
		},
		d(detaching) {
			if (if_block) {
				if_block.d(detaching);
			}

			if (detaching) detach(if_block_anchor);
		}
	};
}

function create_fragment$k(ctx) {
	let div0;
	let t0;
	let div15;
	let h5;
	let t1;
	let t2;
	let hr;
	let t3;
	let div1;
	let t4;
	let div8;
	let div3;
	let div2;
	let span0;
	let t5;
	let div4;
	let h60;
	let t6;
	let t7;
	let div5;
	let t8;
	let div7;
	let div6;
	let span1;
	let t9;
	let div14;
	let div13;
	let ul;
	let li;
	let a;
	let div12;
	let div10;
	let div9;
	let span2;
	let t10;
	let div11;
	let h61;
	let t11;

	function select_block_type(ctx, dirty) {
		if (/*saving*/ ctx[0]) return create_if_block_11;
		return create_else_block$8;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type(ctx);
	let each_value = /*blocks*/ ctx[1];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$5(get_each_context$5(ctx, each_value, i));
	}

	return {
		c() {
			div0 = element("div");
			if_block.c();
			t0 = space();
			div15 = element("div");
			h5 = element("h5");
			t1 = text("Add Field");
			t2 = space();
			hr = element("hr");
			t3 = space();
			div1 = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t4 = space();
			div8 = element("div");
			div3 = element("div");
			div2 = element("div");
			span0 = element("span");
			t5 = space();
			div4 = element("div");
			h60 = element("h6");
			t6 = text("Styling");
			t7 = space();
			div5 = element("div");
			t8 = space();
			div7 = element("div");
			div6 = element("div");
			span1 = element("span");
			t9 = space();
			div14 = element("div");
			div13 = element("div");
			ul = element("ul");
			li = element("li");
			a = element("a");
			div12 = element("div");
			div10 = element("div");
			div9 = element("div");
			span2 = element("span");
			t10 = space();
			div11 = element("div");
			h61 = element("h6");
			t11 = text("Spacer");
			this.h();
		},
		l(nodes) {
			div0 = claim_element(nodes, "DIV", { style: true });
			var div0_nodes = children(div0);
			if_block.l(div0_nodes);
			div0_nodes.forEach(detach);
			t0 = claim_space(nodes);
			div15 = claim_element(nodes, "DIV", { style: true });
			var div15_nodes = children(div15);
			h5 = claim_element(div15_nodes, "H5", { style: true });
			var h5_nodes = children(h5);
			t1 = claim_text(h5_nodes, "Add Field");
			h5_nodes.forEach(detach);
			t2 = claim_space(div15_nodes);
			hr = claim_element(div15_nodes, "HR", { style: true });
			t3 = claim_space(div15_nodes);
			div1 = claim_element(div15_nodes, "DIV", { id: true });
			var div1_nodes = children(div1);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(div1_nodes);
			}

			div1_nodes.forEach(detach);
			t4 = claim_space(div15_nodes);

			div8 = claim_element(div15_nodes, "DIV", {
				class: true,
				href: true,
				"data-toggle": true,
				"data-target": true,
				"aria-expanded": true
			});

			var div8_nodes = children(div8);
			div3 = claim_element(div8_nodes, "DIV", {});
			var div3_nodes = children(div3);
			div2 = claim_element(div3_nodes, "DIV", { class: true });
			var div2_nodes = children(div2);
			span0 = claim_element(div2_nodes, "SPAN", { class: true });
			children(span0).forEach(detach);
			div2_nodes.forEach(detach);
			div3_nodes.forEach(detach);
			t5 = claim_space(div8_nodes);
			div4 = claim_element(div8_nodes, "DIV", { class: true });
			var div4_nodes = children(div4);
			h60 = claim_element(div4_nodes, "H6", { class: true });
			var h60_nodes = children(h60);
			t6 = claim_text(h60_nodes, "Styling");
			h60_nodes.forEach(detach);
			div4_nodes.forEach(detach);
			t7 = claim_space(div8_nodes);
			div5 = claim_element(div8_nodes, "DIV", { class: true });
			children(div5).forEach(detach);
			t8 = claim_space(div8_nodes);
			div7 = claim_element(div8_nodes, "DIV", {});
			var div7_nodes = children(div7);
			div6 = claim_element(div7_nodes, "DIV", { class: true });
			var div6_nodes = children(div6);
			span1 = claim_element(div6_nodes, "SPAN", { class: true, style: true });
			children(span1).forEach(detach);
			div6_nodes.forEach(detach);
			div7_nodes.forEach(detach);
			div8_nodes.forEach(detach);
			t9 = claim_space(div15_nodes);
			div14 = claim_element(div15_nodes, "DIV", {});
			var div14_nodes = children(div14);

			div13 = claim_element(div14_nodes, "DIV", {
				class: true,
				role: true,
				id: true,
				"aria-expanded": true,
				style: true
			});

			var div13_nodes = children(div13);
			ul = claim_element(div13_nodes, "UL", { class: true });
			var ul_nodes = children(ul);
			li = claim_element(ul_nodes, "LI", { class: true });
			var li_nodes = children(li);

			a = claim_element(li_nodes, "A", {
				class: true,
				id: true,
				href: true,
				style: true
			});

			var a_nodes = children(a);
			div12 = claim_element(a_nodes, "DIV", { class: true });
			var div12_nodes = children(div12);
			div10 = claim_element(div12_nodes, "DIV", {});
			var div10_nodes = children(div10);
			div9 = claim_element(div10_nodes, "DIV", { class: true });
			var div9_nodes = children(div9);
			span2 = claim_element(div9_nodes, "SPAN", { class: true });
			children(span2).forEach(detach);
			div9_nodes.forEach(detach);
			div10_nodes.forEach(detach);
			t10 = claim_space(div12_nodes);
			div11 = claim_element(div12_nodes, "DIV", { class: true });
			var div11_nodes = children(div11);
			h61 = claim_element(div11_nodes, "H6", { class: true });
			var h61_nodes = children(h61);
			t11 = claim_text(h61_nodes, "Spacer");
			h61_nodes.forEach(detach);
			div11_nodes.forEach(detach);
			div12_nodes.forEach(detach);
			a_nodes.forEach(detach);
			li_nodes.forEach(detach);
			ul_nodes.forEach(detach);
			div13_nodes.forEach(detach);
			div14_nodes.forEach(detach);
			div15_nodes.forEach(detach);
			this.h();
		},
		h() {
			set_style(div0, "text-align", "center");
			set_style(hr, "margin-right", "0.7em", 1);
			attr(div1, "id", "block-container");
			attr(span0, "class", "fas fa-palette");
			attr(div2, "class", "icon icon-sm icon-secondary");
			attr(h60, "class", "h6 svelte-1ture1");
			attr(div4, "class", "pl-3 svelte-1ture1");
			attr(div5, "class", "pl-3 svelte-1ture1");
			attr(span1, "class", "fas fa-chevron-right");
			set_style(span1, "font-size", "1em");
			attr(div6, "class", "icon icon-sm icon-secondary link-arrow");
			attr(div8, "class", "d-flex px-2 collapsed");
			attr(div8, "href", "#submenu-app");
			attr(div8, "data-toggle", "collapse");
			attr(div8, "data-target", "#submenu-app");
			attr(div8, "aria-expanded", "false");
			attr(span2, "class", "fas fa-rocket");
			attr(div9, "class", "icon icon-sm icon-secondary");
			attr(h61, "class", "h6 svelte-1ture1");
			attr(div11, "class", "pl-3 svelte-1ture1");
			attr(div12, "class", "d-flex px-2 block svelte-1ture1");
			attr(a, "class", "nav-link");
			attr(a, "id", "address");
			attr(a, "href", "#");
			set_style(a, "padding-left", "0em");
			attr(li, "class", "nav-item");
			attr(ul, "class", "flex-column nav");
			attr(div13, "class", "multi-level collapse");
			attr(div13, "role", "list");
			attr(div13, "id", "submenu-app");
			attr(div13, "aria-expanded", "false");
			set_style(div13, "padding-top", "0.5em");
			set_style(div13, "padding-left", "1em");
			set_style(div15, "padding-left", "0.2em");
		},
		m(target, anchor) {
			insert(target, div0, anchor);
			if_block.m(div0, null);
			insert(target, t0, anchor);
			insert(target, div15, anchor);
			append(div15, h5);
			append(h5, t1);
			append(div15, t2);
			append(div15, hr);
			append(div15, t3);
			append(div15, div1);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div1, null);
			}

			append(div15, t4);
			append(div15, div8);
			append(div8, div3);
			append(div3, div2);
			append(div2, span0);
			append(div8, t5);
			append(div8, div4);
			append(div4, h60);
			append(h60, t6);
			append(div8, t7);
			append(div8, div5);
			append(div8, t8);
			append(div8, div7);
			append(div7, div6);
			append(div6, span1);
			append(div15, t9);
			append(div15, div14);
			append(div14, div13);
			append(div13, ul);
			append(ul, li);
			append(li, a);
			append(a, div12);
			append(div12, div10);
			append(div10, div9);
			append(div9, span2);
			append(div12, t10);
			append(div12, div11);
			append(div11, h61);
			append(h61, t11);
		},
		p(ctx, [dirty]) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(div0, null);
				}
			}

			if (dirty & /*blocks*/ 2) {
				each_value = /*blocks*/ ctx[1];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$5(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$5(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div1, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div0);
			if_block.d();
			if (detaching) detach(t0);
			if (detaching) detach(div15);
			destroy_each(each_blocks, detaching);
		}
	};
}

function defaultBlocks() {
	return [
		{ name: "string" },
		{ name: "switch" },
		{ name: "spacer" },
		{ name: "date" },
		{ name: "block" },
		{ name: "file" },
		{ name: "address" },
		{ name: "checkbox-group" },
		{ name: "radio-group" },
		{ name: "full-name" }
	];
}

function instance$k($$self, $$props, $$invalidate) {
	var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
		function adopt(value) {
			return value instanceof P
			? value
			: new P(function (resolve) {
						resolve(value);
					});
		}

		return new (P || (P = Promise))(function (resolve, reject) {
				function fulfilled(value) {
					try {
						step(generator.next(value));
					} catch(e) {
						reject(e);
					}
				}

				function rejected(value) {
					try {
						step(generator["throw"](value));
					} catch(e) {
						reject(e);
					}
				}

				function step(result) {
					result.done
					? resolve(result.value)
					: adopt(result.value).then(fulfilled, rejected);
				}

				step((generator = generator.apply(thisArg, _arguments || [])).next());
			});
	};

	let saving = false;
	let drake = null;
	let dragula;
	let blocks = defaultBlocks();

	const loadDragula = debounce(
		() => __awaiter(void 0, void 0, void 0, function* () {
			if (!dragula) {
				dragula = (yield import('./dragula.213efdda.js').then(function (n) { return n.d; })).default;
				yield tick();
			}

			if (drake) {
				drake.destroy();
			}

			yield tick();

			drake = dragula(
				[
					document.querySelector("#block-container"),
					document.querySelector("#form-preview-fields")
				],
				{
					copy(el, source) {
						return source === document.getElementById("block-container");
					},
					accepts(el, target) {
						return target !== document.getElementById("block-container");
					}
				}
			).on("drag", function (el) {
				var _a;

				if (el.id && el.id.startsWith("form-field-")) {
					return;
				}

				const container = document.getElementById("form-preview-fields");

				if (container && !((_a = container.className) === null || _a === void 0
				? void 0
				: _a.includes("ex-over"))) {
					container.className += " ex-over";
				}
			}).on("over", function (el, container) {
				var _a;

				if (el.id && el.id.startsWith("form-field-")) {
					return;
				}

				if (container.id === "form-preview-fields" && !((_a = container.className) === null || _a === void 0
				? void 0
				: _a.includes("ex-over"))) {
					container.className += " ex-over";
				}

				dispatch("drag_over", container);
			}).on("drop", function (el) {
				console.log("drop");
				const container = document.getElementById("form-preview-fields");

				if (container) {
					container.className = container.className.replace("ex-over", "");
				}

				const fields = Array.from(document.querySelector("#form-preview-fields").childNodes).filter(w => {
					var _a, _b;

					return ((_a = w.id) === null || _a === void 0
					? void 0
					: _a.startsWith("sidebar-block")) || ((_b = w.id) === null || _b === void 0
					? void 0
					: _b.startsWith("form-field-"));
				});

				dispatch("drag_finished", fields);
				el.remove();

				setTimeout(
					() => {
						drake.destroy();
					},
					100
				);
			});
		}),
		500
	);

	function saveDraft() {
		return __awaiter(this, void 0, void 0, function* () {
			$$invalidate(0, saving = true);
			yield dispatch("save_form", { status: "draft" });
			$$invalidate(0, saving = false);
		});
	}

	onMount(() => __awaiter(void 0, void 0, void 0, function* () {
		import('./dragula.8f5f778e.js');

		subscribe("form_updated", () => {
			loadDragula();
		});
	}));

	return [saving, blocks, saveDraft];
}

class FormSidebar extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$k, create_fragment$k, safe_not_equal, {});
	}
}

/* src\features\form\edit\FieldEditSidebar.svelte generated by Svelte v3.24.1 */

function get_each_context$6(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[2] = list[i];
	return child_ctx;
}

// (37:0) {:else}
function create_else_block$9(ctx) {
	let formedit;
	let current;
	formedit = new FormEdit({});

	return {
		c() {
			create_component(formedit.$$.fragment);
		},
		l(nodes) {
			claim_component(formedit.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(formedit, target, anchor);
			current = true;
		},
		p: noop,
		i(local) {
			if (current) return;
			transition_in(formedit.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(formedit.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(formedit, detaching);
		}
	};
}

// (31:2) {#if field}
function create_if_block$b(ctx) {
	let each_blocks = [];
	let each_1_lookup = new Map();
	let each_1_anchor;
	let current;
	let each_value = [/*field*/ ctx[0]];
	const get_key = ctx => /*fieldId*/ ctx[1];

	for (let i = 0; i < 1; i += 1) {
		let child_ctx = get_each_context$6(ctx, each_value, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block$6(key, child_ctx));
	}

	return {
		c() {
			for (let i = 0; i < 1; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		l(nodes) {
			for (let i = 0; i < 1; i += 1) {
				each_blocks[i].l(nodes);
			}

			each_1_anchor = empty();
		},
		m(target, anchor) {
			for (let i = 0; i < 1; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert(target, each_1_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (dirty & /*field*/ 1) {
				const each_value = [/*field*/ ctx[0]];
				group_outros();
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block$6, each_1_anchor, get_each_context$6);
				check_outros();
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < 1; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			for (let i = 0; i < 1; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			for (let i = 0; i < 1; i += 1) {
				each_blocks[i].d(detaching);
			}

			if (detaching) detach(each_1_anchor);
		}
	};
}

// (32:2) {#each [field] as f (fieldId)}
function create_each_block$6(key_1, ctx) {
	let div;
	let fieldedit;
	let t;
	let div_transition;
	let current;
	fieldedit = new FieldEdit({ props: { field: /*f*/ ctx[2] } });

	return {
		key: key_1,
		first: null,
		c() {
			div = element("div");
			create_component(fieldedit.$$.fragment);
			t = space();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", {});
			var div_nodes = children(div);
			claim_component(fieldedit.$$.fragment, div_nodes);
			t = claim_space(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			this.first = div;
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(fieldedit, div, null);
			append(div, t);
			current = true;
		},
		p(ctx, dirty) {
			const fieldedit_changes = {};
			if (dirty & /*field*/ 1) fieldedit_changes.field = /*f*/ ctx[2];
			fieldedit.$set(fieldedit_changes);
		},
		i(local) {
			if (current) return;
			transition_in(fieldedit.$$.fragment, local);

			add_render_callback(() => {
				if (!div_transition) div_transition = create_bidirectional_transition(div, slide, { duration: 500 }, true);
				div_transition.run(1);
			});

			current = true;
		},
		o(local) {
			transition_out(fieldedit.$$.fragment, local);
			if (!div_transition) div_transition = create_bidirectional_transition(div, slide, { duration: 500 }, false);
			div_transition.run(0);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(fieldedit);
			if (detaching && div_transition) div_transition.end();
		}
	};
}

function create_fragment$l(ctx) {
	let div1;
	let div0;
	let current_block_type_index;
	let if_block;
	let current;
	const if_block_creators = [create_if_block$b, create_else_block$9];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*field*/ ctx[0]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			div1 = element("div");
			div0 = element("div");
			if_block.c();
			this.h();
		},
		l(nodes) {
			div1 = claim_element(nodes, "DIV", {});
			var div1_nodes = children(div1);
			div0 = claim_element(div1_nodes, "DIV", { class: true, style: true });
			var div0_nodes = children(div0);
			if_block.l(div0_nodes);
			div0_nodes.forEach(detach);
			div1_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div0, "class", "col-md no-gutters");
			set_style(div0, "padding-left", "0.55em");
			set_style(div0, "padding-right", "0.55em");
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			append(div1, div0);
			if_blocks[current_block_type_index].m(div0, null);
			current = true;
		},
		p(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(div0, null);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div1);
			if_blocks[current_block_type_index].d();
		}
	};
}

function instance$l($$self, $$props, $$invalidate) {
	
	
	let field;
	let fieldId;

	onMount(() => {
		subscribeFieldChange(newField => {
			if (newField.id === fieldId && !newField.selected) {
				$$invalidate(0, field = undefined);
				$$invalidate(1, fieldId = undefined);
				return;
			}

			if (newField.selected) {
				$$invalidate(0, field = fastClone(newField));
				$$invalidate(1, fieldId = field.id);
			}
		});
	});

	return [field, fieldId];
}

class FieldEditSidebar extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$l, create_fragment$l, safe_not_equal, {});
	}
}

/* src\components\Sidebar.svelte generated by Svelte v3.24.1 */

function create_fragment$m(ctx) {
	let nav;
	let div;
	let ul;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*$$slots*/ ctx[1].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[0], null);

	return {
		c() {
			nav = element("nav");
			div = element("div");
			ul = element("ul");
			if (default_slot) default_slot.c();
			this.h();
		},
		l(nodes) {
			nav = claim_element(nodes, "NAV", { class: true, style: true });
			var nav_nodes = children(nav);
			div = claim_element(nav_nodes, "DIV", { style: true });
			var div_nodes = children(div);
			ul = claim_element(div_nodes, "UL", { class: true, id: true, style: true });
			var ul_nodes = children(ul);
			if (default_slot) default_slot.l(ul_nodes);
			ul_nodes.forEach(detach);
			div_nodes.forEach(detach);
			nav_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(ul, "class", "nav flex-column");
			attr(ul, "id", "blocks");
			set_style(ul, "padding-top", "0.5em");
			set_style(div, "margin-left", ".5em");
			set_style(div, "margin-right", "0.5em");
			attr(nav, "class", "d-md-block sidebar collapse svelte-1nmn5ly");
			set_style(nav, "background-color", "#f5f9fe");
		},
		m(target, anchor) {
			insert(target, nav, anchor);
			append(nav, div);
			append(div, ul);

			if (default_slot) {
				default_slot.m(ul, null);
			}

			current = true;

			if (!mounted) {
				dispose = listen(nav, "click", stop_propagation(/*click_handler*/ ctx[2]));
				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 1) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[0], dirty, null, null);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(nav);
			if (default_slot) default_slot.d(detaching);
			mounted = false;
			dispose();
		}
	};
}

function instance$m($$self, $$props, $$invalidate) {
	let { $$slots = {}, $$scope } = $$props;

	function click_handler(event) {
		bubble($$self, event);
	}

	$$self.$$set = $$props => {
		if ("$$scope" in $$props) $$invalidate(0, $$scope = $$props.$$scope);
	};

	return [$$scope, $$slots, click_handler];
}

class Sidebar extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$m, create_fragment$m, safe_not_equal, {});
	}
}

/* src\routes\builder\index.svelte generated by Svelte v3.24.1 */

function create_default_slot_1(ctx) {
	let formsidebar;
	let current;
	formsidebar = new FormSidebar({});

	return {
		c() {
			create_component(formsidebar.$$.fragment);
		},
		l(nodes) {
			claim_component(formsidebar.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(formsidebar, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(formsidebar.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(formsidebar.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(formsidebar, detaching);
		}
	};
}

// (43:4) <Sidebar>
function create_default_slot$1(ctx) {
	let switch_instance;
	let switch_instance_anchor;
	let current;
	const switch_instance_spread_levels = [/*rightSidebarProps*/ ctx[1]];
	var switch_value = /*rightSidebar*/ ctx[0];

	function switch_props(ctx) {
		let switch_instance_props = {};

		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
		}

		return { props: switch_instance_props };
	}

	if (switch_value) {
		switch_instance = new switch_value(switch_props());
	}

	return {
		c() {
			if (switch_instance) create_component(switch_instance.$$.fragment);
			switch_instance_anchor = empty();
		},
		l(nodes) {
			if (switch_instance) claim_component(switch_instance.$$.fragment, nodes);
			switch_instance_anchor = empty();
		},
		m(target, anchor) {
			if (switch_instance) {
				mount_component(switch_instance, target, anchor);
			}

			insert(target, switch_instance_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const switch_instance_changes = (dirty & /*rightSidebarProps*/ 2)
			? get_spread_update(switch_instance_spread_levels, [get_spread_object(/*rightSidebarProps*/ ctx[1])])
			: {};

			if (switch_value !== (switch_value = /*rightSidebar*/ ctx[0])) {
				if (switch_instance) {
					group_outros();
					const old_component = switch_instance;

					transition_out(old_component.$$.fragment, 1, 0, () => {
						destroy_component(old_component, 1);
					});

					check_outros();
				}

				if (switch_value) {
					switch_instance = new switch_value(switch_props());
					create_component(switch_instance.$$.fragment);
					transition_in(switch_instance.$$.fragment, 1);
					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
				} else {
					switch_instance = null;
				}
			} else if (switch_value) {
				switch_instance.$set(switch_instance_changes);
			}
		},
		i(local) {
			if (current) return;
			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
			current = true;
		},
		o(local) {
			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(switch_instance_anchor);
			if (switch_instance) destroy_component(switch_instance, detaching);
		}
	};
}

function create_fragment$n(ctx) {
	let div3;
	let div0;
	let sidebar0;
	let t0;
	let div1;
	let formbuilder;
	let t1;
	let div2;
	let sidebar1;
	let current;

	sidebar0 = new Sidebar({
			props: {
				$$slots: { default: [create_default_slot_1] },
				$$scope: { ctx }
			}
		});

	formbuilder = new FormBuilder({});

	sidebar1 = new Sidebar({
			props: {
				$$slots: { default: [create_default_slot$1] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			div3 = element("div");
			div0 = element("div");
			create_component(sidebar0.$$.fragment);
			t0 = space();
			div1 = element("div");
			create_component(formbuilder.$$.fragment);
			t1 = space();
			div2 = element("div");
			create_component(sidebar1.$$.fragment);
			this.h();
		},
		l(nodes) {
			div3 = claim_element(nodes, "DIV", { class: true, id: true, style: true });
			var div3_nodes = children(div3);
			div0 = claim_element(div3_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			claim_component(sidebar0.$$.fragment, div0_nodes);
			div0_nodes.forEach(detach);
			t0 = claim_space(div3_nodes);
			div1 = claim_element(div3_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			claim_component(formbuilder.$$.fragment, div1_nodes);
			div1_nodes.forEach(detach);
			t1 = claim_space(div3_nodes);
			div2 = claim_element(div3_nodes, "DIV", { class: true });
			var div2_nodes = children(div2);
			claim_component(sidebar1.$$.fragment, div2_nodes);
			div2_nodes.forEach(detach);
			div3_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div0, "class", "left-sidebar svelte-sg77i1");
			attr(div1, "class", "main svelte-sg77i1");
			attr(div2, "class", "right-sidebar svelte-sg77i1");
			attr(div3, "class", "container-fluid clearfix svelte-sg77i1");
			attr(div3, "id", "main-container");
			set_style(div3, "margin-top", "3.9em");
		},
		m(target, anchor) {
			insert(target, div3, anchor);
			append(div3, div0);
			mount_component(sidebar0, div0, null);
			append(div3, t0);
			append(div3, div1);
			mount_component(formbuilder, div1, null);
			append(div3, t1);
			append(div3, div2);
			mount_component(sidebar1, div2, null);
			current = true;
		},
		p(ctx, [dirty]) {
			const sidebar0_changes = {};

			if (dirty & /*$$scope*/ 8) {
				sidebar0_changes.$$scope = { dirty, ctx };
			}

			sidebar0.$set(sidebar0_changes);
			const sidebar1_changes = {};

			if (dirty & /*$$scope, rightSidebar, rightSidebarProps*/ 11) {
				sidebar1_changes.$$scope = { dirty, ctx };
			}

			sidebar1.$set(sidebar1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(sidebar0.$$.fragment, local);
			transition_in(formbuilder.$$.fragment, local);
			transition_in(sidebar1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(sidebar0.$$.fragment, local);
			transition_out(formbuilder.$$.fragment, local);
			transition_out(sidebar1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div3);
			destroy_component(sidebar0);
			destroy_component(formbuilder);
			destroy_component(sidebar1);
		}
	};
}

function instance$n($$self, $$props, $$invalidate) {
	var __rest = this && this.__rest || function (s, e) {
		var t = {};
		for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];

		if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
			if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
		}

		return t;
	};

	
	let rightSidebar;
	let rightSidebarProps = {};

	onMount(() => {
		$$invalidate(0, rightSidebar = FieldEditSidebar);

		subscribe("show_right_sidebar", _a => {
			var { component } = _a, other = __rest(_a, ["component"]);
			$$invalidate(0, rightSidebar = component);
			$$invalidate(1, rightSidebarProps = other !== null && other !== void 0 ? other : {});
		});
	});

	return [rightSidebar, rightSidebarProps];
}

class Builder extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$n, create_fragment$n, safe_not_equal, {});
	}
}

export default Builder;
