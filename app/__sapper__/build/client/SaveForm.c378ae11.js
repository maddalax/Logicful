import { S as SvelteComponent, i as init, s as safe_not_equal, e as element, k as space, c as claim_element, a as children, d as detach, l as claim_space, f as attr, g as set_style, h as insert, j as append, C as listen, G as stop_propagation, n as noop, I as run_all, a0 as toggle_class, A as group_outros, u as transition_out, B as check_outros, r as transition_in, o as onMount, x as dispatch, t as text, b as claim_text, y as set_data, m as create_component, p as claim_component, q as mount_component, v as destroy_component, a1 as assign, Z as get_spread_update, _ as get_spread_object, z as subscribe, a7 as __awaiter, w as goto } from './client.a93cf518.js';
import { F as FieldValueLoader, f as formStore, a as FullName, R as RadioGroup, C as CheckboxGroup, b as FileUpload, D as DatePicker, S as Switch, c as Spacer, T as TextArea, d as RichTextDisplay, e as ComboBox, g as TextInput, A as Address, h as firstNotEmpty } from './FileUpload.6e1eb6f3.js';
import { L as LoadState, r as randomString, f as fastClone } from './fuse.esm.4840cecb.js';
import { p as putApi, a as postApi } from './ApiService.7fbbc2d7.js';

/* src\features\form\edit\Field.svelte generated by Svelte v3.24.1 */

function create_if_block_15(ctx) {
	let div;
	let button0;
	let span1;
	let span0;
	let t;
	let button1;
	let span3;
	let span2;
	let mounted;
	let dispose;

	return {
		c() {
			div = element("div");
			button0 = element("button");
			span1 = element("span");
			span0 = element("span");
			t = space();
			button1 = element("button");
			span3 = element("span");
			span2 = element("span");
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", {
				class: true,
				role: true,
				"aria-label": true,
				style: true
			});

			var div_nodes = children(div);
			button0 = claim_element(div_nodes, "BUTTON", { type: true, class: true, style: true });
			var button0_nodes = children(button0);
			span1 = claim_element(button0_nodes, "SPAN", { class: true });
			var span1_nodes = children(span1);
			span0 = claim_element(span1_nodes, "SPAN", { class: true });
			children(span0).forEach(detach);
			span1_nodes.forEach(detach);
			button0_nodes.forEach(detach);
			t = claim_space(div_nodes);
			button1 = claim_element(div_nodes, "BUTTON", { type: true, class: true, style: true });
			var button1_nodes = children(button1);
			span3 = claim_element(button1_nodes, "SPAN", { class: true });
			var span3_nodes = children(span3);
			span2 = claim_element(span3_nodes, "SPAN", { class: true });
			children(span2).forEach(detach);
			span3_nodes.forEach(detach);
			button1_nodes.forEach(detach);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(span0, "class", "far fa-clone");
			attr(span1, "class", "icon-brand");
			attr(button0, "type", "button");
			attr(button0, "class", "btn btn-secondary svelte-blsrvm");
			set_style(button0, "font-size", "0.5rem");
			set_style(button0, "padding", "0.25rem 0.5rem");
			attr(span2, "class", "fas fa-trash");
			attr(span3, "class", "icon-brand");
			attr(button1, "type", "button");
			attr(button1, "class", "btn btn-secondary svelte-blsrvm");
			set_style(button1, "font-size", "0.5rem");
			set_style(button1, "padding", "0.25rem 0.5rem");
			attr(div, "class", "btn-group float-right svelte-blsrvm");
			attr(div, "role", "group");
			attr(div, "aria-label", "Selected");
			set_style(div, "top", "-0.5em");
			set_style(div, "right", "1em");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, button0);
			append(button0, span1);
			append(span1, span0);
			append(div, t);
			append(div, button1);
			append(button1, span3);
			append(span3, span2);

			if (!mounted) {
				dispose = [
					listen(button0, "click", stop_propagation(/*onClone*/ ctx[5])),
					listen(button1, "click", stop_propagation(/*click_handler*/ ctx[9]))
				];

				mounted = true;
			}
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(div);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (141:4) {:else}
function create_else_block(ctx) {
	let p;
	let t0;
	let t1_value = JSON.stringify(/*field*/ ctx[0], null, 2) + "";
	let t1;

	return {
		c() {
			p = element("p");
			t0 = text("No field found for field. ");
			t1 = text(t1_value);
		},
		l(nodes) {
			p = claim_element(nodes, "P", {});
			var p_nodes = children(p);
			t0 = claim_text(p_nodes, "No field found for field. ");
			t1 = claim_text(p_nodes, t1_value);
			p_nodes.forEach(detach);
		},
		m(target, anchor) {
			insert(target, p, anchor);
			append(p, t0);
			append(p, t1);
		},
		p(ctx, dirty) {
			if (dirty & /*field*/ 1 && t1_value !== (t1_value = JSON.stringify(/*field*/ ctx[0], null, 2) + "")) set_data(t1, t1_value);
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(p);
		}
	};
}

// (139:41) 
function create_if_block_14(ctx) {
	let fullname;
	let current;

	fullname = new FullName({
			props: {
				field: /*field*/ ctx[0],
				value: /*value*/ ctx[4]
			}
		});

	return {
		c() {
			create_component(fullname.$$.fragment);
		},
		l(nodes) {
			claim_component(fullname.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(fullname, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const fullname_changes = {};
			if (dirty & /*field*/ 1) fullname_changes.field = /*field*/ ctx[0];
			if (dirty & /*value*/ 16) fullname_changes.value = /*value*/ ctx[4];
			fullname.$set(fullname_changes);
		},
		i(local) {
			if (current) return;
			transition_in(fullname.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(fullname.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(fullname, detaching);
		}
	};
}

// (137:43) 
function create_if_block_13(ctx) {
	let radiogroup;
	let current;
	radiogroup = new RadioGroup({ props: { field: /*field*/ ctx[0] } });

	return {
		c() {
			create_component(radiogroup.$$.fragment);
		},
		l(nodes) {
			claim_component(radiogroup.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(radiogroup, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const radiogroup_changes = {};
			if (dirty & /*field*/ 1) radiogroup_changes.field = /*field*/ ctx[0];
			radiogroup.$set(radiogroup_changes);
		},
		i(local) {
			if (current) return;
			transition_in(radiogroup.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(radiogroup.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(radiogroup, detaching);
		}
	};
}

// (135:46) 
function create_if_block_12(ctx) {
	let checkboxgroup;
	let current;
	checkboxgroup = new CheckboxGroup({ props: { field: /*field*/ ctx[0] } });

	return {
		c() {
			create_component(checkboxgroup.$$.fragment);
		},
		l(nodes) {
			claim_component(checkboxgroup.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(checkboxgroup, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const checkboxgroup_changes = {};
			if (dirty & /*field*/ 1) checkboxgroup_changes.field = /*field*/ ctx[0];
			checkboxgroup.$set(checkboxgroup_changes);
		},
		i(local) {
			if (current) return;
			transition_in(checkboxgroup.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(checkboxgroup.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(checkboxgroup, detaching);
		}
	};
}

// (133:36) 
function create_if_block_11(ctx) {
	let fileupload;
	let current;
	fileupload = new FileUpload({ props: { field: /*field*/ ctx[0] } });

	return {
		c() {
			create_component(fileupload.$$.fragment);
		},
		l(nodes) {
			claim_component(fileupload.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(fileupload, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const fileupload_changes = {};
			if (dirty & /*field*/ 1) fileupload_changes.field = /*field*/ ctx[0];
			fileupload.$set(fileupload_changes);
		},
		i(local) {
			if (current) return;
			transition_in(fileupload.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(fileupload.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(fileupload, detaching);
		}
	};
}

// (129:43) 
function create_if_block_10(ctx) {
	let div;
	let p;
	let t;

	return {
		c() {
			div = element("div");
			p = element("p");
			t = text("You have no fields, drag one from the left sidebar to get started.");
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			p = claim_element(div_nodes, "P", {});
			var p_nodes = children(p);
			t = claim_text(p_nodes, "You have no fields, drag one from the left sidebar to get started.");
			p_nodes.forEach(detach);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "placeholder svelte-blsrvm");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, p);
			append(p, t);
		},
		p: noop,
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

// (127:36) 
function create_if_block_9(ctx) {
	let datepicker;
	let current;
	const datepicker_spread_levels = [{ field: /*field*/ ctx[0] }, /*config*/ ctx[2]];
	let datepicker_props = {};

	for (let i = 0; i < datepicker_spread_levels.length; i += 1) {
		datepicker_props = assign(datepicker_props, datepicker_spread_levels[i]);
	}

	datepicker = new DatePicker({ props: datepicker_props });

	return {
		c() {
			create_component(datepicker.$$.fragment);
		},
		l(nodes) {
			claim_component(datepicker.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(datepicker, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const datepicker_changes = (dirty & /*field, config*/ 5)
			? get_spread_update(datepicker_spread_levels, [
					dirty & /*field*/ 1 && { field: /*field*/ ctx[0] },
					dirty & /*config*/ 4 && get_spread_object(/*config*/ ctx[2])
				])
			: {};

			datepicker.$set(datepicker_changes);
		},
		i(local) {
			if (current) return;
			transition_in(datepicker.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(datepicker.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(datepicker, detaching);
		}
	};
}

// (125:38) 
function create_if_block_8(ctx) {
	let switch_1;
	let current;
	const switch_1_spread_levels = [{ field: /*field*/ ctx[0] }, /*config*/ ctx[2]];
	let switch_1_props = {};

	for (let i = 0; i < switch_1_spread_levels.length; i += 1) {
		switch_1_props = assign(switch_1_props, switch_1_spread_levels[i]);
	}

	switch_1 = new Switch({ props: switch_1_props });

	return {
		c() {
			create_component(switch_1.$$.fragment);
		},
		l(nodes) {
			claim_component(switch_1.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(switch_1, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const switch_1_changes = (dirty & /*field, config*/ 5)
			? get_spread_update(switch_1_spread_levels, [
					dirty & /*field*/ 1 && { field: /*field*/ ctx[0] },
					dirty & /*config*/ 4 && get_spread_object(/*config*/ ctx[2])
				])
			: {};

			switch_1.$set(switch_1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(switch_1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(switch_1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(switch_1, detaching);
		}
	};
}

// (123:38) 
function create_if_block_7(ctx) {
	let spacer;
	let current;
	spacer = new Spacer({ props: { field: /*field*/ ctx[0] } });

	return {
		c() {
			create_component(spacer.$$.fragment);
		},
		l(nodes) {
			claim_component(spacer.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(spacer, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const spacer_changes = {};
			if (dirty & /*field*/ 1) spacer_changes.field = /*field*/ ctx[0];
			spacer.$set(spacer_changes);
		},
		i(local) {
			if (current) return;
			transition_in(spacer.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(spacer.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(spacer, detaching);
		}
	};
}

// (121:44) 
function create_if_block_6(ctx) {
	let textarea;
	let current;
	const textarea_spread_levels = [{ field: /*field*/ ctx[0] }, /*config*/ ctx[2], { isPreview: true }];
	let textarea_props = {};

	for (let i = 0; i < textarea_spread_levels.length; i += 1) {
		textarea_props = assign(textarea_props, textarea_spread_levels[i]);
	}

	textarea = new TextArea({ props: textarea_props });

	return {
		c() {
			create_component(textarea.$$.fragment);
		},
		l(nodes) {
			claim_component(textarea.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(textarea, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const textarea_changes = (dirty & /*field, config*/ 5)
			? get_spread_update(textarea_spread_levels, [
					dirty & /*field*/ 1 && { field: /*field*/ ctx[0] },
					dirty & /*config*/ 4 && get_spread_object(/*config*/ ctx[2]),
					textarea_spread_levels[2]
				])
			: {};

			textarea.$set(textarea_changes);
		},
		i(local) {
			if (current) return;
			transition_in(textarea.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(textarea.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(textarea, detaching);
		}
	};
}

// (119:37) 
function create_if_block_5(ctx) {
	let richtextdisplay;
	let current;
	richtextdisplay = new RichTextDisplay({ props: { field: /*field*/ ctx[0] } });

	return {
		c() {
			create_component(richtextdisplay.$$.fragment);
		},
		l(nodes) {
			claim_component(richtextdisplay.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(richtextdisplay, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const richtextdisplay_changes = {};
			if (dirty & /*field*/ 1) richtextdisplay_changes.field = /*field*/ ctx[0];
			richtextdisplay.$set(richtextdisplay_changes);
		},
		i(local) {
			if (current) return;
			transition_in(richtextdisplay.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(richtextdisplay.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(richtextdisplay, detaching);
		}
	};
}

// (117:40) 
function create_if_block_4(ctx) {
	let combobox;
	let current;
	const combobox_spread_levels = [{ field: /*field*/ ctx[0] }, /*config*/ ctx[2]];
	let combobox_props = {};

	for (let i = 0; i < combobox_spread_levels.length; i += 1) {
		combobox_props = assign(combobox_props, combobox_spread_levels[i]);
	}

	combobox = new ComboBox({ props: combobox_props });

	return {
		c() {
			create_component(combobox.$$.fragment);
		},
		l(nodes) {
			claim_component(combobox.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(combobox, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const combobox_changes = (dirty & /*field, config*/ 5)
			? get_spread_update(combobox_spread_levels, [
					dirty & /*field*/ 1 && { field: /*field*/ ctx[0] },
					dirty & /*config*/ 4 && get_spread_object(/*config*/ ctx[2])
				])
			: {};

			combobox.$set(combobox_changes);
		},
		i(local) {
			if (current) return;
			transition_in(combobox.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(combobox.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(combobox, detaching);
		}
	};
}

// (115:38) 
function create_if_block_3(ctx) {
	let textinput;
	let current;

	textinput = new TextInput({
			props: { field: /*field*/ ctx[0], type: "number" }
		});

	return {
		c() {
			create_component(textinput.$$.fragment);
		},
		l(nodes) {
			claim_component(textinput.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(textinput, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const textinput_changes = {};
			if (dirty & /*field*/ 1) textinput_changes.field = /*field*/ ctx[0];
			textinput.$set(textinput_changes);
		},
		i(local) {
			if (current) return;
			transition_in(textinput.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(textinput.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(textinput, detaching);
		}
	};
}

// (113:38) 
function create_if_block_2(ctx) {
	let textinput;
	let current;
	textinput = new TextInput({ props: { field: /*field*/ ctx[0] } });

	return {
		c() {
			create_component(textinput.$$.fragment);
		},
		l(nodes) {
			claim_component(textinput.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(textinput, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const textinput_changes = {};
			if (dirty & /*field*/ 1) textinput_changes.field = /*field*/ ctx[0];
			textinput.$set(textinput_changes);
		},
		i(local) {
			if (current) return;
			transition_in(textinput.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(textinput.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(textinput, detaching);
		}
	};
}

// (111:39) 
function create_if_block_1(ctx) {
	let address;
	let current;

	address = new Address({
			props: {
				field: /*field*/ ctx[0],
				value: /*value*/ ctx[4]
			}
		});

	return {
		c() {
			create_component(address.$$.fragment);
		},
		l(nodes) {
			claim_component(address.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(address, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const address_changes = {};
			if (dirty & /*field*/ 1) address_changes.field = /*field*/ ctx[0];
			if (dirty & /*value*/ 16) address_changes.value = /*value*/ ctx[4];
			address.$set(address_changes);
		},
		i(local) {
			if (current) return;
			transition_in(address.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(address.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(address, detaching);
		}
	};
}

// (109:4) {#if hidden}
function create_if_block(ctx) {
	let p;
	let t0_value = firstNotEmpty(/*field*/ ctx[0].label, /*field*/ ctx[0].name) + "";
	let t0;
	let t1;

	return {
		c() {
			p = element("p");
			t0 = text(t0_value);
			t1 = text(" is hidden by rules defined in logic. This message is only displayed on this preview.");
		},
		l(nodes) {
			p = claim_element(nodes, "P", {});
			var p_nodes = children(p);
			t0 = claim_text(p_nodes, t0_value);
			t1 = claim_text(p_nodes, " is hidden by rules defined in logic. This message is only displayed on this preview.");
			p_nodes.forEach(detach);
		},
		m(target, anchor) {
			insert(target, p, anchor);
			append(p, t0);
			append(p, t1);
		},
		p(ctx, dirty) {
			if (dirty & /*field*/ 1 && t0_value !== (t0_value = firstNotEmpty(/*field*/ ctx[0].label, /*field*/ ctx[0].name) + "")) set_data(t0, t0_value);
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(p);
		}
	};
}

function create_fragment(ctx) {
	let div1;
	let t;
	let div0;
	let current_block_type_index;
	let if_block1;
	let div0_style_value;
	let current;
	let mounted;
	let dispose;
	let if_block0 = /*field*/ ctx[0].selected && create_if_block_15(ctx);

	const if_block_creators = [
		create_if_block,
		create_if_block_1,
		create_if_block_2,
		create_if_block_3,
		create_if_block_4,
		create_if_block_5,
		create_if_block_6,
		create_if_block_7,
		create_if_block_8,
		create_if_block_9,
		create_if_block_10,
		create_if_block_11,
		create_if_block_12,
		create_if_block_13,
		create_if_block_14,
		create_else_block
	];

	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*hidden*/ ctx[3]) return 0;
		if (/*field*/ ctx[0].type === "address") return 1;
		if (/*field*/ ctx[0].type === "string") return 2;
		if (/*field*/ ctx[0].type === "number") return 3;
		if (/*field*/ ctx[0].type === "combobox") return 4;
		if (/*field*/ ctx[0].type === "block") return 5;
		if (/*field*/ ctx[0].type === "block-editor") return 6;
		if (/*field*/ ctx[0].type === "spacer") return 7;
		if (/*field*/ ctx[0].type === "switch") return 8;
		if (/*field*/ ctx[0].type === "date") return 9;
		if (/*field*/ ctx[0].type === "placeholder") return 10;
		if (/*field*/ ctx[0].type === "file") return 11;
		if (/*field*/ ctx[0].type === "checkbox-group") return 12;
		if (/*field*/ ctx[0].type === "radio-group") return 13;
		if (/*field*/ ctx[0].type === "full-name") return 14;
		return 15;
	}

	current_block_type_index = select_block_type(ctx);
	if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			div1 = element("div");
			if (if_block0) if_block0.c();
			t = space();
			div0 = element("div");
			if_block1.c();
			this.h();
		},
		l(nodes) {
			div1 = claim_element(nodes, "DIV", { style: true, class: true });
			var div1_nodes = children(div1);
			if (if_block0) if_block0.l(div1_nodes);
			t = claim_space(div1_nodes);
			div0 = claim_element(div1_nodes, "DIV", { style: true });
			var div0_nodes = children(div0);
			if_block1.l(div0_nodes);
			div0_nodes.forEach(detach);
			div1_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div0, "style", div0_style_value = /*styles*/ ctx[6]());
			set_style(div1, "margin-top", ".3em");
			attr(div1, "class", "svelte-blsrvm");
			toggle_class(div1, "hidden", /*hidden*/ ctx[3]);
			toggle_class(div1, "wrapper", !/*field*/ ctx[0].configTarget && !/*editor*/ ctx[1]);
			toggle_class(div1, "selected", /*field*/ ctx[0].selected);
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			if (if_block0) if_block0.m(div1, null);
			append(div1, t);
			append(div1, div0);
			if_blocks[current_block_type_index].m(div0, null);
			current = true;

			if (!mounted) {
				dispose = listen(div1, "click", stop_propagation(/*select*/ ctx[7]));
				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (/*field*/ ctx[0].selected) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_15(ctx);
					if_block0.c();
					if_block0.m(div1, t);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block1 = if_blocks[current_block_type_index];

				if (!if_block1) {
					if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block1.c();
				}

				transition_in(if_block1, 1);
				if_block1.m(div0, null);
			}

			if (dirty & /*hidden*/ 8) {
				toggle_class(div1, "hidden", /*hidden*/ ctx[3]);
			}

			if (dirty & /*field, editor*/ 3) {
				toggle_class(div1, "wrapper", !/*field*/ ctx[0].configTarget && !/*editor*/ ctx[1]);
			}

			if (dirty & /*field*/ 1) {
				toggle_class(div1, "selected", /*field*/ ctx[0].selected);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block1);
			current = true;
		},
		o(local) {
			transition_out(if_block1);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div1);
			if (if_block0) if_block0.d();
			if_blocks[current_block_type_index].d();
			mounted = false;
			dispose();
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
		function adopt(value) {
			return value instanceof P
			? value
			: new P(function (resolve) {
						resolve(value);
					});
		}

		return new (P || (P = Promise))(function (resolve, reject) {
				function fulfilled(value) {
					try {
						step(generator.next(value));
					} catch(e) {
						reject(e);
					}
				}

				function rejected(value) {
					try {
						step(generator["throw"](value));
					} catch(e) {
						reject(e);
					}
				}

				function step(result) {
					result.done
					? resolve(result.value)
					: adopt(result.value).then(fulfilled, rejected);
				}

				step((generator = generator.apply(thisArg, _arguments || [])).next());
			});
	};

	
	let { field } = $$props;
	let state = LoadState.NotStarted;
	let value;
	let lastValue;
	let { editor = false } = $$props;
	let { config = {} } = $$props;
	let { hidden = false } = $$props;
	let { padding = true } = $$props;
	onMount(load);

	function onClone() {
		dispatch("field_clone", { field });
	}

	function styles() {
		let style = "";

		if (padding) {
			style = `padding: .75em 0.6em; border-radius: 1em;`;
		}

		if (field.customCss) {
			style += ` ${field.customCss} padding-left: 0.6em;`;
		}

		return style;
	}

	function select() {
		if (field.configTarget || editor) {
			return;
		}

		$$invalidate(0, field.selected = !field.selected, field);

		formStore.set(field, {
			field: "selected",
			value: field.selected,
			fromUser: false
		});
	}

	function load() {
		var _a;

		return __awaiter(this, void 0, void 0, function* () {
			lastValue = field.value;

			if (((_a = field.value) !== null && _a !== void 0
			? _a
			: field.defaultValue) != null) {
				state = LoadState.Loading;

				try {
					const loader = new FieldValueLoader();
					const result = yield loader.load(field);
					$$invalidate(4, value = result);
					$$invalidate(0, field.value = result, field);

					formStore.set(field, {
						value: result,
						field: "value",
						fromUser: false
					});

					state = LoadState.Finished;
				} catch(e) {
					console.error(e);
					state = LoadState.Failed;
				}
			}
		});
	}

	const click_handler = () => dispatch("confirm_field_deletion", {});

	$$self.$$set = $$props => {
		if ("field" in $$props) $$invalidate(0, field = $$props.field);
		if ("editor" in $$props) $$invalidate(1, editor = $$props.editor);
		if ("config" in $$props) $$invalidate(2, config = $$props.config);
		if ("hidden" in $$props) $$invalidate(3, hidden = $$props.hidden);
		if ("padding" in $$props) $$invalidate(8, padding = $$props.padding);
	};

	return [
		field,
		editor,
		config,
		hidden,
		value,
		onClone,
		styles,
		select,
		padding,
		click_handler
	];
}

class Field extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance, create_fragment, safe_not_equal, {
			field: 0,
			editor: 1,
			config: 2,
			hidden: 3,
			padding: 8
		});
	}
}

/* src\features\form\edit\FormEditSettings.svelte generated by Svelte v3.24.1 */

function create_fragment$1(ctx) {
	let field0;
	let t0;
	let field1;
	let t1;
	let h2;
	let t2;
	let t3;
	let field2;
	let t4;
	let field3;
	let t5;
	let field4;
	let t6;
	let field5;
	let current;

	field0 = new Field({
			props: {
				field: {
					id: randomString(),
					required: true,
					label: "Form Title",
					value: {
						type: "local",
						value: /*form*/ ctx[0].title
					},
					type: "string",
					configFieldTarget: "title",
					configTarget: "form"
				}
			}
		});

	field1 = new Field({
			props: {
				field: {
					id: randomString(),
					required: true,
					label: "Form Description",
					value: {
						type: "local",
						value: /*form*/ ctx[0].description
					},
					type: "string",
					configFieldTarget: "description",
					configTarget: "form"
				}
			}
		});

	field2 = new Field({
			props: {
				field: {
					id: randomString(),
					type: "switch",
					label: "Disable Summisions",
					value: {
						type: "local",
						value: /*form*/ ctx[0].disableSubmissions ?? false
					},
					configFieldTarget: "disableSubmissions",
					configTarget: "form"
				}
			}
		});

	field3 = new Field({
			props: {
				field: {
					id: randomString(),
					type: "switch",
					label: "Disable after a maximum number of submissions",
					value: {
						type: "local",
						value: /*form*/ ctx[0].maxSubmissions ?? false
					},
					configFieldTarget: "maxSubmissions",
					configTarget: "form"
				}
			}
		});

	field4 = new Field({
			props: {
				field: {
					id: randomString(),
					type: "date",
					required: true,
					label: "Submissions open after date/time",
					value: {
						type: "local",
						value: /*form*/ ctx[0].openDateTime ?? ""
					},
					configFieldTarget: "openDateTime",
					configTarget: "form"
				}
			}
		});

	field5 = new Field({
			props: {
				field: {
					id: randomString(),
					type: "date",
					required: true,
					label: "Submissions close after date/time ",
					value: {
						type: "local",
						value: /*form*/ ctx[0].closeDateTime ?? ""
					},
					configFieldTarget: "closeDateTime",
					configTarget: "form"
				}
			}
		});

	return {
		c() {
			create_component(field0.$$.fragment);
			t0 = space();
			create_component(field1.$$.fragment);
			t1 = space();
			h2 = element("h2");
			t2 = text("Form Availability");
			t3 = space();
			create_component(field2.$$.fragment);
			t4 = space();
			create_component(field3.$$.fragment);
			t5 = space();
			create_component(field4.$$.fragment);
			t6 = space();
			create_component(field5.$$.fragment);
			this.h();
		},
		l(nodes) {
			claim_component(field0.$$.fragment, nodes);
			t0 = claim_space(nodes);
			claim_component(field1.$$.fragment, nodes);
			t1 = claim_space(nodes);
			h2 = claim_element(nodes, "H2", { class: true, style: true });
			var h2_nodes = children(h2);
			t2 = claim_text(h2_nodes, "Form Availability");
			h2_nodes.forEach(detach);
			t3 = claim_space(nodes);
			claim_component(field2.$$.fragment, nodes);
			t4 = claim_space(nodes);
			claim_component(field3.$$.fragment, nodes);
			t5 = claim_space(nodes);
			claim_component(field4.$$.fragment, nodes);
			t6 = claim_space(nodes);
			claim_component(field5.$$.fragment, nodes);
			this.h();
		},
		h() {
			attr(h2, "class", "h5");
			set_style(h2, "padding-top", "2em");
		},
		m(target, anchor) {
			mount_component(field0, target, anchor);
			insert(target, t0, anchor);
			mount_component(field1, target, anchor);
			insert(target, t1, anchor);
			insert(target, h2, anchor);
			append(h2, t2);
			insert(target, t3, anchor);
			mount_component(field2, target, anchor);
			insert(target, t4, anchor);
			mount_component(field3, target, anchor);
			insert(target, t5, anchor);
			mount_component(field4, target, anchor);
			insert(target, t6, anchor);
			mount_component(field5, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const field0_changes = {};

			if (dirty & /*form*/ 1) field0_changes.field = {
				id: randomString(),
				required: true,
				label: "Form Title",
				value: {
					type: "local",
					value: /*form*/ ctx[0].title
				},
				type: "string",
				configFieldTarget: "title",
				configTarget: "form"
			};

			field0.$set(field0_changes);
			const field1_changes = {};

			if (dirty & /*form*/ 1) field1_changes.field = {
				id: randomString(),
				required: true,
				label: "Form Description",
				value: {
					type: "local",
					value: /*form*/ ctx[0].description
				},
				type: "string",
				configFieldTarget: "description",
				configTarget: "form"
			};

			field1.$set(field1_changes);
			const field2_changes = {};

			if (dirty & /*form*/ 1) field2_changes.field = {
				id: randomString(),
				type: "switch",
				label: "Disable Summisions",
				value: {
					type: "local",
					value: /*form*/ ctx[0].disableSubmissions ?? false
				},
				configFieldTarget: "disableSubmissions",
				configTarget: "form"
			};

			field2.$set(field2_changes);
			const field3_changes = {};

			if (dirty & /*form*/ 1) field3_changes.field = {
				id: randomString(),
				type: "switch",
				label: "Disable after a maximum number of submissions",
				value: {
					type: "local",
					value: /*form*/ ctx[0].maxSubmissions ?? false
				},
				configFieldTarget: "maxSubmissions",
				configTarget: "form"
			};

			field3.$set(field3_changes);
			const field4_changes = {};

			if (dirty & /*form*/ 1) field4_changes.field = {
				id: randomString(),
				type: "date",
				required: true,
				label: "Submissions open after date/time",
				value: {
					type: "local",
					value: /*form*/ ctx[0].openDateTime ?? ""
				},
				configFieldTarget: "openDateTime",
				configTarget: "form"
			};

			field4.$set(field4_changes);
			const field5_changes = {};

			if (dirty & /*form*/ 1) field5_changes.field = {
				id: randomString(),
				type: "date",
				required: true,
				label: "Submissions close after date/time ",
				value: {
					type: "local",
					value: /*form*/ ctx[0].closeDateTime ?? ""
				},
				configFieldTarget: "closeDateTime",
				configTarget: "form"
			};

			field5.$set(field5_changes);
		},
		i(local) {
			if (current) return;
			transition_in(field0.$$.fragment, local);
			transition_in(field1.$$.fragment, local);
			transition_in(field2.$$.fragment, local);
			transition_in(field3.$$.fragment, local);
			transition_in(field4.$$.fragment, local);
			transition_in(field5.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(field0.$$.fragment, local);
			transition_out(field1.$$.fragment, local);
			transition_out(field2.$$.fragment, local);
			transition_out(field3.$$.fragment, local);
			transition_out(field4.$$.fragment, local);
			transition_out(field5.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(field0, detaching);
			if (detaching) detach(t0);
			destroy_component(field1, detaching);
			if (detaching) detach(t1);
			if (detaching) detach(h2);
			if (detaching) detach(t3);
			destroy_component(field2, detaching);
			if (detaching) detach(t4);
			destroy_component(field3, detaching);
			if (detaching) detach(t5);
			destroy_component(field4, detaching);
			if (detaching) detach(t6);
			destroy_component(field5, detaching);
		}
	};
}

function instance$1($$self, $$props, $$invalidate) {
	
	let { form } = $$props;

	onMount(() => {
		subscribe("form_loaded", updatedForm => {
			$$invalidate(0, form = updatedForm);
		});

		subscribe("form_updated", updatedForm => {
			$$invalidate(0, form = updatedForm);
		});
	});

	$$self.$$set = $$props => {
		if ("form" in $$props) $$invalidate(0, form = $$props.form);
	};

	return [form];
}

class FormEditSettings extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$1, create_fragment$1, safe_not_equal, { form: 0 });
	}
}

function saveForm() {
    return __awaiter(this, void 0, void 0, function* () {
        const form = formStore.getForm();
        const isNew = form.id == null;
        removeValues(form);
        const saved = yield save(form);
        form.id = saved.id;
        saveToLocalStorage(form);
        formStore.setForm(form);
        if (isNew) {
            goto('/builder?formId=' + form.id);
        }
    });
}
function saveToLocalStorage(form) {
    let copy = fastClone(form);
    copy = removeValues(copy);
    localStorage.setItem("form", JSON.stringify(copy));
}
function removeValues(form) {
    form.fields = form.fields.map(f => {
        delete (f.value);
        return f;
    });
    return form;
}
function save(form) {
    return __awaiter(this, void 0, void 0, function* () {
        return yield (form.id ? putApi(`form/${form.id}`, form) : postApi("form", form));
    });
}

export { Field as F, FormEditSettings as a, saveToLocalStorage as b, saveForm as s };
